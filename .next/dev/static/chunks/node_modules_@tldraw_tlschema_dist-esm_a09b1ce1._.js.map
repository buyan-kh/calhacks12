{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/id-validator.ts"],"sourcesContent":["import type { RecordId, UnknownRecord } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\n\n/**\n * Creates a validator for typed record IDs that ensures they follow the correct\n * format with the specified prefix. Record IDs in tldraw follow the pattern\n * \"prefix:identifier\" where the prefix indicates the record type.\n *\n * @param prefix - The required prefix for the ID (e.g., 'shape', 'page', 'asset')\n * @returns A validator that checks the ID format and returns the typed ID\n * @public\n * @example\n * ```ts\n * const shapeIdValidator = idValidator<TLShapeId>('shape')\n * const validId = shapeIdValidator.validate('shape:abc123') // Returns 'shape:abc123' as TLShapeId\n *\n * const pageIdValidator = idValidator<TLPageId>('page')\n * const pageId = pageIdValidator.validate('page:main') // Returns 'page:main' as TLPageId\n *\n * // This would throw an error:\n * // shapeIdValidator.validate('page:abc123') // Error: shape ID must start with \"shape:\"\n * ```\n */\nexport function idValidator<Id extends RecordId<UnknownRecord>>(\n\tprefix: Id['__type__']['typeName']\n): T.Validator<Id> {\n\treturn T.string.refine((id) => {\n\t\tif (!id.startsWith(`${prefix}:`)) {\n\t\t\tthrow new Error(`${prefix} ID must start with \"${prefix}:\"`)\n\t\t}\n\t\treturn id as Id\n\t})\n}\n"],"names":[],"mappings":";;;;;AACA,SAAS,SAAS;;AAsBX,SAAS,YACf,MAAA,EACkB;IAClB,OAAO,8MAAA,CAAE,MAAA,CAAO,MAAA,CAAO,CAAC,OAAO;QAC9B,IAAI,CAAC,GAAG,UAAA,CAAW,GAAG,MAAM,CAAA,CAAA,CAAG,GAAG;YACjC,MAAM,IAAI,MAAM,GAAG,MAAM,CAAA,qBAAA,EAAwB,MAAM,CAAA,EAAA,CAAI;QAC5D;QACA,OAAO;IACR,CAAC;AACF","debugId":null}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/assets/TLBaseAsset.ts"],"sourcesContent":["import { BaseRecord } from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { TLAssetId } from '../records/TLAsset'\n\n/**\n * Base interface for all asset records in tldraw. Assets represent external resources\n * like images, videos, or bookmarks that shapes can reference. This interface extends\n * the base record system with asset-specific typing.\n *\n * @param Type - The specific asset type identifier (e.g., 'image', 'video', 'bookmark')\n * @param Props - The properties object specific to this asset type\n *\n * @example\n * ```ts\n * // Define a custom asset type\n * interface MyCustomAsset extends TLBaseAsset<'custom', { url: string; title: string }> {}\n *\n * const customAsset: MyCustomAsset = {\n *   id: 'asset:custom123',\n *   typeName: 'asset',\n *   type: 'custom',\n *   props: {\n *     url: 'https://example.com',\n *     title: 'My Custom Asset'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport interface TLBaseAsset<Type extends string, Props> extends BaseRecord<'asset', TLAssetId> {\n\t/** The specific type of this asset (e.g., 'image', 'video', 'bookmark') */\n\ttype: Type\n\t/** Type-specific properties for this asset */\n\tprops: Props\n\t/** User-defined metadata that can be attached to this asset */\n\tmeta: JsonObject\n}\n\n/**\n * A validator for asset record type IDs. This validator ensures that asset IDs\n * follow the correct format and type structure required by tldraw's asset system.\n * Asset IDs are prefixed with 'asset:' followed by a unique identifier.\n *\n * @example\n * ```ts\n * import { assetIdValidator } from '@tldraw/tlschema'\n *\n * // Valid asset ID\n * const validId = 'asset:abc123'\n * console.log(assetIdValidator.isValid(validId)) // true\n *\n * // Invalid asset ID\n * const invalidId = 'shape:abc123'\n * console.log(assetIdValidator.isValid(invalidId)) // false\n * ```\n *\n * @public\n */\nexport const assetIdValidator = idValidator<TLAssetId>('asset')\n\n/**\n * Creates a validator for a specific asset record type. This factory function generates\n * a complete validator that validates the entire asset record structure including the\n * base properties (id, typeName, type, meta) and the type-specific props.\n *\n * @param type - The asset type identifier (e.g., 'image', 'video', 'bookmark')\n * @param props - The validator for the asset's type-specific properties\n * @returns A complete validator for the asset record type\n *\n * @example\n * ```ts\n * import { createAssetValidator, TLBaseAsset } from '@tldraw/tlschema'\n * import { T } from '@tldraw/validate'\n *\n * // Define a custom asset type\n * type TLCustomAsset = TLBaseAsset<'custom', {\n *   url: string\n *   title: string\n *   description?: string\n * }>\n *\n * // Create validator for the custom asset\n * const customAssetValidator = createAssetValidator('custom', T.object({\n *   url: T.string,\n *   title: T.string,\n *   description: T.string.optional()\n * }))\n *\n * // Use the validator\n * const assetData = {\n *   id: 'asset:custom123',\n *   typeName: 'asset' as const,\n *   type: 'custom' as const,\n *   props: {\n *     url: 'https://example.com',\n *     title: 'My Custom Asset'\n *   },\n *   meta: {}\n * }\n *\n * const validatedAsset = customAssetValidator.validate(assetData)\n * ```\n *\n * @public\n */\nexport function createAssetValidator<Type extends string, Props extends JsonObject>(\n\ttype: Type,\n\tprops: T.Validator<Props>\n) {\n\treturn T.object<{\n\t\tid: TLAssetId\n\t\ttypeName: 'asset'\n\t\ttype: Type\n\t\tprops: Props\n\t\tmeta: JsonObject\n\t}>({\n\t\tid: assetIdValidator,\n\t\ttypeName: T.literal('asset'),\n\t\ttype: T.literal(type),\n\t\tprops,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n}\n"],"names":[],"mappings":";;;;;;;AAEA,SAAS,SAAS;AAClB,SAAS,mBAAmB;;;AA2DrB,MAAM,uBAAmB,iMAAA,EAAuB,OAAO;AA+CvD,SAAS,qBACf,IAAA,EACA,KAAA,EACC;IACD,OAAO,8MAAA,CAAE,MAAA,CAMN;QACF,IAAI;QACJ,UAAU,8MAAA,CAAE,OAAA,CAAQ,OAAO;QAC3B,MAAM,8MAAA,CAAE,OAAA,CAAQ,IAAI;QACpB;QACA,MAAM,8MAAA,CAAE,SAAA;IACT,CAAC;AACF","debugId":null}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/geometry-types.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\n\n/**\n * A serializable model for 2D boxes.\n *\n * @public */\nexport interface BoxModel {\n\tx: number\n\ty: number\n\tw: number\n\th: number\n}\n\n/**\n * A serializable model for 2D vectors.\n *\n * @public */\nexport interface VecModel {\n\tx: number\n\ty: number\n\tz?: number\n}\n\n/**\n * Validator for VecModel objects that ensures they have numeric x and y coordinates,\n * with an optional z coordinate for 3D vectors. Used throughout the schema to\n * validate point and vector data structures.\n *\n * @public\n * @example\n * ```ts\n * const vector2D = { x: 10, y: 20 }\n * const isValid = vecModelValidator.check(vector2D) // true\n *\n * const vector3D = { x: 10, y: 20, z: 30 }\n * const isValid3D = vecModelValidator.check(vector3D) // true\n * ```\n */\nexport const vecModelValidator: T.ObjectValidator<VecModel> = T.object({\n\tx: T.number,\n\ty: T.number,\n\tz: T.number.optional(),\n})\n\n/**\n * Validator for BoxModel objects that ensures they have numeric x, y coordinates\n * for position and w, h values for width and height. Used throughout the schema\n * to validate bounding box and rectangular area data structures.\n *\n * @public\n * @example\n * ```ts\n * const box = { x: 10, y: 20, w: 100, h: 50 }\n * const isValid = boxModelValidator.check(box) // true\n *\n * const invalidBox = { x: 10, y: 20, w: -5, h: 50 }\n * const isValidNegative = boxModelValidator.check(invalidBox) // true (validator allows negative values)\n * ```\n */\nexport const boxModelValidator: T.ObjectValidator<BoxModel> = T.object({\n\tx: T.number,\n\ty: T.number,\n\tw: T.number,\n\th: T.number,\n})\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,SAAS;;AAsCX,MAAM,oBAAiD,8MAAA,CAAE,MAAA,CAAO;IACtE,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;AACtB,CAAC;AAiBM,MAAM,oBAAiD,8MAAA,CAAE,MAAA,CAAO;IACtE,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;AACN,CAAC","debugId":null}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLOpacity.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\n\n/**\n * A type representing opacity values in tldraw.\n *\n * Opacity values are numbers between 0 and 1, where 0 is fully transparent\n * and 1 is fully opaque. This type is used throughout the editor to control\n * the transparency of shapes, UI elements, and other visual components.\n *\n * @example\n * ```ts\n * const fullyOpaque: TLOpacityType = 1.0\n * const halfTransparent: TLOpacityType = 0.5\n * const fullyTransparent: TLOpacityType = 0.0\n * const quarterOpaque: TLOpacityType = 0.25\n * ```\n *\n * @public\n */\nexport type TLOpacityType = number\n\n/**\n * A validator for opacity values.\n *\n * This validator ensures that opacity values are numbers between 0 and 1 (inclusive).\n * Values outside this range will cause a validation error. The validator provides\n * runtime type checking for opacity properties throughout the editor.\n *\n * @param n - The number to validate as an opacity value\n * @throws T.ValidationError When the value is not between 0 and 1\n *\n * @example\n * ```ts\n * import { opacityValidator } from '@tldraw/tlschema'\n *\n * // Valid opacity values\n * try {\n *   const validOpacity1 = opacityValidator.validate(0.5) // \u2713\n *   const validOpacity2 = opacityValidator.validate(1.0) // \u2713\n *   const validOpacity3 = opacityValidator.validate(0.0) // \u2713\n * } catch (error) {\n *   console.error('Validation failed:', error.message)\n * }\n *\n * // Invalid opacity values\n * try {\n *   opacityValidator.validate(-0.1) // \u2717 Throws error\n *   opacityValidator.validate(1.5)  // \u2717 Throws error\n * } catch (error) {\n *   console.error('Invalid opacity:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const opacityValidator = T.number.check((n) => {\n\tif (n < 0 || n > 1) {\n\t\tthrow new T.ValidationError('Opacity must be between 0 and 1')\n\t}\n})\n"],"names":[],"mappings":";;;;;AAAA,SAAS,SAAS;;AAuDX,MAAM,mBAAmB,8MAAA,CAAE,MAAA,CAAO,KAAA,CAAM,CAAC,MAAM;IACrD,IAAI,IAAI,KAAK,IAAI,GAAG;QACnB,MAAM,IAAI,8MAAA,CAAE,eAAA,CAAgB,iCAAiC;IAC9D;AACD,CAAC","debugId":null}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLBaseShape.ts"],"sourcesContent":["import { BaseRecord } from '@tldraw/store'\nimport { IndexKey, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { TLOpacityType, opacityValidator } from '../misc/TLOpacity'\nimport { idValidator } from '../misc/id-validator'\nimport { TLParentId, TLShapeId } from '../records/TLShape'\n\n/**\n * Base interface for all shapes in tldraw.\n *\n * This interface defines the common properties that all shapes share, regardless of their\n * specific type. Every shape extends this base with additional type-specific properties.\n *\n * @example\n * ```ts\n * // Define a custom shape type\n * interface MyCustomShape extends TLBaseShape<'custom', { size: number; color: string }> {}\n *\n * // Create a shape instance\n * const myShape: MyCustomShape = {\n *   id: 'shape:abc123',\n *   typeName: 'shape',\n *   type: 'custom',\n *   x: 100,\n *   y: 200,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     size: 50,\n *     color: 'blue'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport interface TLBaseShape<Type extends string, Props extends object>\n\textends BaseRecord<'shape', TLShapeId> {\n\ttype: Type\n\tx: number\n\ty: number\n\trotation: number\n\tindex: IndexKey\n\tparentId: TLParentId\n\tisLocked: boolean\n\topacity: TLOpacityType\n\tprops: Props\n\tmeta: JsonObject\n}\n\n/**\n * Validator for parent IDs, ensuring they follow the correct format.\n *\n * Parent IDs must start with either \"page:\" (for shapes directly on a page)\n * or \"shape:\" (for shapes inside other shapes like frames or groups).\n *\n * @example\n * ```ts\n * // Valid parent IDs\n * const pageParent = parentIdValidator.validate('page:main') // \u2713\n * const shapeParent = parentIdValidator.validate('shape:frame1') // \u2713\n *\n * // Invalid parent ID (throws error)\n * const invalid = parentIdValidator.validate('invalid:123') // \u2717\n * ```\n *\n * @public\n */\nexport const parentIdValidator = T.string.refine((id) => {\n\tif (!id.startsWith('page:') && !id.startsWith('shape:')) {\n\t\tthrow new Error('Parent ID must start with \"page:\" or \"shape:\"')\n\t}\n\treturn id as TLParentId\n})\n\n/**\n * Validator for shape IDs, ensuring they follow the \"shape:\" format.\n *\n * @example\n * ```ts\n * const validId = shapeIdValidator.validate('shape:abc123') // \u2713\n * const invalidId = shapeIdValidator.validate('page:abc123') // \u2717 throws error\n * ```\n *\n * @public\n */\nexport const shapeIdValidator = idValidator<TLShapeId>('shape')\n\n/**\n * Creates a validator for a specific shape type.\n *\n * This function generates a complete validator that can validate shape records\n * of the specified type, including both the base shape properties and any\n * custom properties and metadata specific to that shape type.\n *\n * @param type - The string literal type for this shape (e.g., 'geo', 'arrow')\n * @param props - Optional validator configuration for shape-specific properties\n * @param meta - Optional validator configuration for shape-specific metadata\n * @returns A validator that can validate complete shape records of the specified type\n *\n * @example\n * ```ts\n * // Create a validator for a custom shape type\n * const customShapeValidator = createShapeValidator('custom', {\n *   width: T.number,\n *   height: T.number,\n *   color: T.string\n * })\n *\n * // Use the validator to validate shape data\n * const shapeData = {\n *   id: 'shape:abc123',\n *   typeName: 'shape',\n *   type: 'custom',\n *   x: 100,\n *   y: 200,\n *   // ... other base properties\n *   props: {\n *     width: 150,\n *     height: 100,\n *     color: 'red'\n *   }\n * }\n *\n * const validatedShape = customShapeValidator.validate(shapeData)\n * ```\n *\n * @public\n */\nexport function createShapeValidator<\n\tType extends string,\n\tProps extends JsonObject,\n\tMeta extends JsonObject,\n>(\n\ttype: Type,\n\tprops?: { [K in keyof Props]: T.Validatable<Props[K]> },\n\tmeta?: { [K in keyof Meta]: T.Validatable<Meta[K]> }\n) {\n\treturn T.object<TLBaseShape<Type, Props>>({\n\t\tid: shapeIdValidator,\n\t\ttypeName: T.literal('shape'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\trotation: T.number,\n\t\tindex: T.indexKey,\n\t\tparentId: parentIdValidator,\n\t\ttype: T.literal(type),\n\t\tisLocked: T.boolean,\n\t\topacity: opacityValidator,\n\t\tprops: props ? T.object(props) : (T.jsonValue as any),\n\t\tmeta: meta ? T.object(meta) : (T.jsonValue as any),\n\t})\n}\n"],"names":[],"mappings":";;;;;;;;;AAEA,SAAS,SAAS;AAClB,SAAwB,wBAAwB;AAChD,SAAS,mBAAmB;;;;AAoErB,MAAM,oBAAoB,8MAAA,CAAE,MAAA,CAAO,MAAA,CAAO,CAAC,OAAO;IACxD,IAAI,CAAC,GAAG,UAAA,CAAW,OAAO,KAAK,CAAC,GAAG,UAAA,CAAW,QAAQ,GAAG;QACxD,MAAM,IAAI,MAAM,+CAA+C;IAChE;IACA,OAAO;AACR,CAAC;AAaM,MAAM,uBAAmB,iMAAA,EAAuB,OAAO;AA2CvD,SAAS,qBAKf,IAAA,EACA,KAAA,EACA,IAAA,EACC;IACD,OAAO,8MAAA,CAAE,MAAA,CAAiC;QACzC,IAAI;QACJ,UAAU,8MAAA,CAAE,OAAA,CAAQ,OAAO;QAC3B,GAAG,8MAAA,CAAE,MAAA;QACL,GAAG,8MAAA,CAAE,MAAA;QACL,UAAU,8MAAA,CAAE,MAAA;QACZ,OAAO,8MAAA,CAAE,QAAA;QACT,UAAU;QACV,MAAM,8MAAA,CAAE,OAAA,CAAQ,IAAI;QACpB,UAAU,8MAAA,CAAE,OAAA;QACZ,SAAS,gMAAA;QACT,OAAO,QAAQ,8MAAA,CAAE,MAAA,CAAO,KAAK,IAAK,8MAAA,CAAE,SAAA;QACpC,MAAM,OAAO,8MAAA,CAAE,MAAA,CAAO,IAAI,IAAK,8MAAA,CAAE,SAAA;IAClC,CAAC;AACF","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/bindings/TLBaseBinding.ts"],"sourcesContent":["import { BaseRecord } from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { TLBindingId } from '../records/TLBinding'\nimport { TLShapeId } from '../records/TLShape'\nimport { shapeIdValidator } from '../shapes/TLBaseShape'\n\n/**\n * Base interface for all binding types in tldraw. Bindings represent relationships\n * between shapes, such as arrows connecting to other shapes or organizational connections.\n *\n * All bindings extend this base interface with specific type and property definitions.\n * The binding system enables shapes to maintain relationships that persist through\n * transformations, movements, and other operations.\n *\n * @param Type - String literal type identifying the specific binding type (e.g., 'arrow')\n * @param Props - Object containing binding-specific properties and configuration\n *\n * @example\n * ```ts\n * // Define a custom binding type\n * interface MyCustomBinding extends TLBaseBinding<'custom', MyCustomProps> {}\n *\n * interface MyCustomProps {\n *   strength: number\n *   color: string\n * }\n *\n * // Create a binding instance\n * const binding: MyCustomBinding = {\n *   id: 'binding:abc123',\n *   typeName: 'binding',\n *   type: 'custom',\n *   fromId: 'shape:source1',\n *   toId: 'shape:target1',\n *   props: {\n *     strength: 0.8,\n *     color: 'red'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport interface TLBaseBinding<Type extends string, Props extends object>\n\textends BaseRecord<'binding', TLBindingId> {\n\t/** The specific type of this binding (e.g., 'arrow', 'custom') */\n\ttype: Type\n\t/** ID of the source shape in this binding relationship */\n\tfromId: TLShapeId\n\t/** ID of the target shape in this binding relationship */\n\ttoId: TLShapeId\n\t/** Binding-specific properties that define behavior and appearance */\n\tprops: Props\n\t/** User-defined metadata for extending binding functionality */\n\tmeta: JsonObject\n}\n\n/**\n * Validator for binding IDs. Ensures that binding identifiers follow the correct\n * format and type constraints required by the tldraw schema system.\n *\n * Used internally by the schema validation system to verify binding IDs when\n * records are created or modified. All binding IDs must be prefixed with 'binding:'.\n *\n * @example\n * ```ts\n * import { bindingIdValidator } from '@tldraw/tlschema'\n *\n * // Validate a binding ID\n * const isValid = bindingIdValidator.isValid('binding:abc123') // true\n * const isInvalid = bindingIdValidator.isValid('shape:abc123') // false\n *\n * // Use in custom validation schema\n * const customBindingValidator = T.object({\n *   id: bindingIdValidator,\n *   // ... other properties\n * })\n * ```\n *\n * @public\n */\nexport const bindingIdValidator = idValidator<TLBindingId>('binding')\n\n/**\n * Creates a runtime validator for a specific binding type. This factory function\n * generates a complete validation schema for custom bindings that extends TLBaseBinding.\n *\n * The validator ensures all binding records conform to the expected structure with\n * proper type safety and runtime validation. It validates the base binding properties\n * (id, type, fromId, toId) along with custom props and meta fields.\n *\n * @param type - The string literal type identifier for this binding (e.g., 'arrow', 'custom')\n * @param props - Optional validation schema for binding-specific properties\n * @param meta - Optional validation schema for metadata fields\n *\n * @returns A validator object that can validate complete binding records\n *\n * @example\n * ```ts\n * import { createBindingValidator } from '@tldraw/tlschema'\n * import { T } from '@tldraw/validate'\n *\n * // Create validator for a custom binding type\n * const myBindingValidator = createBindingValidator(\n *   'myBinding',\n *   {\n *     strength: T.number,\n *     color: T.string,\n *     enabled: T.boolean\n *   },\n *   {\n *     createdAt: T.number,\n *     author: T.string\n *   }\n * )\n *\n * // Validate a binding instance\n * const bindingData = {\n *   id: 'binding:123',\n *   typeName: 'binding',\n *   type: 'myBinding',\n *   fromId: 'shape:abc',\n *   toId: 'shape:def',\n *   props: {\n *     strength: 0.8,\n *     color: 'red',\n *     enabled: true\n *   },\n *   meta: {\n *     createdAt: Date.now(),\n *     author: 'user123'\n *   }\n * }\n *\n * const isValid = myBindingValidator.isValid(bindingData) // true\n * ```\n *\n * @example\n * ```ts\n * // Simple binding without custom props or meta\n * const simpleBindingValidator = createBindingValidator('simple')\n *\n * // This will use JsonValue validation for props and meta\n * const binding = {\n *   id: 'binding:456',\n *   typeName: 'binding',\n *   type: 'simple',\n *   fromId: 'shape:start',\n *   toId: 'shape:end',\n *   props: {}, // Any JSON value allowed\n *   meta: {}   // Any JSON value allowed\n * }\n * ```\n *\n * @public\n */\nexport function createBindingValidator<\n\tType extends string,\n\tProps extends JsonObject,\n\tMeta extends JsonObject,\n>(\n\ttype: Type,\n\tprops?: { [K in keyof Props]: T.Validatable<Props[K]> },\n\tmeta?: { [K in keyof Meta]: T.Validatable<Meta[K]> }\n) {\n\treturn T.object<TLBaseBinding<Type, Props>>({\n\t\tid: bindingIdValidator,\n\t\ttypeName: T.literal('binding'),\n\t\ttype: T.literal(type),\n\t\tfromId: shapeIdValidator,\n\t\ttoId: shapeIdValidator,\n\t\tprops: props ? T.object(props) : (T.jsonValue as any),\n\t\tmeta: meta ? T.object(meta) : (T.jsonValue as any),\n\t})\n}\n"],"names":[],"mappings":";;;;;;;AAEA,SAAS,SAAS;AAClB,SAAS,mBAAmB;AAG5B,SAAS,wBAAwB;;;;AA8E1B,MAAM,yBAAqB,iMAAA,EAAyB,SAAS;AA2E7D,SAAS,uBAKf,IAAA,EACA,KAAA,EACA,IAAA,EACC;IACD,OAAO,8MAAA,CAAE,MAAA,CAAmC;QAC3C,IAAI;QACJ,UAAU,8MAAA,CAAE,OAAA,CAAQ,SAAS;QAC7B,MAAM,8MAAA,CAAE,OAAA,CAAQ,IAAI;QACpB,QAAQ,oMAAA;QACR,MAAM,oMAAA;QACN,OAAO,QAAQ,8MAAA,CAAE,MAAA,CAAO,KAAK,IAAK,8MAAA,CAAE,SAAA;QACpC,MAAM,OAAO,8MAAA,CAAE,MAAA,CAAO,IAAI,IAAK,8MAAA,CAAE,SAAA;IAClC,CAAC;AACF","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLBinding.ts"],"sourcesContent":["import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { Expand, mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { TLArrowBinding } from '../bindings/TLArrowBinding'\nimport { TLBaseBinding, createBindingValidator } from '../bindings/TLBaseBinding'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\n\n/**\n * The default set of bindings that are available in the editor.\n * Currently includes only arrow bindings, but can be extended with custom bindings.\n *\n * @example\n * ```ts\n * // Arrow binding connects an arrow to shapes\n * const arrowBinding: TLDefaultBinding = {\n *   id: 'binding:arrow1',\n *   typeName: 'binding',\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultBinding = TLArrowBinding\n\n/**\n * A type for a binding that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default bindings or else a custom binding.\n * Used internally for type-safe handling of bindings with unknown structure.\n *\n * @example\n * ```ts\n * // Function that works with any binding type\n * function processBinding(binding: TLUnknownBinding) {\n *   console.log(`Processing ${binding.type} binding from ${binding.fromId} to ${binding.toId}`)\n *   // Handle binding properties generically\n * }\n * ```\n *\n * @public\n */\nexport type TLUnknownBinding = TLBaseBinding<string, object>\n\n/**\n * The set of all bindings that are available in the editor, including unknown bindings.\n * Bindings represent relationships between shapes, such as arrows connecting to other shapes.\n *\n * @example\n * ```ts\n * // Check binding type and handle accordingly\n * function handleBinding(binding: TLBinding) {\n *   switch (binding.type) {\n *     case 'arrow':\n *       // Handle arrow binding\n *       break\n *     default:\n *       // Handle unknown custom binding\n *       break\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLBinding = TLDefaultBinding | TLUnknownBinding\n\n/**\n * Type for updating existing bindings with partial properties.\n * Only the id and type are required, all other properties are optional.\n *\n * @example\n * ```ts\n * // Update arrow binding properties\n * const bindingUpdate: TLBindingUpdate<TLArrowBinding> = {\n *   id: 'binding:arrow1',\n *   type: 'arrow',\n *   props: {\n *     normalizedAnchor: { x: 0.7, y: 0.3 } // Only update anchor position\n *   }\n * }\n *\n * editor.updateBindings([bindingUpdate])\n * ```\n *\n * @public\n */\nexport type TLBindingUpdate<T extends TLBinding = TLBinding> = Expand<{\n\tid: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId?: T['fromId']\n\ttoId?: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/**\n * Type for creating new bindings with required fromId and toId.\n * The id is optional and will be generated if not provided.\n *\n * @example\n * ```ts\n * // Create a new arrow binding\n * const newBinding: TLBindingCreate<TLArrowBinding> = {\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true\n *   }\n * }\n *\n * editor.createBindings([newBinding])\n * ```\n *\n * @public\n */\nexport type TLBindingCreate<T extends TLBinding = TLBinding> = Expand<{\n\tid?: TLBindingId\n\ttype: T['type']\n\ttypeName?: T['typeName']\n\tfromId: T['fromId']\n\ttoId: T['toId']\n\tprops?: Partial<T['props']>\n\tmeta?: Partial<T['meta']>\n}>\n\n/**\n * Branded string type for binding record identifiers.\n * Prevents mixing binding IDs with other types of record IDs at compile time.\n *\n * @example\n * ```ts\n * import { createBindingId } from '@tldraw/tlschema'\n *\n * // Create a new binding ID\n * const bindingId: TLBindingId = createBindingId()\n *\n * // Use in binding records\n * const binding: TLBinding = {\n *   id: bindingId,\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport type TLBindingId = RecordId<TLUnknownBinding>\n\n/**\n * Migration version identifiers for the root binding record schema.\n * Currently empty as no migrations have been applied to the base binding structure.\n *\n * @example\n * ```ts\n * // Future migrations would be defined here\n * const rootBindingVersions = createMigrationIds('com.tldraw.binding', {\n *   AddNewProperty: 1,\n * } as const)\n * ```\n *\n * @public\n */\nexport const rootBindingVersions = createMigrationIds('com.tldraw.binding', {} as const)\n\n/**\n * Migration sequence for the root binding record structure.\n * Currently empty as the binding schema has not required any migrations yet.\n *\n * @example\n * ```ts\n * // Migrations would be automatically applied when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n * ```\n *\n * @public\n */\nexport const rootBindingMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.binding',\n\trecordType: 'binding',\n\tsequence: [],\n})\n\n/**\n * Type guard to check if a record is a TLBinding.\n * Useful for filtering or type narrowing when working with mixed record types.\n *\n * @param record - The record to check\n * @returns True if the record is a binding, false otherwise\n *\n * @example\n * ```ts\n * // Filter bindings from mixed records\n * const allRecords = store.allRecords()\n * const bindings = allRecords.filter(isBinding)\n *\n * // Type guard usage\n * function processRecord(record: UnknownRecord) {\n *   if (isBinding(record)) {\n *     // record is now typed as TLBinding\n *     console.log(`Binding from ${record.fromId} to ${record.toId}`)\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function isBinding(record?: UnknownRecord): record is TLBinding {\n\tif (!record) return false\n\treturn record.typeName === 'binding'\n}\n\n/**\n * Type guard to check if a string is a valid TLBindingId.\n * Validates that the ID follows the correct format for binding identifiers.\n *\n * @param id - The string to check\n * @returns True if the string is a valid binding ID, false otherwise\n *\n * @example\n * ```ts\n * // Validate binding IDs\n * const maybeBindingId = 'binding:abc123'\n * if (isBindingId(maybeBindingId)) {\n *   // maybeBindingId is now typed as TLBindingId\n *   const binding = store.get(maybeBindingId)\n * }\n *\n * // Filter binding IDs from mixed ID array\n * const mixedIds = ['shape:1', 'binding:2', 'page:3']\n * const bindingIds = mixedIds.filter(isBindingId)\n * ```\n *\n * @public\n */\nexport function isBindingId(id?: string): id is TLBindingId {\n\tif (!id) return false\n\treturn id.startsWith('binding:')\n}\n\n/**\n * Creates a new TLBindingId with proper formatting.\n * Generates a unique ID if none is provided, or formats a provided ID correctly.\n *\n * @param id - Optional custom ID suffix. If not provided, a unique ID is generated\n * @returns A properly formatted binding ID\n *\n * @example\n * ```ts\n * // Create with auto-generated ID\n * const bindingId1 = createBindingId() // 'binding:abc123'\n *\n * // Create with custom ID\n * const bindingId2 = createBindingId('myCustomBinding') // 'binding:myCustomBinding'\n *\n * // Use in binding creation\n * const binding: TLBinding = {\n *   id: createBindingId(),\n *   type: 'arrow',\n *   fromId: 'shape:arrow1',\n *   toId: 'shape:rectangle1',\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport function createBindingId(id?: string): TLBindingId {\n\treturn `binding:${id ?? uniqueId()}` as TLBindingId\n}\n\n/**\n * Creates a migration sequence for binding properties.\n * This is a pass-through function that validates and returns the provided migrations.\n *\n * @param migrations - The migration sequence for binding properties\n * @returns The validated migration sequence\n *\n * @example\n * ```ts\n * // Define migrations for custom binding properties\n * const myBindingMigrations = createBindingPropsMigrationSequence({\n *   sequence: [\n *     {\n *       id: 'com.myapp.binding.custom/1.0.0',\n *       up: (props) => ({ ...props, newProperty: 'default' }),\n *       down: ({ newProperty, ...props }) => props\n *     }\n *   ]\n * })\n * ```\n *\n * @public\n */\nexport function createBindingPropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * Creates properly formatted migration IDs for binding property migrations.\n * Follows the convention: 'com.tldraw.binding.\\{bindingType\\}/\\{version\\}'\n *\n * @param bindingType - The type of binding these migrations apply to\n * @param ids - Object mapping migration names to version numbers\n * @returns Object with formatted migration IDs\n *\n * @example\n * ```ts\n * // Create migration IDs for custom binding\n * const myBindingVersions = createBindingPropsMigrationIds('myCustomBinding', {\n *   AddNewProperty: 1,\n *   UpdateProperty: 2\n * })\n *\n * // Result:\n * // {\n * //   AddNewProperty: 'com.tldraw.binding.myCustomBinding/1',\n * //   UpdateProperty: 'com.tldraw.binding.myCustomBinding/2'\n * // }\n * ```\n *\n * @public\n */\nexport function createBindingPropsMigrationIds<S extends string, T extends Record<string, number>>(\n\tbindingType: S,\n\tids: T\n): { [k in keyof T]: `com.tldraw.binding.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`) as any\n}\n\n/**\n * Creates a record type for TLBinding with validation based on the provided binding schemas.\n * This function is used internally to configure the binding record type in the schema.\n *\n * @param bindings - Record mapping binding type names to their schema information\n * @returns A configured record type for bindings with validation\n *\n * @example\n * ```ts\n * // Used internally when creating schemas\n * const bindingRecordType = createBindingRecordType({\n *   arrow: {\n *     props: arrowBindingProps,\n *     meta: arrowBindingMeta\n *   }\n * })\n * ```\n *\n * @internal\n */\nexport function createBindingRecordType(bindings: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLBinding>('binding', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'binding',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(bindings, (type, { props, meta }) =>\n\t\t\t\t\tcreateBindingValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tmeta: {},\n\t}))\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;AAOA,SAAiB,oBAAoB,gBAAgB;;AACrD,SAAS,SAAS;AAElB,SAAwB,8BAA8B;;;;;AA8K/C,MAAM,0BAAsB,4LAAA,EAAmB,sBAAsB,CAAC,CAAU;AAiBhF,MAAM,4BAAwB,uMAAA,EAA8B;IAClE,YAAY;IACZ,YAAY;IACZ,UAAU,CAAC,CAAA;AACZ,CAAC;AA0BM,SAAS,UAAU,MAAA,EAA6C;IACtE,IAAI,CAAC,OAAQ,CAAA,OAAO;IACpB,OAAO,OAAO,QAAA,KAAa;AAC5B;AAyBO,SAAS,YAAY,EAAA,EAAgC;IAC3D,IAAI,CAAC,GAAI,CAAA,OAAO;IAChB,OAAO,GAAG,UAAA,CAAW,UAAU;AAChC;AA6BO,SAAS,gBAAgB,EAAA,EAA0B;IACzD,OAAO,CAAA,QAAA,EAAW,UAAM,6KAAA,CAAS,CAAC,GAAA;AACnC;AAyBO,SAAS,oCACf,UAAA,EACoB;IACpB,OAAO;AACR;AA2BO,SAAS,+BACf,WAAA,EACA,GAAA,EACwD;IACxD,WAAO,2LAAA,EAAmB,KAAK,CAAC,IAAI,IAAM,CAAA,mBAAA,EAAsB,WAAW,CAAA,CAAA,EAAI,CAAC,EAAE;AACnF;AAsBO,SAAS,wBAAwB,QAAA,EAA2C;IAClF,WAAO,6LAAA,EAA4B,WAAW;QAC7C,OAAO;QACP,WAAW,8MAAA,CAAE,KAAA,CACZ,WACA,8MAAA,CAAE,KAAA,CACD,YACA,2LAAA,EAAmB,UAAU,CAAC,MAAM,EAAE,KAAA,EAAO,IAAA,CAAK,CAAA,OACjD,8MAAA,EAAuB,MAAM,OAAO,IAAI;IAI5C,CAAC,EAAE,qBAAA,CAAsB,IAAA,CAAO;YAC/B,MAAM,CAAC;QACR,CAAA,CAAE;AACH","debugId":null}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLRichText.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\n\n/**\n * Validator for TLRichText objects that ensures they have the correct structure\n * for document-based rich text content. Validates a document with a type field\n * and an array of content blocks.\n *\n * @public\n * @example\n * ```ts\n * const richText = { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello' }] }] }\n * const isValid = richTextValidator.check(richText) // true\n * ```\n */\nexport const richTextValidator = T.object({ type: T.string, content: T.arrayOf(T.unknown) })\n\n/**\n * Type representing rich text content in tldraw. Rich text follows a document-based\n * structure with a root document containing an array of content blocks (paragraphs,\n * text nodes, etc.). This enables formatted text with support for multiple paragraphs,\n * styling, and other rich content.\n *\n * @public\n * @example\n * ```ts\n * const richText: TLRichText = {\n *   type: 'doc',\n *   content: [\n *     {\n *       type: 'paragraph',\n *       content: [{ type: 'text', text: 'Hello world!' }]\n *     }\n *   ]\n * }\n * ```\n */\nexport type TLRichText = T.TypeOf<typeof richTextValidator>\n\n/**\n * Converts a plain text string into a TLRichText object. Each line of the input\n * text becomes a separate paragraph in the rich text document. Empty lines are\n * preserved as empty paragraphs to maintain the original text structure.\n *\n * @param text - The plain text string to convert to rich text\n * @returns A TLRichText object with the text content structured as paragraphs\n * @public\n * @example\n * ```ts\n * const richText = toRichText('Hello\\nWorld')\n * // Returns:\n * // {\n * //   type: 'doc',\n * //   content: [\n * //     { type: 'paragraph', content: [{ type: 'text', text: 'Hello' }] },\n * //     { type: 'paragraph', content: [{ type: 'text', text: 'World' }] }\n * //   ]\n * // }\n *\n * const emptyLine = toRichText('Line 1\\n\\nLine 3')\n * // Creates three paragraphs, with the middle one being empty\n * ```\n */\nexport function toRichText(text: string): TLRichText {\n\tconst lines = text.split('\\n')\n\tconst content = lines.map((text) => {\n\t\tif (!text) {\n\t\t\treturn {\n\t\t\t\ttype: 'paragraph',\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: 'paragraph',\n\t\t\tcontent: [{ type: 'text', text }],\n\t\t}\n\t})\n\n\treturn {\n\t\ttype: 'doc',\n\t\tcontent,\n\t}\n}\n"],"names":["text"],"mappings":";;;;;;;AAAA,SAAS,SAAS;;AAcX,MAAM,oBAAoB,8MAAA,CAAE,MAAA,CAAO;IAAE,MAAM,8MAAA,CAAE,MAAA;IAAQ,SAAS,8MAAA,CAAE,OAAA,CAAQ,8MAAA,CAAE,OAAO;AAAE,CAAC;AAgDpF,SAAS,WAAW,IAAA,EAA0B;IACpD,MAAM,QAAQ,KAAK,KAAA,CAAM,IAAI;IAC7B,MAAM,UAAU,MAAM,GAAA,CAAI,CAACA,UAAS;QACnC,IAAI,CAACA,OAAM;YACV,OAAO;gBACN,MAAM;YACP;QACD;QAEA,OAAO;YACN,MAAM;YACN,SAAS;gBAAC;oBAAE,MAAM;oBAAQ,MAAAA;gBAAK,CAAC;aAAA;QACjC;IACD,CAAC;IAED,OAAO;QACN,MAAM;QACN;IACD;AACD","debugId":null}},
    {"offset": {"line": 281, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/StyleProp.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\n\n/**\n * A `StyleProp` is a property of a shape that follows some special rules.\n *\n * 1. The same value can be set on lots of shapes at the same time.\n *\n * 2. The last used value is automatically saved and applied to new shapes.\n *\n * For example, {@link DefaultColorStyle} is a style prop used by tldraw's default shapes to set\n * their color. If you try selecting several shapes on tldraw.com and changing their color, you'll\n * see that the color is applied to all of them. Then, if you draw a new shape, it'll have the same\n * color as the one you just set.\n *\n * You can use styles in your own shapes by either defining your own (see {@link StyleProp.define}\n * and {@link StyleProp.defineEnum}) or using tldraw's default ones, like {@link DefaultColorStyle}.\n * When you define a shape, pass a `props` object describing all of your shape's properties, using\n * `StyleProp`s for the ones you want to be styles. See the\n * {@link https://github.com/tldraw/tldraw/tree/main/apps/examples | custom styles example}\n * for more.\n *\n * @public\n */\nexport class StyleProp<Type> implements T.Validatable<Type> {\n\t/**\n\t * Define a new {@link StyleProp}.\n\t *\n\t * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with\n\t * your app/library name.\n\t * @param options -\n\t * - `defaultValue`: The default value for this style prop.\n\t *\n\t * - `type`: Optionally, describe what type of data you expect for this style prop.\n\t *\n\t * @example\n\t * ```ts\n\t * import {T} from '@tldraw/validate'\n\t * import {StyleProp} from '@tldraw/tlschema'\n\t *\n\t * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {\n\t *   defaultValue: 1,\n\t *   type: T.number,\n\t * })\n\t * ```\n\t * @public\n\t */\n\tstatic define<Type>(\n\t\tuniqueId: string,\n\t\toptions: { defaultValue: Type; type?: T.Validatable<Type> }\n\t) {\n\t\tconst { defaultValue, type = T.any } = options\n\t\treturn new StyleProp<Type>(uniqueId, defaultValue, type)\n\t}\n\n\t/**\n\t * Define a new {@link StyleProp} as a list of possible values.\n\t *\n\t * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with\n\t * your app/library name.\n\t * @param options -\n\t * - `defaultValue`: The default value for this style prop.\n\t *\n\t * - `values`: An array of possible values of this style prop.\n\t *\n\t * @example\n\t * ```ts\n\t * import {StyleProp} from '@tldraw/tlschema'\n\t *\n\t * const MySizeProp = StyleProp.defineEnum('myApp:size', {\n\t *   defaultValue: 'medium',\n\t *   values: ['small', 'medium', 'large'],\n\t * })\n\t * ```\n\t */\n\tstatic defineEnum<const Values extends readonly unknown[]>(\n\t\tuniqueId: string,\n\t\toptions: { defaultValue: Values[number]; values: Values }\n\t) {\n\t\tconst { defaultValue, values } = options\n\t\treturn new EnumStyleProp<Values[number]>(uniqueId, defaultValue, values)\n\t}\n\n\t/** @internal */\n\tprotected constructor(\n\t\treadonly id: string,\n\t\tpublic defaultValue: Type,\n\t\treadonly type: T.Validatable<Type>\n\t) {}\n\n\tsetDefaultValue(value: Type) {\n\t\tthis.defaultValue = value\n\t}\n\n\tvalidate(value: unknown) {\n\t\treturn this.type.validate(value)\n\t}\n\n\tvalidateUsingKnownGoodVersion(prevValue: Type, newValue: unknown) {\n\t\tif (this.type.validateUsingKnownGoodVersion) {\n\t\t\treturn this.type.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t} else {\n\t\t\treturn this.validate(newValue)\n\t\t}\n\t}\n}\n\n/**\n * See {@link StyleProp} & {@link StyleProp.defineEnum}\n *\n * @public\n */\nexport class EnumStyleProp<T> extends StyleProp<T> {\n\t/** @internal */\n\tconstructor(\n\t\tid: string,\n\t\tdefaultValue: T,\n\t\treadonly values: readonly T[]\n\t) {\n\t\tsuper(id, defaultValue, T.literalEnum(...values))\n\t}\n}\n\n/**\n * @public\n */\nexport type StylePropValue<T extends StyleProp<any>> = T extends StyleProp<infer U> ? U : never\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,SAAS;;AAuBX,MAAM,UAA+C;IAAA,cAAA,GA4DjD,YACA,EAAA,EACF,YAAA,EACE,IAAA,CACR;QAHQ,IAAA,CAAA,EAAA,GAAA;QACF,IAAA,CAAA,YAAA,GAAA;QACE,IAAA,CAAA,IAAA,GAAA;IACP;IAAA;;;;;;;;;;;;;;;;;;;;;GAAA,GAzCH,OAAO,OACN,QAAA,EACA,OAAA,EACC;QACD,MAAM,EAAE,YAAA,EAAc,OAAO,8MAAA,CAAE,GAAA,CAAI,CAAA,GAAI;QACvC,OAAO,IAAI,UAAgB,UAAU,cAAc,IAAI;IACxD;IAAA;;;;;;;;;;;;;;;;;;;GAAA,GAsBA,OAAO,WACN,QAAA,EACA,OAAA,EACC;QACD,MAAM,EAAE,YAAA,EAAc,MAAA,CAAO,CAAA,GAAI;QACjC,OAAO,IAAI,cAA8B,UAAU,cAAc,MAAM;IACxE;IASA,gBAAgB,KAAA,EAAa;QAC5B,IAAA,CAAK,YAAA,GAAe;IACrB;IAEA,SAAS,KAAA,EAAgB;QACxB,OAAO,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK;IAChC;IAEA,8BAA8B,SAAA,EAAiB,QAAA,EAAmB;QACjE,IAAI,IAAA,CAAK,IAAA,CAAK,6BAAA,EAA+B;YAC5C,OAAO,IAAA,CAAK,IAAA,CAAK,6BAAA,CAA8B,WAAW,QAAQ;QACnE,OAAO;YACN,OAAO,IAAA,CAAK,QAAA,CAAS,QAAQ;QAC9B;IACD;AACD;AAOO,MAAM,sBAAyB,UAAa;IAAA,cAAA,GAElD,YACC,EAAA,EACA,YAAA,EACS,MAAA,CACR;QACD,KAAA,CAAM,IAAI,cAAc,8MAAA,CAAE,WAAA,CAAY,GAAG,MAAM,CAAC;QAFvC,IAAA,CAAA,MAAA,GAAA;IAGV;AACD","debugId":null}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLShape.ts"],"sourcesContent":["import {\n\tRecordId,\n\tUnknownRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n} from '@tldraw/store'\nimport { mapObjectMapValues, uniqueId } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from '../createTLSchema'\nimport { TLPropsMigrations } from '../recordsWithProps'\nimport { TLArrowShape } from '../shapes/TLArrowShape'\nimport { TLBaseShape, createShapeValidator } from '../shapes/TLBaseShape'\nimport { TLBookmarkShape } from '../shapes/TLBookmarkShape'\nimport { TLDrawShape } from '../shapes/TLDrawShape'\nimport { TLEmbedShape } from '../shapes/TLEmbedShape'\nimport { TLFrameShape } from '../shapes/TLFrameShape'\nimport { TLGeoShape } from '../shapes/TLGeoShape'\nimport { TLGroupShape } from '../shapes/TLGroupShape'\nimport { TLHighlightShape } from '../shapes/TLHighlightShape'\nimport { TLImageShape } from '../shapes/TLImageShape'\nimport { TLLineShape } from '../shapes/TLLineShape'\nimport { TLNoteShape } from '../shapes/TLNoteShape'\nimport { TLTextShape } from '../shapes/TLTextShape'\nimport { TLVideoShape } from '../shapes/TLVideoShape'\nimport { StyleProp } from '../styles/StyleProp'\nimport { TLPageId } from './TLPage'\n\n/**\n * The default set of shapes that are available in the editor.\n *\n * This union type represents all the built-in shape types supported by tldraw,\n * including arrows, bookmarks, drawings, embeds, frames, geometry shapes,\n * groups, images, lines, notes, text, videos, and highlights.\n *\n * @example\n * ```ts\n * // Check if a shape is a default shape type\n * function isDefaultShape(shape: TLShape): shape is TLDefaultShape {\n *   const defaultTypes = ['arrow', 'bookmark', 'draw', 'embed', 'frame', 'geo', 'group', 'image', 'line', 'note', 'text', 'video', 'highlight']\n *   return defaultTypes.includes(shape.type)\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultShape =\n\t| TLArrowShape\n\t| TLBookmarkShape\n\t| TLDrawShape\n\t| TLEmbedShape\n\t| TLFrameShape\n\t| TLGeoShape\n\t| TLGroupShape\n\t| TLImageShape\n\t| TLLineShape\n\t| TLNoteShape\n\t| TLTextShape\n\t| TLVideoShape\n\t| TLHighlightShape\n\n/**\n * A type for a shape that is available in the editor but whose type is\n * unknown\u2014either one of the editor's default shapes or else a custom shape.\n *\n * This is useful when working with shapes generically without knowing their specific type.\n * The shape type is a string and props are a generic object.\n *\n * @example\n * ```ts\n * // Handle any shape regardless of its specific type\n * function processUnknownShape(shape: TLUnknownShape) {\n *   console.log(`Processing shape of type: ${shape.type}`)\n *   console.log(`Position: (${shape.x}, ${shape.y})`)\n * }\n * ```\n *\n * @public\n */\nexport type TLUnknownShape = TLBaseShape<string, object>\n\n/**\n * The set of all shapes that are available in the editor, including unknown shapes.\n *\n * This is the primary shape type used throughout tldraw. It includes both the\n * built-in default shapes and any custom shapes that might be added.\n *\n * @example\n * ```ts\n * // Work with any shape in the editor\n * function moveShape(shape: TLShape, deltaX: number, deltaY: number): TLShape {\n *   return {\n *     ...shape,\n *     x: shape.x + deltaX,\n *     y: shape.y + deltaY\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLShape = TLDefaultShape | TLUnknownShape\n\n/**\n * A partial version of a shape, useful for updates and patches.\n *\n * This type represents a shape where all properties except `id` and `type` are optional.\n * It's commonly used when updating existing shapes or creating shape patches.\n *\n * @example\n * ```ts\n * // Update a shape's position\n * const shapeUpdate: TLShapePartial = {\n *   id: 'shape:123',\n *   type: 'geo',\n *   x: 100,\n *   y: 200\n * }\n *\n * // Update shape properties\n * const propsUpdate: TLShapePartial<TLGeoShape> = {\n *   id: 'shape:123',\n *   type: 'geo',\n *   props: {\n *     w: 150,\n *     h: 100\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLShapePartial<T extends TLShape = TLShape> = T extends T\n\t? {\n\t\t\tid: TLShapeId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/**\n * A unique identifier for a shape record.\n *\n * Shape IDs are branded strings that start with \"shape:\" followed by a unique identifier.\n * This type-safe approach prevents mixing up different types of record IDs.\n *\n * @example\n * ```ts\n * const shapeId: TLShapeId = createShapeId() // \"shape:abc123\"\n * const customId: TLShapeId = createShapeId('my-custom-id') // \"shape:my-custom-id\"\n * ```\n *\n * @public\n */\nexport type TLShapeId = RecordId<TLUnknownShape>\n\n/**\n * The ID of a shape's parent, which can be either a page or another shape.\n *\n * Shapes can be parented to pages (for top-level shapes) or to other shapes\n * (for shapes inside frames or groups).\n *\n * @example\n * ```ts\n * // Shape parented to a page\n * const pageParentId: TLParentId = 'page:main'\n *\n * // Shape parented to another shape (e.g., inside a frame)\n * const shapeParentId: TLParentId = 'shape:frame123'\n * ```\n *\n * @public\n */\nexport type TLParentId = TLPageId | TLShapeId\n\n/**\n * Migration version IDs for the root shape schema.\n *\n * These track the evolution of the base shape structure over time, ensuring\n * that shapes created in older versions can be migrated to newer formats.\n *\n * @example\n * ```ts\n * // Check if a migration needs to be applied\n * if (shapeVersion < rootShapeVersions.AddIsLocked) {\n *   // Apply isLocked migration\n * }\n * ```\n *\n * @public\n */\nexport const rootShapeVersions = createMigrationIds('com.tldraw.shape', {\n\tAddIsLocked: 1,\n\tHoistOpacity: 2,\n\tAddMeta: 3,\n\tAddWhite: 4,\n} as const)\n\n/**\n * Migration sequence for the root shape record type.\n *\n * This sequence defines how shape records should be transformed when migrating\n * between different schema versions. Each migration handles a specific version\n * upgrade, ensuring data compatibility across tldraw versions.\n *\n * @public\n */\nexport const rootShapeMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.shape',\n\trecordType: 'shape',\n\tsequence: [\n\t\t{\n\t\t\tid: rootShapeVersions.AddIsLocked,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.isLocked = false\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tdelete record.isLocked\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.HoistOpacity,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.opacity = Number(record.props.opacity ?? '1')\n\t\t\t\tdelete record.props.opacity\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tconst opacity = record.opacity\n\t\t\t\tdelete record.opacity\n\t\t\t\trecord.props.opacity =\n\t\t\t\t\topacity < 0.175\n\t\t\t\t\t\t? '0.1'\n\t\t\t\t\t\t: opacity < 0.375\n\t\t\t\t\t\t\t? '0.25'\n\t\t\t\t\t\t\t: opacity < 0.625\n\t\t\t\t\t\t\t\t? '0.5'\n\t\t\t\t\t\t\t\t: opacity < 0.875\n\t\t\t\t\t\t\t\t\t? '0.75'\n\t\t\t\t\t\t\t\t\t: '1'\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: rootShapeVersions.AddWhite,\n\t\t\tup: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tif (record.props.color === 'white') {\n\t\t\t\t\trecord.props.color = 'black'\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Type guard to check if a record is a shape.\n *\n * @param record - The record to check\n * @returns True if the record is a shape, false otherwise\n *\n * @example\n * ```ts\n * const record = store.get('shape:abc123')\n * if (isShape(record)) {\n *   console.log(`Shape type: ${record.type}`)\n *   console.log(`Position: (${record.x}, ${record.y})`)\n * }\n * ```\n *\n * @public\n */\nexport function isShape(record?: UnknownRecord): record is TLShape {\n\tif (!record) return false\n\treturn record.typeName === 'shape'\n}\n\n/**\n * Type guard to check if a string is a valid shape ID.\n *\n * @param id - The string to check\n * @returns True if the string is a valid shape ID, false otherwise\n *\n * @example\n * ```ts\n * const id = 'shape:abc123'\n * if (isShapeId(id)) {\n *   const shape = store.get(id) // TypeScript knows id is TLShapeId\n * }\n *\n * // Check user input\n * function selectShape(id: string) {\n *   if (isShapeId(id)) {\n *     editor.selectShape(id)\n *   } else {\n *     console.error('Invalid shape ID format')\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function isShapeId(id?: string): id is TLShapeId {\n\tif (!id) return false\n\treturn id.startsWith('shape:')\n}\n\n/**\n * Creates a new shape ID.\n *\n * @param id - Optional custom ID suffix. If not provided, a unique ID will be generated\n * @returns A new shape ID with the \"shape:\" prefix\n *\n * @example\n * ```ts\n * // Create a shape with auto-generated ID\n * const shapeId = createShapeId() // \"shape:abc123\"\n *\n * // Create a shape with custom ID\n * const customShapeId = createShapeId('my-rectangle') // \"shape:my-rectangle\"\n *\n * // Use in shape creation\n * const newShape: TLGeoShape = {\n *   id: createShapeId(),\n *   type: 'geo',\n *   x: 100,\n *   y: 200,\n *   // ... other properties\n * }\n * ```\n *\n * @public\n */\nexport function createShapeId(id?: string): TLShapeId {\n\treturn `shape:${id ?? uniqueId()}` as TLShapeId\n}\n\n/**\n * Extracts style properties from a shape's props definition and maps them to their property keys.\n *\n * This function analyzes shape property validators to identify which ones are style properties\n * and creates a mapping from StyleProp instances to their corresponding property keys.\n * It also validates that each style property is only used once per shape.\n *\n * @param props - Record of property validators for a shape type\n * @returns Map from StyleProp instances to their property keys\n * @throws Error if a style property is used more than once in the same shape\n *\n * @example\n * ```ts\n * const geoShapeProps = {\n *   color: DefaultColorStyle,\n *   fill: DefaultFillStyle,\n *   width: T.number,\n *   height: T.number\n * }\n *\n * const styleMap = getShapePropKeysByStyle(geoShapeProps)\n * // styleMap.get(DefaultColorStyle) === 'color'\n * // styleMap.get(DefaultFillStyle) === 'fill'\n * ```\n *\n * @internal\n */\nexport function getShapePropKeysByStyle(props: Record<string, T.Validatable<any>>) {\n\tconst propKeysByStyle = new Map<StyleProp<unknown>, string>()\n\tfor (const [key, prop] of Object.entries(props)) {\n\t\tif (prop instanceof StyleProp) {\n\t\t\tif (propKeysByStyle.has(prop)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`\n\t\t\t\t)\n\t\t\t}\n\t\t\tpropKeysByStyle.set(prop, key)\n\t\t}\n\t}\n\treturn propKeysByStyle\n}\n\n/**\n * Creates a migration sequence for shape properties.\n *\n * This is a pass-through function that maintains the same structure as the input.\n * It's used for consistency and to provide a clear API for defining shape property migrations.\n *\n * @param migrations - The migration sequence to create\n * @returns The same migration sequence (pass-through)\n *\n * @example\n * ```ts\n * const myShapeMigrations = createShapePropsMigrationSequence({\n *   sequence: [\n *     {\n *       id: 'com.myapp.shape.custom/1.0.0',\n *       up: (props) => ({ ...props, newProperty: 'default' }),\n *       down: ({ newProperty, ...props }) => props\n *     }\n *   ]\n * })\n * ```\n *\n * @public\n */\nexport function createShapePropsMigrationSequence(\n\tmigrations: TLPropsMigrations\n): TLPropsMigrations {\n\treturn migrations\n}\n\n/**\n * Creates properly formatted migration IDs for shape properties.\n *\n * Generates standardized migration IDs following the convention:\n * `com.tldraw.shape.{shapeType}/{version}`\n *\n * @param shapeType - The type of shape these migrations apply to\n * @param ids - Record mapping migration names to version numbers\n * @returns Record with the same keys but formatted migration ID values\n *\n * @example\n * ```ts\n * const myShapeVersions = createShapePropsMigrationIds('custom', {\n *   AddColor: 1,\n *   AddSize: 2,\n *   RefactorProps: 3\n * })\n * // Result: {\n * //   AddColor: 'com.tldraw.shape.custom/1',\n * //   AddSize: 'com.tldraw.shape.custom/2',\n * //   RefactorProps: 'com.tldraw.shape.custom/3'\n * // }\n * ```\n *\n * @public\n */\nexport function createShapePropsMigrationIds<\n\tconst S extends string,\n\tconst T extends Record<string, number>,\n>(shapeType: S, ids: T): { [k in keyof T]: `com.tldraw.shape.${S}/${T[k]}` } {\n\treturn mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`) as any\n}\n\n/**\n * Creates the record type definition for shapes.\n *\n * This function generates a complete record type for shapes that includes validation\n * for all registered shape types. It combines the base shape properties with\n * type-specific properties and creates a union validator that can handle any\n * registered shape type.\n *\n * @param shapes - Record of shape type names to their schema configuration\n * @returns A complete RecordType for shapes with proper validation and default properties\n *\n * @example\n * ```ts\n * const shapeRecordType = createShapeRecordType({\n *   geo: { props: geoShapeProps, migrations: geoMigrations },\n *   arrow: { props: arrowShapeProps, migrations: arrowMigrations }\n * })\n * ```\n *\n * @internal\n */\nexport function createShapeRecordType(shapes: Record<string, SchemaPropsInfo>) {\n\treturn createRecordType<TLShape>('shape', {\n\t\tscope: 'document',\n\t\tvalidator: T.model(\n\t\t\t'shape',\n\t\t\tT.union(\n\t\t\t\t'type',\n\t\t\t\tmapObjectMapValues(shapes, (type, { props, meta }) =>\n\t\t\t\t\tcreateShapeValidator(type, props, meta)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t}).withDefaultProperties(() => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\trotation: 0,\n\t\tisLocked: false,\n\t\topacity: 1,\n\t\tmeta: {},\n\t}))\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 501, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/recordsWithProps.ts"],"sourcesContent":["import {\n\tMigration,\n\tMigrationId,\n\tMigrationSequence,\n\tRecordType,\n\tStandaloneDependsOn,\n\tUnknownRecord,\n\tcreateMigrationSequence,\n} from '@tldraw/store'\nimport { MakeUndefinedOptional, assert } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { SchemaPropsInfo } from './createTLSchema'\n\n/**\n * Maps a record's property types to their corresponding validators.\n *\n * This utility type takes a record type with a `props` object and creates\n * a mapping where each property key maps to a validator for that property's type.\n * This is used to define validation schemas for record properties.\n *\n * @example\n * ```ts\n * interface MyShape extends TLBaseShape<'custom', { width: number; color: string }> {}\n *\n * // Define validators for the shape properties\n * const myShapeProps: RecordProps<MyShape> = {\n *   width: T.number,\n *   color: T.string\n * }\n * ```\n *\n * @public\n */\nexport type RecordProps<R extends UnknownRecord & { props: object }> = {\n\t[K in keyof R['props']]: T.Validatable<R['props'][K]>\n}\n\n/**\n * Extracts the TypeScript types from a record properties configuration.\n *\n * Takes a configuration object where values are validators and returns the\n * corresponding TypeScript types, with undefined values made optional.\n *\n * @example\n * ```ts\n * const shapePropsConfig = {\n *   width: T.number,\n *   height: T.number,\n *   color: T.optional(T.string)\n * }\n *\n * type ShapeProps = RecordPropsType<typeof shapePropsConfig>\n * // Result: { width: number; height: number; color?: string }\n * ```\n *\n * @public\n */\nexport type RecordPropsType<Config extends Record<string, T.Validatable<any>>> =\n\tMakeUndefinedOptional<{\n\t\t[K in keyof Config]: T.TypeOf<Config[K]>\n\t}>\n\n/**\n * A migration definition for shape or record properties.\n *\n * Defines how to transform record properties when migrating between schema versions.\n * Each migration has an `up` function to upgrade data and an optional `down` function\n * to downgrade data if needed.\n *\n * @example\n * ```ts\n * const addColorMigration: TLPropsMigration = {\n *   id: 'com.myapp.shape.custom/1.0.0',\n *   up: (props) => {\n *     // Add a default color property\n *     return { ...props, color: 'black' }\n *   },\n *   down: (props) => {\n *     // Remove the color property\n *     const { color, ...rest } = props\n *     return rest\n *   }\n * }\n * ```\n *\n * @public\n */\nexport interface TLPropsMigration {\n\treadonly id: MigrationId\n\treadonly dependsOn?: MigrationId[]\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly up: (props: any) => any\n\t/**\n\t * If a down migration was deployed more than a couple of months ago it should be safe to retire it.\n\t * We only really need them to smooth over the transition between versions, and some folks do keep\n\t * browser tabs open for months without refreshing, but at a certain point that kind of behavior is\n\t * on them. Plus anyway recently chrome has started to actually kill tabs that are open for too long\n\t * rather than just suspending them, so if other browsers follow suit maybe it's less of a concern.\n\t *\n\t * @public\n\t */\n\treadonly down?: 'none' | 'retired' | ((props: any) => any)\n}\n\n/**\n * A sequence of property migrations for a record type.\n *\n * Contains an ordered array of migrations that should be applied to transform\n * record properties from one version to another. Migrations can include both\n * property-specific migrations and standalone dependency declarations.\n *\n * @example\n * ```ts\n * const myShapeMigrations: TLPropsMigrations = {\n *   sequence: [\n *     {\n *       id: 'com.myapp.shape.custom/1.0.0',\n *       up: (props) => ({ ...props, version: 1 })\n *     },\n *     {\n *       id: 'com.myapp.shape.custom/2.0.0',\n *       up: (props) => ({ ...props, newFeature: true })\n *     }\n *   ]\n * }\n * ```\n *\n * @public\n */\nexport interface TLPropsMigrations {\n\treadonly sequence: Array<StandaloneDependsOn | TLPropsMigration>\n}\n\n/**\n * Processes property migrations for all record types in a schema.\n *\n * Takes a collection of record configurations and converts their migrations\n * into proper migration sequences that can be used by the store system.\n * Handles different migration formats including legacy migrations.\n *\n * @param typeName - The base type name for the records (e.g., 'shape', 'binding')\n * @param records - Record of type names to their schema configuration\n * @returns Array of processed migration sequences\n *\n * @example\n * ```ts\n * const shapeRecords = {\n *   geo: { props: geoProps, migrations: geoMigrations },\n *   arrow: { props: arrowProps, migrations: arrowMigrations }\n * }\n *\n * const sequences = processPropsMigrations('shape', shapeRecords)\n * ```\n *\n * @internal\n */\nexport function processPropsMigrations<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\trecords: Record<string, SchemaPropsInfo>\n) {\n\tconst result: MigrationSequence[] = []\n\n\tfor (const [subType, { migrations }] of Object.entries(records)) {\n\t\tconst sequenceId = `com.tldraw.${typeName}.${subType}`\n\t\tif (!migrations) {\n\t\t\t// provide empty migrations sequence to allow for future migrations\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: [],\n\t\t\t\t})\n\t\t\t)\n\t\t} else if ('sequenceId' in migrations) {\n\t\t\tassert(\n\t\t\t\tsequenceId === migrations.sequenceId,\n\t\t\t\t`sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`\n\t\t\t)\n\t\t\tresult.push(migrations)\n\t\t} else if ('sequence' in migrations) {\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: migrations.sequence.map((m) =>\n\t\t\t\t\t\t'id' in m ? createPropsMigration(typeName, subType, m) : m\n\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t} else {\n\t\t\t// legacy migrations, will be removed in the future\n\t\t\tresult.push(\n\t\t\t\tcreateMigrationSequence({\n\t\t\t\t\tsequenceId,\n\t\t\t\t\tretroactive: true,\n\t\t\t\t\tsequence: Object.keys(migrations.migrators)\n\t\t\t\t\t\t.map((k) => Number(k))\n\t\t\t\t\t\t.sort((a: number, b: number) => a - b)\n\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t(version): Migration => ({\n\t\t\t\t\t\t\t\tid: `${sequenceId}/${version}`,\n\t\t\t\t\t\t\t\tscope: 'record',\n\t\t\t\t\t\t\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\t\t\t\t\t\t\tup: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].up(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tdown: (record: any) => {\n\t\t\t\t\t\t\t\t\tconst result = migrations.migrators[version].down(record)\n\t\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * Creates a store migration from a props migration definition.\n *\n * Converts a high-level property migration into a low-level store migration\n * that can be applied to records. The resulting migration will only affect\n * records of the specified type and subtype.\n *\n * @param typeName - The base type name (e.g., 'shape', 'binding')\n * @param subType - The specific subtype (e.g., 'geo', 'arrow')\n * @param m - The property migration definition\n * @returns A store migration that applies the property transformation\n *\n * @example\n * ```ts\n * const propsMigration: TLPropsMigration = {\n *   id: 'com.myapp.shape.custom/1.0.0',\n *   up: (props) => ({ ...props, color: 'blue' })\n * }\n *\n * const storeMigration = createPropsMigration('shape', 'custom', propsMigration)\n * ```\n *\n * @internal\n */\nexport function createPropsMigration<R extends UnknownRecord & { type: string; props: object }>(\n\ttypeName: R['typeName'],\n\tsubType: R['type'],\n\tm: TLPropsMigration\n): Migration {\n\treturn {\n\t\tid: m.id,\n\t\tdependsOn: m.dependsOn,\n\t\tscope: 'record',\n\t\tfilter: (r) => r.typeName === typeName && (r as R).type === subType,\n\t\tup: (record: any) => {\n\t\t\tconst result = m.up(record.props)\n\t\t\tif (result) {\n\t\t\t\trecord.props = result\n\t\t\t}\n\t\t},\n\t\tdown:\n\t\t\ttypeof m.down === 'function'\n\t\t\t\t? (record: any) => {\n\t\t\t\t\t\tconst result = (m.down as (props: any) => any)(record.props)\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\trecord.props = result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t}\n}\n"],"names":["result"],"mappings":";;;;;;;;AAAA;;AASA,SAAgC,cAAc;;;AAmJvC,SAAS,uBACf,QAAA,EACA,OAAA,EACC;IACD,MAAM,SAA8B,CAAC,CAAA;IAErC,KAAA,MAAW,CAAC,SAAS,EAAE,UAAA,CAAW,CAAC,CAAA,IAAK,OAAO,OAAA,CAAQ,OAAO,EAAG;QAChE,MAAM,aAAa,CAAA,WAAA,EAAc,QAAQ,CAAA,CAAA,EAAI,OAAO,EAAA;QACpD,IAAI,CAAC,YAAY;YAEhB,OAAO,IAAA,KACN,iMAAA,EAAwB;gBACvB;gBACA,aAAa;gBACb,UAAU,CAAC,CAAA;YACZ,CAAC;QAEH,OAAA,IAAW,gBAAgB,YAAY;YACtC,IAAA,gLAAA,EACC,eAAe,WAAW,UAAA,EAC1B,CAAA,wBAAA,EAA2B,OAAO,CAAA,CAAA,EAAI,uLAAU,CAAA,uBAAA,EAA0B,UAAU,CAAA,QAAA,EAAW,WAAW,UAAU,CAAA,CAAA,CAAA;YAErH,OAAO,IAAA,CAAK,UAAU;QACvB,OAAA,IAAW,cAAc,YAAY;YACpC,OAAO,IAAA,KACN,iMAAA,EAAwB;gBACvB;gBACA,aAAa;gBACb,UAAU,WAAW,QAAA,CAAS,GAAA,CAAI,CAAC,IAClC,QAAQ,IAAI,qBAAqB,UAAU,SAAS,CAAC,IAAI;YAE3D,CAAC;QAEH,OAAO;YAEN,OAAO,IAAA,KACN,iMAAA,EAAwB;gBACvB;gBACA,aAAa;gBACb,UAAU,OAAO,IAAA,CAAK,WAAW,SAAS,EACxC,GAAA,CAAI,CAAC,IAAM,OAAO,CAAC,CAAC,EACpB,IAAA,CAAK,CAAC,GAAW,IAAc,IAAI,CAAC,EACpC,GAAA,CACA,CAAC,UAAA,CAAwB;wBACxB,IAAI,GAAG,UAAU,CAAA,CAAA,EAAI,OAAO,EAAA;wBAC5B,OAAO;wBACP,QAAQ,CAAC,IAAM,EAAE,QAAA,KAAa,YAAa,EAAQ,IAAA,KAAS;wBAC5D,IAAI,CAAC,WAAgB;4BACpB,MAAMA,UAAS,WAAW,SAAA,CAAU,OAAO,CAAA,CAAE,EAAA,CAAG,MAAM;4BACtD,IAAIA,SAAQ;gCACX,OAAOA;4BACR;wBACD;wBACA,MAAM,CAAC,WAAgB;4BACtB,MAAMA,UAAS,WAAW,SAAA,CAAU,OAAO,CAAA,CAAE,IAAA,CAAK,MAAM;4BACxD,IAAIA,SAAQ;gCACX,OAAOA;4BACR;wBACD;oBACD,CAAA;YAEH,CAAC;QAEH;IACD;IAEA,OAAO;AACR;AA0BO,SAAS,qBACf,QAAA,EACA,OAAA,EACA,CAAA,EACY;IACZ,OAAO;QACN,IAAI,EAAE,EAAA;QACN,WAAW,EAAE,SAAA;QACb,OAAO;QACP,QAAQ,CAAC,IAAM,EAAE,QAAA,KAAa,YAAa,EAAQ,IAAA,KAAS;QAC5D,IAAI,CAAC,WAAgB;YACpB,MAAM,SAAS,EAAE,EAAA,CAAG,OAAO,KAAK;YAChC,IAAI,QAAQ;gBACX,OAAO,KAAA,GAAQ;YAChB;QACD;QACA,MACC,OAAO,EAAE,IAAA,KAAS,aACf,CAAC,WAAgB;YACjB,MAAM,SAAU,EAAE,IAAA,CAA6B,OAAO,KAAK;YAC3D,IAAI,QAAQ;gBACX,OAAO,KAAA,GAAQ;YAChB;QACD,IACC,KAAA;IACL;AACD","debugId":null}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLColorStyle.ts"],"sourcesContent":["import { Expand } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Array of default color names available in tldraw's color palette.\n * These colors form the basis for the default color style system and are available\n * in both light and dark theme variants.\n *\n * @example\n * ```ts\n * import { defaultColorNames } from '@tldraw/tlschema'\n *\n * // Create a color picker with all default colors\n * const colorOptions = defaultColorNames.map(color => ({\n *   name: color,\n *   value: color\n * }))\n * ```\n *\n * @public\n */\nexport const defaultColorNames = [\n\t'black',\n\t'grey',\n\t'light-violet',\n\t'violet',\n\t'blue',\n\t'light-blue',\n\t'yellow',\n\t'orange',\n\t'green',\n\t'light-green',\n\t'light-red',\n\t'red',\n\t'white',\n] as const\n\n/**\n * Defines the color variants available for each color in the default theme.\n * Each color has multiple variants for different use cases like fills, strokes,\n * patterns, and UI elements like frames and notes.\n *\n * @example\n * ```ts\n * import { TLDefaultColorThemeColor } from '@tldraw/tlschema'\n *\n * const blueColor: TLDefaultColorThemeColor = {\n *   solid: '#4465e9',\n *   semi: '#dce1f8',\n *   pattern: '#6681ee',\n *   fill: '#4465e9',\n *   // ... other variants\n * }\n * ```\n *\n * @public\n */\nexport interface TLDefaultColorThemeColor {\n\tsolid: string\n\tsemi: string\n\tpattern: string\n\tfill: string // usually same as solid\n\tframeHeadingStroke: string\n\tframeHeadingFill: string\n\tframeStroke: string\n\tframeFill: string\n\tframeText: string\n\tnoteFill: string\n\tnoteText: string\n\thighlightSrgb: string\n\thighlightP3: string\n}\n\n/**\n * Complete color theme definition containing all colors and their variants\n * for either light or dark mode. Includes base theme properties and all\n * default colors with their respective color variants.\n *\n * @example\n * ```ts\n * import { TLDefaultColorTheme } from '@tldraw/tlschema'\n *\n * const customTheme: TLDefaultColorTheme = {\n *   id: 'light',\n *   text: '#000000',\n *   background: '#ffffff',\n *   solid: '#fcfffe',\n *   black: { solid: '#000000', semi: '#cccccc', ... },\n *   // ... other colors\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultColorTheme = Expand<\n\t{\n\t\tid: 'light' | 'dark'\n\t\ttext: string\n\t\tbackground: string\n\t\tsolid: string\n\t} & Record<(typeof defaultColorNames)[number], TLDefaultColorThemeColor>\n>\n\n/**\n * Complete color palette containing both light and dark theme definitions.\n * This object provides the full color system used by tldraw's default themes,\n * including all color variants and theme-specific adjustments.\n *\n * @example\n * ```ts\n * import { DefaultColorThemePalette } from '@tldraw/tlschema'\n *\n * // Get the dark theme colors\n * const darkTheme = DefaultColorThemePalette.darkMode\n * const redColor = darkTheme.red.solid // '#e03131'\n *\n * // Access light theme colors\n * const lightTheme = DefaultColorThemePalette.lightMode\n * const blueColor = lightTheme.blue.fill // '#4465e9'\n * ```\n *\n * @public\n */\nexport const DefaultColorThemePalette: {\n\tlightMode: TLDefaultColorTheme\n\tdarkMode: TLDefaultColorTheme\n} = {\n\tlightMode: {\n\t\tid: 'light',\n\t\ttext: '#000000',\n\t\tbackground: '#f9fafb',\n\t\tsolid: '#fcfffe',\n\t\tblack: {\n\t\t\tsolid: '#1d1d1d',\n\t\t\tfill: '#1d1d1d',\n\t\t\tframeHeadingStroke: '#717171',\n\t\t\tframeHeadingFill: '#ffffff',\n\t\t\tframeStroke: '#717171',\n\t\t\tframeFill: '#ffffff',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#FCE19C',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#e8e8e8',\n\t\t\tpattern: '#494949',\n\t\t\thighlightSrgb: '#fddd00',\n\t\t\thighlightP3: 'color(display-p3 0.972 0.8205 0.05)',\n\t\t},\n\t\tblue: {\n\t\t\tsolid: '#4465e9',\n\t\t\tfill: '#4465e9',\n\t\t\tframeHeadingStroke: '#6681ec',\n\t\t\tframeHeadingFill: '#f9fafe',\n\t\t\tframeStroke: '#6681ec',\n\t\t\tframeFill: '#f9fafe',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#8AA3FF',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#dce1f8',\n\t\t\tpattern: '#6681ee',\n\t\t\thighlightSrgb: '#10acff',\n\t\t\thighlightP3: 'color(display-p3 0.308 0.6632 0.9996)',\n\t\t},\n\t\tgreen: {\n\t\t\tsolid: '#099268',\n\t\t\tfill: '#099268',\n\t\t\tframeHeadingStroke: '#37a684',\n\t\t\tframeHeadingFill: '#f8fcfa',\n\t\t\tframeStroke: '#37a684',\n\t\t\tframeFill: '#f8fcfa',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#6FC896',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#d3e9e3',\n\t\t\tpattern: '#39a785',\n\t\t\thighlightSrgb: '#00ffc8',\n\t\t\thighlightP3: 'color(display-p3 0.2536 0.984 0.7981)',\n\t\t},\n\t\tgrey: {\n\t\t\tsolid: '#9fa8b2',\n\t\t\tfill: '#9fa8b2',\n\t\t\tframeHeadingStroke: '#aaaaab',\n\t\t\tframeHeadingFill: '#fbfcfc',\n\t\t\tframeStroke: '#aaaaab',\n\t\t\tframeFill: '#fcfcfd',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#C0CAD3',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#eceef0',\n\t\t\tpattern: '#bcc3c9',\n\t\t\thighlightSrgb: '#cbe7f1',\n\t\t\thighlightP3: 'color(display-p3 0.8163 0.9023 0.9416)',\n\t\t},\n\t\t'light-blue': {\n\t\t\tsolid: '#4ba1f1',\n\t\t\tfill: '#4ba1f1',\n\t\t\tframeHeadingStroke: '#6cb2f3',\n\t\t\tframeHeadingFill: '#f8fbfe',\n\t\t\tframeStroke: '#6cb2f3',\n\t\t\tframeFill: '#fafcff',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#9BC4FD',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#ddedfa',\n\t\t\tpattern: '#6fbbf8',\n\t\t\thighlightSrgb: '#00f4ff',\n\t\t\thighlightP3: 'color(display-p3 0.1512 0.9414 0.9996)',\n\t\t},\n\t\t'light-green': {\n\t\t\tsolid: '#4cb05e',\n\t\t\tfill: '#4cb05e',\n\t\t\tframeHeadingStroke: '#6dbe7c',\n\t\t\tframeHeadingFill: '#f8fcf9',\n\t\t\tframeStroke: '#6dbe7c',\n\t\t\tframeFill: '#fafdfa',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#98D08A',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#dbf0e0',\n\t\t\tpattern: '#65cb78',\n\t\t\thighlightSrgb: '#65f641',\n\t\t\thighlightP3: 'color(display-p3 0.563 0.9495 0.3857)',\n\t\t},\n\t\t'light-red': {\n\t\t\tsolid: '#f87777',\n\t\t\tfill: '#f87777',\n\t\t\tframeHeadingStroke: '#f89090',\n\t\t\tframeHeadingFill: '#fffafa',\n\t\t\tframeStroke: '#f89090',\n\t\t\tframeFill: '#fffbfb',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#F7A5A1',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#f4dadb',\n\t\t\tpattern: '#fe9e9e',\n\t\t\thighlightSrgb: '#ff7fa3',\n\t\t\thighlightP3: 'color(display-p3 0.9988 0.5301 0.6397)',\n\t\t},\n\t\t'light-violet': {\n\t\t\tsolid: '#e085f4',\n\t\t\tfill: '#e085f4',\n\t\t\tframeHeadingStroke: '#e59bf5',\n\t\t\tframeHeadingFill: '#fefaff',\n\t\t\tframeStroke: '#e59bf5',\n\t\t\tframeFill: '#fefbff',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#DFB0F9',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#f5eafa',\n\t\t\tpattern: '#e9acf8',\n\t\t\thighlightSrgb: '#ff88ff',\n\t\t\thighlightP3: 'color(display-p3 0.9676 0.5652 0.9999)',\n\t\t},\n\t\torange: {\n\t\t\tsolid: '#e16919',\n\t\t\tfill: '#e16919',\n\t\t\tframeHeadingStroke: '#e68544',\n\t\t\tframeHeadingFill: '#fef9f6',\n\t\t\tframeStroke: '#e68544',\n\t\t\tframeFill: '#fef9f6',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#FAA475',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#f8e2d4',\n\t\t\tpattern: '#f78438',\n\t\t\thighlightSrgb: '#ffa500',\n\t\t\thighlightP3: 'color(display-p3 0.9988 0.6905 0.266)',\n\t\t},\n\t\tred: {\n\t\t\tsolid: '#e03131',\n\t\t\tfill: '#e03131',\n\t\t\tframeHeadingStroke: '#e55757',\n\t\t\tframeHeadingFill: '#fef7f7',\n\t\t\tframeStroke: '#e55757',\n\t\t\tframeFill: '#fef9f9',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#FC8282',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#f4dadb',\n\t\t\tpattern: '#e55959',\n\t\t\thighlightSrgb: '#ff636e',\n\t\t\thighlightP3: 'color(display-p3 0.9992 0.4376 0.45)',\n\t\t},\n\t\tviolet: {\n\t\t\tsolid: '#ae3ec9',\n\t\t\tfill: '#ae3ec9',\n\t\t\tframeHeadingStroke: '#bc62d3',\n\t\t\tframeHeadingFill: '#fcf7fd',\n\t\t\tframeStroke: '#bc62d3',\n\t\t\tframeFill: '#fdf9fd',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#DB91FD',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#ecdcf2',\n\t\t\tpattern: '#bd63d3',\n\t\t\thighlightSrgb: '#c77cff',\n\t\t\thighlightP3: 'color(display-p3 0.7469 0.5089 0.9995)',\n\t\t},\n\t\tyellow: {\n\t\t\tsolid: '#f1ac4b',\n\t\t\tfill: '#f1ac4b',\n\t\t\tframeHeadingStroke: '#f3bb6c',\n\t\t\tframeHeadingFill: '#fefcf8',\n\t\t\tframeStroke: '#f3bb6c',\n\t\t\tframeFill: '#fffdfa',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#FED49A',\n\t\t\tnoteText: '#000000',\n\t\t\tsemi: '#f9f0e6',\n\t\t\tpattern: '#fecb92',\n\t\t\thighlightSrgb: '#fddd00',\n\t\t\thighlightP3: 'color(display-p3 0.972 0.8705 0.05)',\n\t\t},\n\t\twhite: {\n\t\t\tsolid: '#FFFFFF',\n\t\t\tfill: '#FFFFFF',\n\t\t\tsemi: '#f5f5f5',\n\t\t\tpattern: '#f9f9f9',\n\t\t\tframeHeadingStroke: '#7d7d7d',\n\t\t\tframeHeadingFill: '#ffffff',\n\t\t\tframeStroke: '#7d7d7d',\n\t\t\tframeFill: '#ffffff',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#FFFFFF',\n\t\t\tnoteText: '#000000',\n\t\t\thighlightSrgb: '#ffffff',\n\t\t\thighlightP3: 'color(display-p3 1 1 1)',\n\t\t},\n\t},\n\tdarkMode: {\n\t\tid: 'dark',\n\t\ttext: 'hsl(210, 17%, 98%)',\n\t\tbackground: 'hsl(240, 5%, 6.5%)',\n\t\tsolid: '#010403',\n\n\t\tblack: {\n\t\t\tsolid: '#f2f2f2',\n\t\t\tfill: '#f2f2f2',\n\t\t\tframeHeadingStroke: '#5c5c5c',\n\t\t\tframeHeadingFill: '#252525',\n\t\t\tframeStroke: '#5c5c5c',\n\t\t\tframeFill: '#0c0c0c',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#2c2c2c',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#2c3036',\n\t\t\tpattern: '#989898',\n\t\t\thighlightSrgb: '#d2b700',\n\t\t\thighlightP3: 'color(display-p3 0.8078 0.6225 0.0312)',\n\t\t},\n\t\tblue: {\n\t\t\tsolid: '#4f72fc', // 3c60f0\n\t\t\tfill: '#4f72fc',\n\t\t\tframeHeadingStroke: '#384994',\n\t\t\tframeHeadingFill: '#1C2036',\n\t\t\tframeStroke: '#384994',\n\t\t\tframeFill: '#11141f',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#2A3F98',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#262d40',\n\t\t\tpattern: '#3a4b9e',\n\t\t\thighlightSrgb: '#0079d2',\n\t\t\thighlightP3: 'color(display-p3 0.0032 0.4655 0.7991)',\n\t\t},\n\t\tgreen: {\n\t\t\tsolid: '#099268',\n\t\t\tfill: '#099268',\n\t\t\tframeHeadingStroke: '#10513C',\n\t\t\tframeHeadingFill: '#14241f',\n\t\t\tframeStroke: '#10513C',\n\t\t\tframeFill: '#0E1614',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#014429',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#253231',\n\t\t\tpattern: '#366a53',\n\t\t\thighlightSrgb: '#009774',\n\t\t\thighlightP3: 'color(display-p3 0.0085 0.582 0.4604)',\n\t\t},\n\t\tgrey: {\n\t\t\tsolid: '#9398b0',\n\t\t\tfill: '#9398b0',\n\t\t\tframeHeadingStroke: '#42474D',\n\t\t\tframeHeadingFill: '#23262A',\n\t\t\tframeStroke: '#42474D',\n\t\t\tframeFill: '#151719',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#56595F',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#33373c',\n\t\t\tpattern: '#7c8187',\n\t\t\thighlightSrgb: '#9cb4cb',\n\t\t\thighlightP3: 'color(display-p3 0.6299 0.7012 0.7856)',\n\t\t},\n\t\t'light-blue': {\n\t\t\tsolid: '#4dabf7',\n\t\t\tfill: '#4dabf7',\n\t\t\tframeHeadingStroke: '#075797',\n\t\t\tframeHeadingFill: '#142839',\n\t\t\tframeStroke: '#075797',\n\t\t\tframeFill: '#0B1823',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#1F5495',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#2a3642',\n\t\t\tpattern: '#4d7aa9',\n\t\t\thighlightSrgb: '#00bdc8',\n\t\t\thighlightP3: 'color(display-p3 0.0023 0.7259 0.7735)',\n\t\t},\n\t\t'light-green': {\n\t\t\tsolid: '#40c057',\n\t\t\tfill: '#40c057',\n\t\t\tframeHeadingStroke: '#1C5427',\n\t\t\tframeHeadingFill: '#18251A',\n\t\t\tframeStroke: '#1C5427',\n\t\t\tframeFill: '#0F1911',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#21581D',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#2a3830',\n\t\t\tpattern: '#4e874e',\n\t\t\thighlightSrgb: '#00a000',\n\t\t\thighlightP3: 'color(display-p3 0.2711 0.6172 0.0195)',\n\t\t},\n\t\t'light-red': {\n\t\t\tsolid: '#ff8787',\n\t\t\tfill: '#ff8787',\n\t\t\tframeHeadingStroke: '#6f3232', // Darker and desaturated variant of solid\n\t\t\tframeHeadingFill: '#341818', // Deep, muted dark red\n\t\t\tframeStroke: '#6f3232', // Matches headingStroke\n\t\t\tframeFill: '#181212', // Darker, muted background shade\n\t\t\tframeText: '#f2f2f2', // Consistent bright text color\n\t\t\tnoteFill: '#7a3333', // Medium-dark, muted variant of solid\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#3c2b2b', // Subdued, darker neutral-red tone\n\t\t\tpattern: '#a56767', // Existing pattern shade retained\n\t\t\thighlightSrgb: '#db005b',\n\t\t\thighlightP3: 'color(display-p3 0.7849 0.0585 0.3589)',\n\t\t},\n\t\t'light-violet': {\n\t\t\tsolid: '#e599f7',\n\t\t\tfill: '#e599f7',\n\t\t\tframeHeadingStroke: '#6c367a',\n\t\t\tframeHeadingFill: '#2D2230',\n\t\t\tframeStroke: '#6c367a',\n\t\t\tframeFill: '#1C151E',\n\t\t\tframeText: '#f2f2f2',\n\t\t\tnoteFill: '#762F8E',\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#383442',\n\t\t\tpattern: '#9770a9',\n\t\t\thighlightSrgb: '#c400c7',\n\t\t\thighlightP3: 'color(display-p3 0.7024 0.0403 0.753)',\n\t\t},\n\t\torange: {\n\t\t\tsolid: '#f76707',\n\t\t\tfill: '#f76707',\n\t\t\tframeHeadingStroke: '#773a0e', // Darker, muted version of solid\n\t\t\tframeHeadingFill: '#2f1d13', // Deep, warm, muted background\n\t\t\tframeStroke: '#773a0e', // Matches headingStroke\n\t\t\tframeFill: '#1c1512', // Darker, richer muted background\n\t\t\tframeText: '#f2f2f2', // Bright text for contrast\n\t\t\tnoteFill: '#7c3905', // Muted dark variant for note fill\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#3b2e27', // Muted neutral-orange tone\n\t\t\tpattern: '#9f552d', // Retained existing shade\n\t\t\thighlightSrgb: '#d07a00',\n\t\t\thighlightP3: 'color(display-p3 0.7699 0.4937 0.0085)',\n\t\t},\n\t\tred: {\n\t\t\tsolid: '#e03131',\n\t\t\tfill: '#e03131',\n\t\t\tframeHeadingStroke: '#701e1e', // Darker, muted variation of solid\n\t\t\tframeHeadingFill: '#301616', // Deep, muted reddish backdrop\n\t\t\tframeStroke: '#701e1e', // Matches headingStroke\n\t\t\tframeFill: '#1b1313', // Rich, dark muted background\n\t\t\tframeText: '#f2f2f2', // Bright text for readability\n\t\t\tnoteFill: '#7e201f', // Muted dark variant for note fill\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#382726', // Dark neutral-red tone\n\t\t\tpattern: '#8f3734', // Existing pattern color retained\n\t\t\thighlightSrgb: '#de002c',\n\t\t\thighlightP3: 'color(display-p3 0.7978 0.0509 0.2035)',\n\t\t},\n\t\tviolet: {\n\t\t\tsolid: '#ae3ec9',\n\t\t\tfill: '#ae3ec9',\n\t\t\tframeHeadingStroke: '#6d1583', // Darker, muted variation of solid\n\t\t\tframeHeadingFill: '#27152e', // Deep, rich muted violet backdrop\n\t\t\tframeStroke: '#6d1583', // Matches headingStroke\n\t\t\tframeFill: '#1b0f21', // Darker muted violet background\n\t\t\tframeText: '#f2f2f2', // Consistent bright text color\n\t\t\tnoteFill: '#5f1c70', // Muted dark variant for note fill\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#342938', // Dark neutral-violet tone\n\t\t\tpattern: '#763a8b', // Retained existing pattern color\n\t\t\thighlightSrgb: '#9e00ee',\n\t\t\thighlightP3: 'color(display-p3 0.5651 0.0079 0.8986)',\n\t\t},\n\t\tyellow: {\n\t\t\tsolid: '#ffc034',\n\t\t\tfill: '#ffc034',\n\t\t\tframeHeadingStroke: '#684e12', // Darker, muted variant of solid\n\t\t\tframeHeadingFill: '#2a2113', // Rich, muted dark-yellow background\n\t\t\tframeStroke: '#684e12', // Matches headingStroke\n\t\t\tframeFill: '#1e1911', // Darker muted shade for background fill\n\t\t\tframeText: '#f2f2f2', // Bright text color for readability\n\t\t\tnoteFill: '#8a5e1c', // Muted, dark complementary variant\n\t\t\tnoteText: '#f2f2f2',\n\t\t\tsemi: '#3b352b', // Dark muted neutral-yellow tone\n\t\t\tpattern: '#fecb92', // Existing shade retained\n\t\t\thighlightSrgb: '#d2b700',\n\t\t\thighlightP3: 'color(display-p3 0.8078 0.7225 0.0312)',\n\t\t},\n\t\twhite: {\n\t\t\tsolid: '#f3f3f3',\n\t\t\tfill: '#f3f3f3',\n\t\t\tsemi: '#f5f5f5',\n\t\t\tpattern: '#f9f9f9',\n\t\t\tframeHeadingStroke: '#ffffff',\n\t\t\tframeHeadingFill: '#ffffff',\n\t\t\tframeStroke: '#ffffff',\n\t\t\tframeFill: '#ffffff',\n\t\t\tframeText: '#000000',\n\t\t\tnoteFill: '#eaeaea',\n\t\t\tnoteText: '#1d1d1d',\n\t\t\thighlightSrgb: '#ffffff',\n\t\t\thighlightP3: 'color(display-p3 1 1 1)',\n\t\t},\n\t},\n}\n\n/**\n * Returns the appropriate default color theme based on the dark mode preference.\n *\n * @param opts - Configuration options\n *   - isDarkMode - Whether to return the dark theme (true) or light theme (false)\n * @returns The corresponding TLDefaultColorTheme (light or dark)\n *\n * @example\n * ```ts\n * import { getDefaultColorTheme } from '@tldraw/tlschema'\n *\n * // Get light theme\n * const lightTheme = getDefaultColorTheme({ isDarkMode: false })\n *\n * // Get dark theme\n * const darkTheme = getDefaultColorTheme({ isDarkMode: true })\n *\n * // Use with editor\n * const theme = getDefaultColorTheme({ isDarkMode: window.matchMedia('(prefers-color-scheme: dark)').matches })\n * ```\n *\n * @public\n */\nexport function getDefaultColorTheme(opts: { isDarkMode: boolean }): TLDefaultColorTheme {\n\treturn opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode\n}\n\n/**\n * Default color style property used by tldraw shapes for their primary color.\n * This style prop allows shapes to use any of the default color names and\n * automatically saves the last used value for new shapes.\n *\n * @example\n * ```ts\n * import { DefaultColorStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   color: typeof DefaultColorStyle\n *   // other props...\n * }\n *\n * // Set color on a shape\n * const shape = {\n *   // ... other properties\n *   props: {\n *     color: 'red' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultColorStyle = StyleProp.defineEnum('tldraw:color', {\n\tdefaultValue: 'black',\n\tvalues: defaultColorNames,\n})\n\n/**\n * Default label color style property used for text labels on shapes.\n * This is separate from the main color style to allow different colors\n * for shape fills/strokes versus their text labels.\n *\n * @example\n * ```ts\n * import { DefaultLabelColorStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   labelColor: typeof DefaultLabelColorStyle\n *   // other props...\n * }\n *\n * // Create a shape with different fill and label colors\n * const shape = {\n *   // ... other properties\n *   props: {\n *     color: 'blue' as const,\n *     labelColor: 'white' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultLabelColorStyle = StyleProp.defineEnum('tldraw:labelColor', {\n\tdefaultValue: 'black',\n\tvalues: defaultColorNames,\n})\n\n/**\n * Type representing a default color style value.\n * This is a union type of all available default color names.\n *\n * @example\n * ```ts\n * import { TLDefaultColorStyle } from '@tldraw/tlschema'\n *\n * // Valid color values\n * const redColor: TLDefaultColorStyle = 'red'\n * const blueColor: TLDefaultColorStyle = 'blue'\n *\n * // Type guard usage\n * function isValidColor(color: string): color is TLDefaultColorStyle {\n *   return ['black', 'red', 'blue'].includes(color as TLDefaultColorStyle)\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultColorStyle = T.TypeOf<typeof DefaultColorStyle>\n\nconst defaultColorNamesSet = new Set(defaultColorNames)\n\n/**\n * Type guard to check if a color value is one of the default theme colors.\n * Useful for determining if a color can be looked up in the theme palette.\n *\n * @param color - The color value to check\n * @returns True if the color is a default theme color, false otherwise\n *\n * @example\n * ```ts\n * import { isDefaultThemeColor, TLDefaultColorStyle } from '@tldraw/tlschema'\n *\n * const color: TLDefaultColorStyle = 'red'\n *\n * if (isDefaultThemeColor(color)) {\n *   // color is guaranteed to be a default theme color\n *   console.log(`${color} is a default theme color`)\n * } else {\n *   // color might be a custom hex value or other format\n *   console.log(`${color} is a custom color`)\n * }\n * ```\n *\n * @public\n */\nexport function isDefaultThemeColor(\n\tcolor: TLDefaultColorStyle\n): color is (typeof defaultColorNames)[number] {\n\treturn defaultColorNamesSet.has(color as (typeof defaultColorNames)[number])\n}\n\n/**\n * Resolves a color style value to its actual CSS color string for a given theme and variant.\n * If the color is not a default theme color, returns the color value as-is.\n *\n * @param theme - The color theme to use for resolution\n * @param color - The color style value to resolve\n * @param variant - Which variant of the color to return (solid, fill, pattern, etc.)\n * @returns The CSS color string for the specified color and variant\n *\n * @example\n * ```ts\n * import { getColorValue, getDefaultColorTheme } from '@tldraw/tlschema'\n *\n * const theme = getDefaultColorTheme({ isDarkMode: false })\n *\n * // Get the solid variant of red\n * const redSolid = getColorValue(theme, 'red', 'solid') // '#e03131'\n *\n * // Get the fill variant of blue\n * const blueFill = getColorValue(theme, 'blue', 'fill') // '#4465e9'\n *\n * // Custom color passes through unchanged\n * const customColor = getColorValue(theme, '#ff0000', 'solid') // '#ff0000'\n * ```\n *\n * @public\n */\nexport function getColorValue(\n\ttheme: TLDefaultColorTheme,\n\tcolor: TLDefaultColorStyle,\n\tvariant: keyof TLDefaultColorThemeColor\n): string {\n\tif (!isDefaultThemeColor(color)) {\n\t\treturn color\n\t}\n\n\treturn theme[color][variant]\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAEA,SAAS,iBAAiB;;AAoBnB,MAAM,oBAAoB;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAwFO,MAAM,2BAGT;IACH,WAAW;QACV,IAAI;QACJ,MAAM;QACN,YAAY;QACZ,OAAO;QACP,OAAO;YACN,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,MAAM;YACL,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,OAAO;YACN,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,MAAM;YACL,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,cAAc;YACb,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,eAAe;YACd,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,aAAa;YACZ,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,gBAAgB;YACf,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,QAAQ;YACP,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,KAAK;YACJ,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,QAAQ;YACP,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,QAAQ;YACP,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,OAAO;YACN,OAAO;YACP,MAAM;YACN,MAAM;YACN,SAAS;YACT,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,eAAe;YACf,aAAa;QACd;IACD;IACA,UAAU;QACT,IAAI;QACJ,MAAM;QACN,YAAY;QACZ,OAAO;QAEP,OAAO;YACN,OAAO;YACP,MAAM;YACN,oBAAoB;YACpB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,UAAU;YACV,UAAU;YACV,MAAM;YACN,SAAS;YACT,eAAe;YACf,aAAa;QACd;QACA,MAAM;YACL,OAAO;YAAA,SAAA;YACP,MAA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","debugId":null}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLDashStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default dash style property used by tldraw shapes for line styling.\n * Controls how shape outlines and lines are rendered with different dash patterns.\n *\n * Available values:\n * - `draw` - Hand-drawn, sketchy line style\n * - `solid` - Continuous solid line\n * - `dashed` - Evenly spaced dashes\n * - `dotted` - Evenly spaced dots\n *\n * @example\n * ```ts\n * import { DefaultDashStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   dash: typeof DefaultDashStyle\n *   // other props...\n * }\n *\n * // Create a shape with dashed outline\n * const shape = {\n *   // ... other properties\n *   props: {\n *     dash: 'dashed' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultDashStyle = StyleProp.defineEnum('tldraw:dash', {\n\tdefaultValue: 'draw',\n\tvalues: ['draw', 'solid', 'dashed', 'dotted'],\n})\n\n/**\n * Type representing a default dash style value.\n * This is a union type of all available dash style options.\n *\n * @example\n * ```ts\n * import { TLDefaultDashStyle } from '@tldraw/tlschema'\n *\n * // Valid dash style values\n * const drawStyle: TLDefaultDashStyle = 'draw'\n * const solidStyle: TLDefaultDashStyle = 'solid'\n * const dashedStyle: TLDefaultDashStyle = 'dashed'\n * const dottedStyle: TLDefaultDashStyle = 'dotted'\n *\n * // Use in a function parameter\n * function setShapeDash(dash: TLDefaultDashStyle) {\n *   // Apply dash style to shape\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultDashStyle = T.TypeOf<typeof DefaultDashStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAkCnB,MAAM,mBAAmB,2LAAA,CAAU,UAAA,CAAW,eAAe;IACnE,cAAc;IACd,QAAQ;QAAC;QAAQ;QAAS;QAAU,QAAQ;KAAA;AAC7C,CAAC","debugId":null}},
    {"offset": {"line": 1111, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLFillStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default fill style property used by tldraw shapes for interior styling.\n * Controls how the inside of shapes are filled or left empty.\n *\n * Available values:\n * - `none` - No fill, shape interior is transparent\n * - `semi` - Semi-transparent fill using the shape's color\n * - `solid` - Solid fill using the shape's color\n * - `pattern` - Crosshatch pattern fill using the shape's color\n * - `fill` - Alternative solid fill variant\n *\n * @example\n * ```ts\n * import { DefaultFillStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   fill: typeof DefaultFillStyle\n *   // other props...\n * }\n *\n * // Create a shape with solid fill\n * const shape = {\n *   // ... other properties\n *   props: {\n *     fill: 'solid' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultFillStyle = StyleProp.defineEnum('tldraw:fill', {\n\tdefaultValue: 'none',\n\tvalues: ['none', 'semi', 'solid', 'pattern', 'fill'],\n})\n\n/**\n * Type representing a default fill style value.\n * This is a union type of all available fill style options.\n *\n * @example\n * ```ts\n * import { TLDefaultFillStyle } from '@tldraw/tlschema'\n *\n * // Valid fill style values\n * const noFill: TLDefaultFillStyle = 'none'\n * const solidFill: TLDefaultFillStyle = 'solid'\n * const patternFill: TLDefaultFillStyle = 'pattern'\n *\n * // Use in a function parameter\n * function setShapeFill(fill: TLDefaultFillStyle) {\n *   // Apply fill style to shape\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultFillStyle = T.TypeOf<typeof DefaultFillStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAmCnB,MAAM,mBAAmB,2LAAA,CAAU,UAAA,CAAW,eAAe;IACnE,cAAc;IACd,QAAQ;QAAC;QAAQ;QAAQ;QAAS;QAAW,MAAM;KAAA;AACpD,CAAC","debugId":null}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLFontStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default font style property used by tldraw shapes for text styling.\n * Controls which typeface is used for text content within shapes.\n *\n * Available values:\n * - `draw` - Hand-drawn, sketchy font style\n * - `sans` - Clean sans-serif font\n * - `serif` - Traditional serif font\n * - `mono` - Monospace font for code-like text\n *\n * @example\n * ```ts\n * import { DefaultFontStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyTextShapeProps {\n *   font: typeof DefaultFontStyle\n *   // other props...\n * }\n *\n * // Create a text shape with monospace font\n * const textShape = {\n *   // ... other properties\n *   props: {\n *     font: 'mono' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultFontStyle = StyleProp.defineEnum('tldraw:font', {\n\tdefaultValue: 'draw',\n\tvalues: ['draw', 'sans', 'serif', 'mono'],\n})\n\n/**\n * Type representing a default font style value.\n * This is a union type of all available font style options.\n *\n * @example\n * ```ts\n * import { TLDefaultFontStyle } from '@tldraw/tlschema'\n *\n * // Valid font style values\n * const drawFont: TLDefaultFontStyle = 'draw'\n * const sansFont: TLDefaultFontStyle = 'sans'\n * const serifFont: TLDefaultFontStyle = 'serif'\n * const monoFont: TLDefaultFontStyle = 'mono'\n *\n * // Use in a function parameter\n * function setTextFont(font: TLDefaultFontStyle) {\n *   // Apply font style to text\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultFontStyle = T.TypeOf<typeof DefaultFontStyle>\n\n/**\n * Mapping of font style names to their corresponding CSS font-family declarations.\n * These are the actual CSS font families used when rendering text with each font style.\n *\n * @example\n * ```ts\n * import { DefaultFontFamilies, TLDefaultFontStyle } from '@tldraw/tlschema'\n *\n * // Get CSS font family for a font style\n * const fontStyle: TLDefaultFontStyle = 'mono'\n * const cssFamily = DefaultFontFamilies[fontStyle] // \"'tldraw_mono', monospace\"\n *\n * // Apply to DOM element\n * element.style.fontFamily = DefaultFontFamilies.sans\n * ```\n *\n * @public\n */\nexport const DefaultFontFamilies = {\n\tdraw: \"'tldraw_draw', sans-serif\",\n\tsans: \"'tldraw_sans', sans-serif\",\n\tserif: \"'tldraw_serif', serif\",\n\tmono: \"'tldraw_mono', monospace\",\n}\n"],"names":[],"mappings":";;;;;;AACA,SAAS,iBAAiB;;AAkCnB,MAAM,mBAAmB,2LAAA,CAAU,UAAA,CAAW,eAAe;IACnE,cAAc;IACd,QAAQ;QAAC;QAAQ;QAAQ;QAAS,MAAM;KAAA;AACzC,CAAC;AA4CM,MAAM,sBAAsB;IAClC,MAAM;IACN,MAAM;IACN,OAAO;IACP,MAAM;AACP","debugId":null}},
    {"offset": {"line": 1162, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLSizeStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default size style property used by tldraw shapes for scaling visual elements.\n * Controls the relative size of shape elements like stroke width, text size, and other proportional features.\n *\n * Available values:\n * - `s` - Small size\n * - `m` - Medium size (default)\n * - `l` - Large size\n * - `xl` - Extra large size\n *\n * @example\n * ```ts\n * import { DefaultSizeStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   size: typeof DefaultSizeStyle\n *   // other props...\n * }\n *\n * // Create a shape with large size\n * const shape = {\n *   // ... other properties\n *   props: {\n *     size: 'l' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultSizeStyle = StyleProp.defineEnum('tldraw:size', {\n\tdefaultValue: 'm',\n\tvalues: ['s', 'm', 'l', 'xl'],\n})\n\n/**\n * Type representing a default size style value.\n * This is a union type of all available size options.\n *\n * @example\n * ```ts\n * import { TLDefaultSizeStyle } from '@tldraw/tlschema'\n *\n * // Valid size values\n * const smallSize: TLDefaultSizeStyle = 's'\n * const mediumSize: TLDefaultSizeStyle = 'm'\n * const largeSize: TLDefaultSizeStyle = 'l'\n * const extraLargeSize: TLDefaultSizeStyle = 'xl'\n *\n * // Use in a function parameter\n * function setShapeSize(size: TLDefaultSizeStyle) {\n *   // Apply size style to shape\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultSizeStyle = T.TypeOf<typeof DefaultSizeStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAkCnB,MAAM,mBAAmB,2LAAA,CAAU,UAAA,CAAW,eAAe;IACnE,cAAc;IACd,QAAQ;QAAC;QAAK;QAAK;QAAK,IAAI;KAAA;AAC7B,CAAC","debugId":null}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLArrowShape.ts"],"sourcesContent":["import { createMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLRichText, richTextValidator, toRichText } from '../misc/TLRichText'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createBindingId } from '../records/TLBinding'\nimport { TLShapeId, createShapePropsMigrationIds } from '../records/TLShape'\nimport { RecordProps, TLPropsMigration, createPropsMigration } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\nconst arrowKinds = ['arc', 'elbow'] as const\n/**\n * Style property for arrow shape kind, determining how the arrow is drawn.\n *\n * Arrows can be drawn as arcs (curved) or elbows (angled with straight segments).\n * This affects the visual appearance and behavior of arrow shapes.\n *\n * @example\n * ```ts\n * // Create an arrow with arc style (curved)\n * const arcArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     kind: 'arc',\n *     // ... other props\n *   }\n * }\n *\n * // Create an arrow with elbow style (angled)\n * const elbowArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     kind: 'elbow',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeKindStyle = StyleProp.defineEnum('tldraw:arrowKind', {\n\tdefaultValue: 'arc',\n\tvalues: arrowKinds,\n})\n\n/**\n * The type representing arrow shape kinds.\n *\n * @public\n */\nexport type TLArrowShapeKind = T.TypeOf<typeof ArrowShapeKindStyle>\n\nconst arrowheadTypes = [\n\t'arrow',\n\t'triangle',\n\t'square',\n\t'dot',\n\t'pipe',\n\t'diamond',\n\t'inverted',\n\t'bar',\n\t'none',\n] as const\n\n/**\n * Style property for the arrowhead at the start of an arrow.\n *\n * Defines the visual style of the arrowhead at the beginning of the arrow path.\n * Can be one of several predefined styles or none for no arrowhead.\n *\n * @example\n * ```ts\n * // Arrow with no start arrowhead but triangle end arrowhead\n * const arrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     arrowheadStart: 'none',\n *     arrowheadEnd: 'triangle',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeArrowheadStartStyle = StyleProp.defineEnum('tldraw:arrowheadStart', {\n\tdefaultValue: 'none',\n\tvalues: arrowheadTypes,\n})\n\n/**\n * Style property for the arrowhead at the end of an arrow.\n *\n * Defines the visual style of the arrowhead at the end of the arrow path.\n * Defaults to 'arrow' style, giving arrows their characteristic pointed appearance.\n *\n * @example\n * ```ts\n * // Arrow with different start and end arrowheads\n * const doubleArrow: TLArrowShape = {\n *   // ... other properties\n *   props: {\n *     arrowheadStart: 'triangle',\n *     arrowheadEnd: 'diamond',\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const ArrowShapeArrowheadEndStyle = StyleProp.defineEnum('tldraw:arrowheadEnd', {\n\tdefaultValue: 'arrow',\n\tvalues: arrowheadTypes,\n})\n\n/**\n * The type representing arrowhead styles for both start and end of arrows.\n *\n * @public\n */\nexport type TLArrowShapeArrowheadStyle = T.TypeOf<typeof ArrowShapeArrowheadStartStyle>\n\n/**\n * Properties specific to arrow shapes.\n *\n * Defines all the configurable aspects of an arrow shape, including visual styling,\n * geometry, text labeling, and positioning. Arrows can connect two points and\n * optionally display text labels.\n *\n * @example\n * ```ts\n * const arrowProps: TLArrowShapeProps = {\n *   kind: 'arc',\n *   labelColor: 'black',\n *   color: 'blue',\n *   fill: 'none',\n *   dash: 'solid',\n *   size: 'm',\n *   arrowheadStart: 'none',\n *   arrowheadEnd: 'arrow',\n *   font: 'draw',\n *   start: { x: 0, y: 0 },\n *   end: { x: 100, y: 100 },\n *   bend: 0.2,\n *   richText: toRichText('Label'),\n *   labelPosition: 0.5,\n *   scale: 1,\n *   elbowMidPoint: 0.5\n * }\n * ```\n *\n * @public\n */\nexport interface TLArrowShapeProps {\n\tkind: TLArrowShapeKind\n\tlabelColor: TLDefaultColorStyle\n\tcolor: TLDefaultColorStyle\n\tfill: TLDefaultFillStyle\n\tdash: TLDefaultDashStyle\n\tsize: TLDefaultSizeStyle\n\tarrowheadStart: TLArrowShapeArrowheadStyle\n\tarrowheadEnd: TLArrowShapeArrowheadStyle\n\tfont: TLDefaultFontStyle\n\tstart: VecModel\n\tend: VecModel\n\tbend: number\n\trichText: TLRichText\n\tlabelPosition: number\n\tscale: number\n\telbowMidPoint: number\n}\n\n/**\n * A complete arrow shape record.\n *\n * Combines the base shape interface with arrow-specific properties to create\n * a full arrow shape that can be stored and manipulated in the editor.\n *\n * @example\n * ```ts\n * const arrowShape: TLArrowShape = {\n *   id: 'shape:arrow123',\n *   typeName: 'shape',\n *   type: 'arrow',\n *   x: 100,\n *   y: 200,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     kind: 'arc',\n *     start: { x: 0, y: 0 },\n *     end: { x: 150, y: 100 },\n *     // ... other props\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLArrowShape = TLBaseShape<'arrow', TLArrowShapeProps>\n\n/**\n * Validation configuration for arrow shape properties.\n *\n * Defines the validators for each property of an arrow shape, ensuring that\n * arrow shape data is valid and conforms to the expected types and constraints.\n *\n * @example\n * ```ts\n * // The validators ensure proper typing and validation\n * const validator = T.object(arrowShapeProps)\n * const validArrowProps = validator.validate({\n *   kind: 'arc',\n *   start: { x: 0, y: 0 },\n *   end: { x: 100, y: 50 },\n *   // ... other required properties\n * })\n * ```\n *\n * @public\n */\nexport const arrowShapeProps: RecordProps<TLArrowShape> = {\n\tkind: ArrowShapeKindStyle,\n\tlabelColor: DefaultLabelColorStyle,\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tarrowheadStart: ArrowShapeArrowheadStartStyle,\n\tarrowheadEnd: ArrowShapeArrowheadEndStyle,\n\tfont: DefaultFontStyle,\n\tstart: vecModelValidator,\n\tend: vecModelValidator,\n\tbend: T.number,\n\trichText: richTextValidator,\n\tlabelPosition: T.number,\n\tscale: T.nonZeroNumber,\n\telbowMidPoint: T.number,\n}\n\n/**\n * Migration version identifiers for arrow shape properties.\n *\n * These track the evolution of the arrow shape schema over time, with each\n * version representing a specific change to the arrow shape structure or properties.\n *\n * @example\n * ```ts\n * // Used internally for migration system\n * if (version < arrowShapeVersions.AddLabelColor) {\n *   // Apply label color migration\n * }\n * ```\n *\n * @public\n */\nexport const arrowShapeVersions = createShapePropsMigrationIds('arrow', {\n\tAddLabelColor: 1,\n\tAddIsPrecise: 2,\n\tAddLabelPosition: 3,\n\tExtractBindings: 4,\n\tAddScale: 5,\n\tAddElbow: 6,\n\tAddRichText: 7,\n})\n\nfunction propsMigration(migration: TLPropsMigration) {\n\treturn createPropsMigration<TLArrowShape>('shape', 'arrow', migration)\n}\n\n/**\n * Complete migration sequence for arrow shapes.\n *\n * Defines all the migrations needed to transform arrow shape data from older\n * versions to the current version. Each migration handles a specific schema change,\n * ensuring backward compatibility and smooth data evolution.\n *\n * @public\n */\nexport const arrowShapeMigrations = createMigrationSequence({\n\tsequenceId: 'com.tldraw.shape.arrow',\n\tretroactive: false,\n\tsequence: [\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddIsPrecise,\n\t\t\tup: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tstart.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tend.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5)\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ start, end }) => {\n\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\tif (!start.isPrecise) {\n\t\t\t\t\t\tstart.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete start.isPrecise\n\t\t\t\t}\n\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\tif (!end.isPrecise) {\n\t\t\t\t\t\tend.normalizedAnchor = { x: 0.5, y: 0.5 }\n\t\t\t\t\t}\n\t\t\t\t\tdelete end.isPrecise\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddLabelPosition,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelPosition = 0.5\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.labelPosition\n\t\t\t},\n\t\t}),\n\n\t\t{\n\t\t\tid: arrowShapeVersions.ExtractBindings,\n\t\t\tscope: 'store',\n\t\t\tup: (oldStore) => {\n\t\t\t\ttype OldArrowTerminal =\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'point'\n\t\t\t\t\t\t\tx: number\n\t\t\t\t\t\t\ty: number\n\t\t\t\t\t  }\n\t\t\t\t\t| {\n\t\t\t\t\t\t\ttype: 'binding'\n\t\t\t\t\t\t\tboundShapeId: TLShapeId\n\t\t\t\t\t\t\tnormalizedAnchor: VecModel\n\t\t\t\t\t\t\tisExact: boolean\n\t\t\t\t\t\t\tisPrecise: boolean\n\t\t\t\t\t  }\n\t\t\t\t\t// new type:\n\t\t\t\t\t| { type?: undefined; x: number; y: number }\n\n\t\t\t\ttype OldArrow = TLBaseShape<'arrow', { start: OldArrowTerminal; end: OldArrowTerminal }>\n\n\t\t\t\tconst arrows = Object.values(oldStore).filter(\n\t\t\t\t\t(r: any): r is OldArrow => r.typeName === 'shape' && r.type === 'arrow'\n\t\t\t\t)\n\n\t\t\t\tfor (const arrow of arrows) {\n\t\t\t\t\tconst { start, end } = arrow.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: start.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'start',\n\t\t\t\t\t\t\t\tnormalizedAnchor: start.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: start.isExact,\n\t\t\t\t\t\t\t\tisPrecise: start.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.start = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.start.type\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\tconst id = createBindingId()\n\t\t\t\t\t\tconst binding = {\n\t\t\t\t\t\t\ttypeName: 'binding',\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\ttype: 'arrow',\n\t\t\t\t\t\t\tfromId: arrow.id,\n\t\t\t\t\t\t\ttoId: end.boundShapeId,\n\t\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tterminal: 'end',\n\t\t\t\t\t\t\t\tnormalizedAnchor: end.normalizedAnchor,\n\t\t\t\t\t\t\t\tisExact: end.isExact,\n\t\t\t\t\t\t\t\tisPrecise: end.isPrecise,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toldStore[id] = binding\n\t\t\t\t\t\tarrow.props.end = { x: 0, y: 0 }\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete arrow.props.end.type\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t}),\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddElbow,\n\t\t\tup: (props) => {\n\t\t\t\tprops.kind = 'arc'\n\t\t\t\tprops.elbowMidPoint = 0.5\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.kind\n\t\t\t\tdelete props.elbowMidPoint\n\t\t\t},\n\t\t}),\n\t\tpropsMigration({\n\t\t\tid: arrowShapeVersions.AddRichText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.richText = toRichText(props.text)\n\t\t\t\tdelete props.text\n\t\t\t},\n\t\t\t// N.B. Explicitly no down state so that we force clients to update.\n\t\t\t// down: (props) => {\n\t\t\t// \tdelete props.richText\n\t\t\t// },\n\t\t}),\n\t],\n})\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1426, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/bindings/TLArrowBinding.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport {\n\tcreateBindingPropsMigrationIds,\n\tcreateBindingPropsMigrationSequence,\n} from '../records/TLBinding'\nimport { RecordProps } from '../recordsWithProps'\nimport { arrowShapeVersions } from '../shapes/TLArrowShape'\nimport { TLBaseBinding } from './TLBaseBinding'\n\n/**\n * Defines the snapping behavior for elbow-style arrows when binding to shapes.\n * Controls how the arrow segment aligns with the target shape's geometry.\n *\n * @example\n * ```ts\n * const binding: TLArrowBindingProps = {\n *   terminal: 'end',\n *   normalizedAnchor: { x: 0.5, y: 0.5 },\n *   isExact: false,\n *   isPrecise: true,\n *   snap: 'edge' // Snap to shape edge\n * }\n * ```\n *\n * @public\n */\nexport const ElbowArrowSnap = T.literalEnum('center', 'edge-point', 'edge', 'none')\n/**\n * Type representing the possible elbow arrow snap modes.\n *\n * - `'center'` - Snap to the center of the target shape\n * - `'edge-point'` - Snap to a specific point on the shape's edge\n * - `'edge'` - Snap to the nearest edge of the shape\n * - `'none'` - No snapping behavior\n *\n * @public\n */\nexport type ElbowArrowSnap = T.TypeOf<typeof ElbowArrowSnap>\n\n/**\n * Properties that define how an arrow binds to a target shape.\n * These properties control the visual and behavioral aspects of the arrow-to-shape connection.\n *\n * @example\n * ```ts\n * const arrowBindingProps: TLArrowBindingProps = {\n *   terminal: 'end', // Bind the arrow's end point\n *   normalizedAnchor: { x: 0.5, y: 0.0 }, // Bind to top center of shape\n *   isExact: true, // Arrow head enters the shape\n *   isPrecise: true, // Use exact anchor position\n *   snap: 'edge' // Snap to shape edge\n * }\n * ```\n *\n * @public\n */\nexport interface TLArrowBindingProps {\n\t/** Which end of the arrow is bound - either 'start' or 'end' */\n\tterminal: 'start' | 'end'\n\t/**\n\t * Normalized anchor point on the target shape (0,0 = top-left, 1,1 = bottom-right).\n\t * Coordinates are relative to the shape's bounding box.\n\t */\n\tnormalizedAnchor: VecModel\n\t/**\n\t * Whether the arrow head 'enters' the bound shape to point directly at the binding\n\t * anchor point. When true, the arrow head will be positioned inside the target shape.\n\t */\n\tisExact: boolean\n\t/**\n\t * Whether to bind to the exact normalizedAnchor position, or to the center of the shape.\n\t * When false, the arrow will connect to the shape's center regardless of anchor position.\n\t */\n\tisPrecise: boolean\n\t/** Snapping behavior for elbow-style arrows */\n\tsnap: ElbowArrowSnap\n}\n\n/**\n * Validation schema for arrow binding properties.\n * Defines the runtime validation rules for each property in TLArrowBindingProps.\n *\n * @example\n * ```ts\n * import { arrowBindingProps } from '@tldraw/tlschema'\n *\n * // Use in custom shape schema\n * const customSchema = createTLSchema({\n *   bindings: {\n *     arrow: {\n *       props: arrowBindingProps,\n *       migrations: arrowBindingMigrations\n *     }\n *   }\n * })\n * ```\n *\n * @public\n */\nexport const arrowBindingProps: RecordProps<TLArrowBinding> = {\n\tterminal: T.literalEnum('start', 'end'),\n\tnormalizedAnchor: vecModelValidator,\n\tisExact: T.boolean,\n\tisPrecise: T.boolean,\n\tsnap: ElbowArrowSnap,\n}\n\n/**\n * Represents a binding relationship between an arrow shape and another shape.\n * Arrow bindings allow arrows to connect to and follow other shapes, maintaining\n * the connection even when shapes are moved or transformed.\n *\n * @example\n * ```ts\n * const arrowBinding: TLArrowBinding = {\n *   id: 'binding:abc123',\n *   typeName: 'binding',\n *   type: 'arrow',\n *   fromId: 'shape:arrow1', // The arrow shape\n *   toId: 'shape:rectangle1', // The target shape\n *   props: {\n *     terminal: 'end',\n *     normalizedAnchor: { x: 0.5, y: 0.5 },\n *     isExact: false,\n *     isPrecise: true,\n *     snap: 'edge'\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLArrowBinding = TLBaseBinding<'arrow', TLArrowBindingProps>\n\n/**\n * Version identifiers for arrow binding property migrations.\n * Each version represents a schema change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if migration is needed\n * if (bindingVersion < arrowBindingVersions.AddSnap) {\n *   // Apply AddSnap migration\n * }\n * ```\n *\n * @public\n */\nexport const arrowBindingVersions = createBindingPropsMigrationIds('arrow', {\n\tAddSnap: 1,\n})\n\n/**\n * Migration sequence for arrow binding properties.\n * Handles schema evolution over time by defining how to migrate data between versions.\n *\n * The sequence includes:\n * - **AddSnap (v1)**: Adds the `snap` property with default value 'none'\n *\n * @example\n * ```ts\n * import { arrowBindingMigrations } from '@tldraw/tlschema'\n *\n * // Apply migrations when loading older data\n * const migratedBinding = arrowBindingMigrations.migrate(oldBinding)\n * ```\n *\n * @public\n */\nexport const arrowBindingMigrations = createBindingPropsMigrationSequence({\n\tsequence: [\n\t\t{ dependsOn: [arrowShapeVersions.ExtractBindings] },\n\t\t{\n\t\t\tid: arrowBindingVersions.AddSnap,\n\t\t\tup: (props) => {\n\t\t\t\tprops.snap = 'none'\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.snap\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAmB,yBAAyB;AAC5C;AAKA,SAAS,0BAA0B;;;;;AAoB5B,MAAM,iBAAiB,8MAAA,CAAE,WAAA,CAAY,UAAU,cAAc,QAAQ,MAAM;AAyE3E,MAAM,oBAAiD;IAC7D,UAAU,8MAAA,CAAE,WAAA,CAAY,SAAS,KAAK;IACtC,kBAAkB,yMAAA;IAClB,SAAS,8MAAA,CAAE,OAAA;IACX,WAAW,8MAAA,CAAE,OAAA;IACb,MAAM;AACP;AA4CO,MAAM,2BAAuB,iNAAA,EAA+B,SAAS;IAC3E,SAAS;AACV,CAAC;AAmBM,MAAM,6BAAyB,sNAAA,EAAoC;IACzE,UAAU;QACT;YAAE,WAAW;gBAAC,uMAAA,CAAmB,eAAe;aAAA;QAAE;QAClD;YACC,IAAI,qBAAqB,OAAA;YACzB,IAAI,CAAC,UAAU;gBACd,MAAM,IAAA,GAAO;YACd;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,IAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 1480, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLCamera.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * A camera record representing the viewport's position and zoom level.\n * The camera defines what portion of the infinite canvas is visible to the user.\n *\n * @example\n * ```ts\n * const camera: TLCamera = {\n *   id: 'camera:user1',\n *   typeName: 'camera',\n *   x: 100,    // Camera x position (negative values pan right)\n *   y: 50,     // Camera y position (negative values pan down)\n *   z: 0.5,    // Zoom level (1 = 100%, 0.5 = 50%, 2 = 200%)\n *   meta: {\n *     userId: 'user123',\n *     lastUpdated: Date.now()\n *   }\n * }\n *\n * // Set camera position and zoom\n * editor.setCamera({ x: -200, y: -100, z: 1.5 })\n * ```\n *\n * @public\n */\nexport interface TLCamera extends BaseRecord<'camera', TLCameraId> {\n\t/** Camera x position. Negative values move the viewport right */\n\tx: number\n\t/** Camera y position. Negative values move the viewport down */\n\ty: number\n\t/** Zoom level. 1 = 100%, 0.5 = 50% zoom, 2 = 200% zoom */\n\tz: number\n\t/** User-defined metadata for the camera */\n\tmeta: JsonObject\n}\n\n/**\n * Branded string type for camera record identifiers.\n * Prevents mixing camera IDs with other types of record IDs at compile time.\n *\n * @example\n * ```ts\n * import { CameraRecordType } from '@tldraw/tlschema'\n *\n * // Create a camera ID (typically one per user/session)\n * const cameraId: TLCameraId = CameraRecordType.createId()\n *\n * // Use in camera records\n * const camera: TLCamera = {\n *   id: cameraId,\n *   typeName: 'camera',\n *   x: 0, y: 0, z: 1,\n *   meta: {}\n * }\n *\n * // Get camera from store\n * const currentCamera = store.get(cameraId)\n * ```\n *\n * @public\n */\nexport type TLCameraId = RecordId<TLCamera>\n\n/**\n * Validator for TLCamera records that ensures runtime type safety.\n * Validates camera position coordinates and zoom level.\n *\n * @example\n * ```ts\n * // Validation happens automatically when cameras are stored\n * try {\n *   const validatedCamera = cameraValidator.validate(cameraData)\n *   store.put([validatedCamera])\n * } catch (error) {\n *   console.error('Camera validation failed:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const cameraValidator: T.Validator<TLCamera> = T.model(\n\t'camera',\n\tT.object({\n\t\ttypeName: T.literal('camera'),\n\t\tid: idValidator<TLCameraId>('camera'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\tz: T.number,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Migration version identifiers for camera record schema evolution.\n * Each version represents a breaking change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if a camera needs migration\n * const needsMigration = currentVersion < cameraVersions.AddMeta\n * ```\n *\n * @public\n */\nexport const cameraVersions = createMigrationIds('com.tldraw.camera', {\n\tAddMeta: 1,\n})\n\n/**\n * Migration sequence for evolving camera record structure over time.\n * Handles converting camera records from older schema versions to current format.\n *\n * @example\n * ```ts\n * // Migration is applied automatically when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n * ```\n *\n * @public\n */\nexport const cameraMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.camera',\n\trecordType: 'camera',\n\tsequence: [\n\t\t{\n\t\t\tid: cameraVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Record type definition for TLCamera with validation and default properties.\n * Configures cameras as session-scoped records that don't persist across sessions.\n *\n * @example\n * ```ts\n * // Create a new camera record with defaults\n * const cameraRecord = CameraRecordType.create({\n *   id: 'camera:main'\n *   // x: 0, y: 0, z: 1, meta: {} are applied as defaults\n * })\n *\n * // Create with custom position and zoom\n * const customCamera = CameraRecordType.create({\n *   id: 'camera:user1',\n *   x: -100,\n *   y: -50,\n *   z: 1.5,\n *   meta: { userId: 'user123' }\n * })\n *\n * // Store the camera\n * store.put([cameraRecord])\n * ```\n *\n * @public\n */\nexport const CameraRecordType = createRecordType<TLCamera>('camera', {\n\tvalidator: cameraValidator,\n\tscope: 'session',\n}).withDefaultProperties(\n\t(): Omit<TLCamera, 'id' | 'typeName'> => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 1,\n\t\tmeta: {},\n\t})\n)\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAQA,SAAS,SAAS;AAClB,SAAS,mBAAmB;;;;AAiFrB,MAAM,kBAAyC,8MAAA,CAAE,KAAA,CACvD,UACA,8MAAA,CAAE,MAAA,CAAO;IACR,UAAU,8MAAA,CAAE,OAAA,CAAQ,QAAQ;IAC5B,QAAI,iMAAA,EAAwB,QAAQ;IACpC,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,MAAM,8MAAA,CAAE,SAAA;AACT,CAAC;AAeK,MAAM,qBAAiB,4LAAA,EAAmB,qBAAqB;IACrE,SAAS;AACV,CAAC;AAiBM,MAAM,uBAAmB,uMAAA,EAA8B;IAC7D,YAAY;IACZ,YAAY;IACZ,UAAU;QACT;YACC,IAAI,eAAe,OAAA;YACnB,IAAI,CAAC,WAAW;;gBACb,OAAe,IAAA,GAAO,CAAC;YAC1B;QACD;KACD;AACD,CAAC;AA6BM,MAAM,uBAAmB,6LAAA,EAA2B,UAAU;IACpE,WAAW;IACX,OAAO;AACR,CAAC,EAAE,qBAAA,CACF,IAAA,CAA0C;QACzC,GAAG;QACH,GAAG;QACH,GAAG;QACH,MAAM,CAAC;IACR,CAAA","debugId":null}},
    {"offset": {"line": 1538, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLCursor.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\n\n/**\n * All available cursor types used throughout the tldraw editor.\n *\n * These cursor types correspond to CSS cursor values and are used to indicate\n * different interaction modes and states within the editor. The cursor types\n * cover selection, resizing, rotation, text editing, and various other editor\n * interactions.\n *\n * @example\n * ```ts\n * // Check if a cursor type is valid\n * if (TL_CURSOR_TYPES.has('resize-corner')) {\n *   console.log('Valid cursor type')\n * }\n *\n * // Get all available cursor types\n * const allCursors = Array.from(TL_CURSOR_TYPES)\n * ```\n *\n * @public\n */\nexport const TL_CURSOR_TYPES = new Set([\n\t'none',\n\t'default',\n\t'pointer',\n\t'cross',\n\t'grab',\n\t'rotate',\n\t'grabbing',\n\t'resize-edge',\n\t'resize-corner',\n\t'text',\n\t'move',\n\t'ew-resize',\n\t'ns-resize',\n\t'nesw-resize',\n\t'nwse-resize',\n\t'nesw-rotate',\n\t'nwse-rotate',\n\t'swne-rotate',\n\t'senw-rotate',\n\t'zoom-in',\n\t'zoom-out',\n])\n\n/**\n * A union type representing all available cursor types in the tldraw editor.\n *\n * Each cursor type corresponds to a different interaction mode or state,\n * helping users understand what action they can perform at any given moment.\n *\n * @example\n * ```ts\n * const defaultCursor: TLCursorType = 'default'\n * const textCursor: TLCursorType = 'text'\n * const resizeCursor: TLCursorType = 'resize-corner'\n * const rotateCursor: TLCursorType = 'nesw-rotate'\n * ```\n *\n * @public\n */\nexport type TLCursorType = SetValue<typeof TL_CURSOR_TYPES>\n\n/**\n * A validator for cursor types.\n *\n * This validator ensures that cursor type values are one of the valid types\n * defined in {@link TL_CURSOR_TYPES}. It provides runtime type checking for\n * cursor properties throughout the editor.\n *\n * @example\n * ```ts\n * import { cursorTypeValidator } from '@tldraw/tlschema'\n *\n * // Validate a cursor type\n * try {\n *   const validCursor = cursorTypeValidator.validate('pointer')\n *   console.log('Valid cursor:', validCursor)\n * } catch (error) {\n *   console.error('Invalid cursor:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const cursorTypeValidator = T.setEnum(TL_CURSOR_TYPES)\n\n/**\n * A cursor object used throughout the tldraw editor.\n *\n * Represents both the cursor type (which determines the visual appearance)\n * and its rotation angle. The rotation is particularly useful for resize\n * and rotation cursors that need to align with the current interaction angle.\n *\n * @example\n * ```ts\n * // Default cursor\n * const defaultCursor: TLCursor = {\n *   type: 'default',\n *   rotation: 0\n * }\n *\n * // Rotated resize cursor\n * const rotatedResizeCursor: TLCursor = {\n *   type: 'resize-corner',\n *   rotation: Math.PI / 4 // 45 degrees\n * }\n *\n * // Text editing cursor\n * const textCursor: TLCursor = {\n *   type: 'text',\n *   rotation: 0\n * }\n * ```\n *\n * @public\n */\nexport interface TLCursor {\n\t/** The cursor type, determining the visual appearance and interaction mode */\n\ttype: TLCursorType\n\t/** The rotation angle in radians, used for rotated cursors like resize handles */\n\trotation: number\n}\n\n/**\n * A validator for TLCursor objects.\n *\n * This validator ensures that cursor objects have valid cursor types and\n * numeric rotation values. It provides runtime validation for cursor\n * properties used throughout the editor.\n *\n * @example\n * ```ts\n * import { cursorValidator } from '@tldraw/tlschema'\n *\n * // Validate a cursor object\n * try {\n *   const validCursor = cursorValidator.validate({\n *     type: 'pointer',\n *     rotation: 0.5\n *   })\n *   console.log('Valid cursor:', validCursor)\n * } catch (error) {\n *   console.error('Invalid cursor:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const cursorValidator: T.ObjectValidator<TLCursor> = T.object<TLCursor>({\n\ttype: cursorTypeValidator,\n\trotation: T.number,\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;;AAwBX,MAAM,kBAAkB,aAAA,GAAA,IAAI,IAAI;IACtC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACA;AA0CM,MAAM,sBAAsB,8MAAA,CAAE,OAAA,CAAQ,eAAe;AAgErD,MAAM,kBAA+C,8MAAA,CAAE,MAAA,CAAiB;IAC9E,MAAM;IACN,UAAU,8MAAA,CAAE,MAAA;AACb,CAAC","debugId":null}},
    {"offset": {"line": 1583, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLColor.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\n\n/**\n * The colors used by tldraw's canvas UI system.\n *\n * These are special color types used for canvas UI elements like selections,\n * accents, and other interface components that overlay the drawing canvas.\n * Unlike shape colors, these are semantic color types that adapt to the\n * current theme.\n *\n * @example\n * ```ts\n * // Check if a color is a canvas UI color\n * if (TL_CANVAS_UI_COLOR_TYPES.has('selection-stroke')) {\n *   console.log('This is a valid canvas UI color')\n * }\n * ```\n *\n * @public\n */\nexport const TL_CANVAS_UI_COLOR_TYPES = new Set([\n\t'accent',\n\t'white',\n\t'black',\n\t'selection-stroke',\n\t'selection-fill',\n\t'laser',\n\t'muted-1',\n] as const)\n\n/**\n * A union type representing the available canvas UI color types.\n *\n * Canvas UI colors are semantic color types used for interface elements\n * that overlay the drawing canvas, such as selection indicators, accents,\n * and other UI components.\n *\n * @example\n * ```ts\n * const selectionColor: TLCanvasUiColor = 'selection-stroke'\n * const accentColor: TLCanvasUiColor = 'accent'\n * const backgroundColor: TLCanvasUiColor = 'white'\n * ```\n *\n * @public\n */\nexport type TLCanvasUiColor = SetValue<typeof TL_CANVAS_UI_COLOR_TYPES>\n\n/**\n * A validator for canvas UI color types.\n *\n * This validator ensures that color values are one of the valid canvas UI\n * color types defined in {@link TL_CANVAS_UI_COLOR_TYPES}. It provides\n * runtime type checking for canvas UI color properties.\n *\n * @example\n * ```ts\n * import { canvasUiColorTypeValidator } from '@tldraw/tlschema'\n *\n * // Validate a color value\n * try {\n *   const validColor = canvasUiColorTypeValidator.validate('accent')\n *   console.log('Valid color:', validColor)\n * } catch (error) {\n *   console.error('Invalid color:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const canvasUiColorTypeValidator = T.setEnum(TL_CANVAS_UI_COLOR_TYPES)\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,SAAS;;AAqBX,MAAM,2BAA2B,aAAA,GAAA,IAAI,IAAI;IAC/C;IACA;IACA;IACA;IACA;IACA;IACA;CACS;AA0CH,MAAM,6BAA6B,8MAAA,CAAE,OAAA,CAAQ,wBAAwB","debugId":null}},
    {"offset": {"line": 1608, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLScribble.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { SetValue } from '../util-types'\nimport { TLCanvasUiColor, canvasUiColorTypeValidator } from './TLColor'\nimport { VecModel, vecModelValidator } from './geometry-types'\n\n/**\n * All available scribble states used by the tldraw drawing system.\n *\n * Scribble states represent the different phases of a drawing stroke:\n *\n * - `starting`: The scribble is being initiated\n * - `paused`: The scribble is temporarily paused\n * - `active`: The scribble is actively being drawn\n * - `stopping`: The scribble is being finished\n *\n * These states help manage the drawing lifecycle and apply appropriate\n * visual effects during different phases of the stroke.\n *\n * @example\n * ```ts\n * // Check if a scribble state is valid\n * if (TL_SCRIBBLE_STATES.has('active')) {\n *   console.log('Valid scribble state')\n * }\n *\n * // Get all available scribble states\n * const allStates = Array.from(TL_SCRIBBLE_STATES)\n * ```\n *\n * @public\n */\nexport const TL_SCRIBBLE_STATES = new Set(['starting', 'paused', 'active', 'stopping'] as const)\n\n/**\n * A scribble object representing a drawing stroke in tldraw.\n *\n * Scribbles are temporary drawing strokes that appear during freehand drawing\n * operations. They provide visual feedback as the user draws and can be styled\n * with various properties like size, color, and effects.\n *\n * @example\n * ```ts\n * // A basic scribble stroke\n * const scribble: TLScribble = {\n *   id: 'scribble-123',\n *   points: [\n *     { x: 0, y: 0, z: 0.5 },\n *     { x: 10, y: 5, z: 0.7 },\n *     { x: 20, y: 10, z: 0.6 }\n *   ],\n *   size: 4,\n *   color: 'black',\n *   opacity: 0.8,\n *   state: 'active',\n *   delay: 0,\n *   shrink: 0.1,\n *   taper: true\n * }\n *\n * // A laser pointer scribble\n * const laserScribble: TLScribble = {\n *   id: 'laser-pointer',\n *   points: [{ x: 50, y: 50, z: 1.0 }],\n *   size: 8,\n *   color: 'laser',\n *   opacity: 1.0,\n *   state: 'active',\n *   delay: 100,\n *   shrink: 0,\n *   taper: false\n * }\n * ```\n *\n * @public\n */\nexport interface TLScribble {\n\t/** Unique identifier for the scribble */\n\tid: string\n\t/** Array of points that make up the scribble path */\n\tpoints: VecModel[]\n\t/** The brush size/width of the scribble stroke */\n\tsize: number\n\t/** The color of the scribble using canvas UI color types */\n\tcolor: TLCanvasUiColor\n\t/** The opacity of the scribble (0-1) */\n\topacity: number\n\t/** The current state of the scribble drawing */\n\tstate: SetValue<typeof TL_SCRIBBLE_STATES>\n\t/** Time delay in milliseconds for animation effects */\n\tdelay: number\n\t/** Amount the stroke should shrink over time (0-1) */\n\tshrink: number\n\t/** Whether the stroke should taper at the ends */\n\ttaper: boolean\n}\n\n/**\n * A validator for TLScribble objects.\n *\n * This validator ensures that scribble objects have all required properties\n * with valid types and values. It validates the points array, size constraints,\n * color types, and state values according to the scribble system requirements.\n *\n * @example\n * ```ts\n * import { scribbleValidator } from '@tldraw/tlschema'\n *\n * // Validate a scribble object\n * try {\n *   const validScribble = scribbleValidator.validate({\n *     id: 'scribble-1',\n *     points: [{ x: 0, y: 0, z: 1 }, { x: 10, y: 10, z: 1 }],\n *     size: 3,\n *     color: 'black',\n *     opacity: 0.8,\n *     state: 'active',\n *     delay: 0,\n *     shrink: 0.05,\n *     taper: true\n *   })\n *   console.log('Valid scribble:', validScribble)\n * } catch (error) {\n *   console.error('Invalid scribble:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const scribbleValidator: T.ObjectValidator<TLScribble> = T.object({\n\tid: T.string,\n\tpoints: T.arrayOf(vecModelValidator),\n\tsize: T.positiveNumber,\n\tcolor: canvasUiColorTypeValidator,\n\topacity: T.number,\n\tstate: T.setEnum(TL_SCRIBBLE_STATES),\n\tdelay: T.number,\n\tshrink: T.number,\n\ttaper: T.boolean,\n})\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,SAAS;AAElB,SAA0B,kCAAkC;AAC5D,SAAmB,yBAAyB;;;;AA4BrC,MAAM,qBAAqB,aAAA,GAAA,IAAI,IAAI;IAAC;IAAY;IAAU;IAAU,UAAU;CAAU;AAiGxF,MAAM,oBAAmD,8MAAA,CAAE,MAAA,CAAO;IACxE,IAAI,8MAAA,CAAE,MAAA;IACN,QAAQ,8MAAA,CAAE,OAAA,CAAQ,yMAAiB;IACnC,MAAM,8MAAA,CAAE,cAAA;IACR,OAAO,wMAAA;IACP,SAAS,8MAAA,CAAE,MAAA;IACX,OAAO,8MAAA,CAAE,OAAA,CAAQ,kBAAkB;IACnC,OAAO,8MAAA,CAAE,MAAA;IACT,QAAQ,8MAAA,CAAE,MAAA;IACV,OAAO,8MAAA,CAAE,OAAA;AACV,CAAC","debugId":null}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLPage.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { IndexKey, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * A page within a tldraw document. Pages are containers for shapes and provide\n * a way to organize content into separate canvases. Each document can have multiple\n * pages, and users can navigate between them.\n *\n * Pages have a name for identification, an index for ordering, and can store\n * custom metadata.\n *\n * @example\n * ```ts\n * const page: TLPage = {\n *   id: 'page:page1',\n *   typeName: 'page',\n *   name: 'Page 1',\n *   index: 'a1',\n *   meta: { description: 'Main design page' }\n * }\n * ```\n *\n * @public\n */\nexport interface TLPage extends BaseRecord<'page', TLPageId> {\n\tname: string\n\tindex: IndexKey\n\tmeta: JsonObject\n}\n\n/**\n * A unique identifier for TLPage records.\n *\n * Page IDs follow the format 'page:' followed by a unique string identifier.\n *\n * @example\n * ```ts\n * const pageId: TLPageId = 'page:main'\n * const pageId2: TLPageId = createShapeId() // generates 'page:abc123'\n * ```\n *\n * @public\n */\nexport type TLPageId = RecordId<TLPage>\n\n/**\n * Validator for TLPageId values. Ensures the ID follows the correct\n * format for page records ('page:' prefix).\n *\n * @example\n * ```ts\n * const isValid = pageIdValidator.isValid('page:main') // true\n * const isValid2 = pageIdValidator.isValid('shape:abc') // false\n * ```\n *\n * @public\n */\nexport const pageIdValidator = idValidator<TLPageId>('page')\n\n/**\n * Runtime validator for TLPage records. Validates the structure and types\n * of all page properties to ensure data integrity.\n *\n * @example\n * ```ts\n * const page = { id: 'page:1', typeName: 'page', name: 'My Page', index: 'a1', meta: {} }\n * const isValid = pageValidator.isValid(page) // true\n * ```\n *\n * @public\n */\nexport const pageValidator: T.Validator<TLPage> = T.model(\n\t'page',\n\tT.object({\n\t\ttypeName: T.literal('page'),\n\t\tid: pageIdValidator,\n\t\tname: T.string,\n\t\tindex: T.indexKey,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Migration version identifiers for TLPage records. Each version represents\n * a schema change that requires data transformation when loading older documents.\n *\n * @public\n */\nexport const pageVersions = createMigrationIds('com.tldraw.page', {\n\tAddMeta: 1,\n})\n\n/**\n * Migration sequence for TLPage records. Defines how to transform page\n * records between different schema versions, ensuring data compatibility.\n *\n * @example\n * ```ts\n * // Migrations are applied automatically when loading documents\n * const migratedPage = pageMigrations.migrate(oldPage, targetVersion)\n * ```\n *\n * @public\n */\nexport const pageMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.page',\n\trecordType: 'page',\n\tsequence: [\n\t\t{\n\t\t\tid: pageVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * The RecordType definition for TLPage records. Defines validation, scope,\n * and default properties for page records in the tldraw store.\n *\n * Pages are scoped to the document level, meaning they persist across sessions\n * and are shared in collaborative environments.\n *\n * @example\n * ```ts\n * const page = PageRecordType.create({\n *   id: 'page:main',\n *   name: 'Main Page',\n *   index: 'a1'\n * })\n * ```\n *\n * @public\n */\nexport const PageRecordType = createRecordType<TLPage>('page', {\n\tvalidator: pageValidator,\n\tscope: 'document',\n}).withDefaultProperties(() => ({\n\tmeta: {},\n}))\n\n/**\n * Type guard to check if a string is a valid TLPageId.\n *\n * @param id - The string to check\n * @returns True if the ID is a valid page ID, false otherwise\n *\n * @example\n * ```ts\n * if (isPageId('page:main')) {\n *   // TypeScript knows this is a TLPageId\n *   console.log('Valid page ID')\n * }\n * ```\n *\n * @public\n */\nexport function isPageId(id: string): id is TLPageId {\n\treturn PageRecordType.isId(id)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAQA,SAAS,SAAS;AAClB,SAAS,mBAAmB;;;;AAwDrB,MAAM,sBAAkB,iMAAA,EAAsB,MAAM;AAcpD,MAAM,gBAAqC,8MAAA,CAAE,KAAA,CACnD,QACA,8MAAA,CAAE,MAAA,CAAO;IACR,UAAU,8MAAA,CAAE,OAAA,CAAQ,MAAM;IAC1B,IAAI;IACJ,MAAM,8MAAA,CAAE,MAAA;IACR,OAAO,8MAAA,CAAE,QAAA;IACT,MAAM,8MAAA,CAAE,SAAA;AACT,CAAC;AASK,MAAM,mBAAe,4LAAA,EAAmB,mBAAmB;IACjE,SAAS;AACV,CAAC;AAcM,MAAM,qBAAiB,uMAAA,EAA8B;IAC3D,YAAY;IACZ,YAAY;IACZ,UAAU;QACT;YACC,IAAI,aAAa,OAAA;YACjB,IAAI,CAAC,WAAgB;gBACpB,OAAO,IAAA,GAAO,CAAC;YAChB;QACD;KACD;AACD,CAAC;AAoBM,MAAM,qBAAiB,6LAAA,EAAyB,QAAQ;IAC9D,WAAW;IACX,OAAO;AACR,CAAC,EAAE,qBAAA,CAAsB,IAAA,CAAO;QAC/B,MAAM,CAAC;IACR,CAAA,CAAE;AAkBK,SAAS,SAAS,EAAA,EAA4B;IACpD,OAAO,eAAe,IAAA,CAAK,EAAE;AAC9B","debugId":null}},
    {"offset": {"line": 1705, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLInstance.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { filterEntries, JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { BoxModel, boxModelValidator } from '../misc/geometry-types'\nimport { idValidator } from '../misc/id-validator'\nimport { cursorValidator, TLCursor } from '../misc/TLCursor'\nimport { opacityValidator, TLOpacityType } from '../misc/TLOpacity'\nimport { scribbleValidator, TLScribble } from '../misc/TLScribble'\nimport { StyleProp } from '../styles/StyleProp'\nimport { pageIdValidator, TLPageId } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/**\n * State that is particular to a single browser tab. The TLInstance record stores\n * all session-specific state including cursor position, selected tools, UI preferences,\n * and temporary interaction state.\n *\n * Each browser tab has exactly one TLInstance record that persists for the duration\n * of the session and tracks the user's current interaction state.\n *\n * @example\n * ```ts\n * const instance: TLInstance = {\n *   id: 'instance:instance',\n *   typeName: 'instance',\n *   currentPageId: 'page:page1',\n *   cursor: { type: 'default', rotation: 0 },\n *   screenBounds: { x: 0, y: 0, w: 1920, h: 1080 },\n *   isFocusMode: false,\n *   isGridMode: true\n * }\n * ```\n *\n * @public\n */\nexport interface TLInstance extends BaseRecord<'instance', TLInstanceId> {\n\tcurrentPageId: TLPageId\n\topacityForNextShape: TLOpacityType\n\tstylesForNextShape: Record<string, unknown>\n\tfollowingUserId: string | null\n\thighlightedUserIds: string[]\n\tbrush: BoxModel | null\n\tcursor: TLCursor\n\tscribbles: TLScribble[]\n\tisFocusMode: boolean\n\tisDebugMode: boolean\n\tisToolLocked: boolean\n\texportBackground: boolean\n\tscreenBounds: BoxModel\n\tinsets: boolean[]\n\tzoomBrush: BoxModel | null\n\tchatMessage: string\n\tisChatting: boolean\n\tisPenMode: boolean\n\tisGridMode: boolean\n\tisFocused: boolean\n\tdevicePixelRatio: number\n\t/**\n\t * This is whether the primary input mechanism includes a pointing device of limited accuracy,\n\t * such as a finger on a touchscreen.\n\t */\n\tisCoarsePointer: boolean\n\t/**\n\t * Will be null if the pointer doesn't support hovering (e.g. touch), but true or false\n\t * otherwise\n\t */\n\tisHoveringCanvas: boolean | null\n\topenMenus: string[]\n\tisChangingStyle: boolean\n\tisReadonly: boolean\n\tmeta: JsonObject\n\tduplicateProps: {\n\t\tshapeIds: TLShapeId[]\n\t\toffset: {\n\t\t\tx: number\n\t\t\ty: number\n\t\t}\n\t} | null\n}\n\n/**\n * Configuration object defining which TLInstance properties should be preserved\n * when loading snapshots across browser sessions. Properties marked as `true`\n * represent user preferences that should persist, while `false` indicates\n * temporary state that should reset.\n *\n * @internal\n */\nexport const shouldKeyBePreservedBetweenSessions = {\n\t// This object defines keys that should be preserved across calls to loadSnapshot()\n\n\tid: false, // meta\n\ttypeName: false, // meta\n\n\tcurrentPageId: false, // does not preserve because who knows if the page still exists\n\topacityForNextShape: false, // does not preserve because it's a temporary state\n\tstylesForNextShape: false, // does not preserve because it's a temporary state\n\tfollowingUserId: false, // does not preserve because it's a temporary state\n\thighlightedUserIds: false, // does not preserve because it's a temporary state\n\tbrush: false, // does not preserve because it's a temporary state\n\tcursor: false, // does not preserve because it's a temporary state\n\tscribbles: false, // does not preserve because it's a temporary state\n\n\tisFocusMode: true, // preserves because it's a user preference\n\tisDebugMode: true, // preserves because it's a user preference\n\tisToolLocked: true, // preserves because it's a user preference\n\texportBackground: true, // preserves because it's a user preference\n\tscreenBounds: true, // preserves because it's capturing the user's screen state\n\tinsets: true, // preserves because it's capturing the user's screen state\n\n\tzoomBrush: false, // does not preserve because it's a temporary state\n\tchatMessage: false, // does not preserve because it's a temporary state\n\tisChatting: false, // does not preserve because it's a temporary state\n\tisPenMode: false, // does not preserve because it's a temporary state\n\n\tisGridMode: true, // preserves because it's a user preference\n\tisFocused: true, // preserves because obviously\n\tdevicePixelRatio: true, // preserves because it captures the user's screen state\n\tisCoarsePointer: true, // preserves because it captures the user's screen state\n\tisHoveringCanvas: false, // does not preserve because it's a temporary state\n\topenMenus: false, // does not preserve because it's a temporary state\n\tisChangingStyle: false, // does not preserve because it's a temporary state\n\tisReadonly: true, // preserves because it's a config option\n\tmeta: false, // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate\n\tduplicateProps: false, //\n} as const satisfies { [K in keyof TLInstance]: boolean }\n\n/**\n * Extracts only the properties from a TLInstance that should be preserved\n * between browser sessions, filtering out temporary state.\n *\n * @param val - The TLInstance to filter, or null/undefined\n * @returns A partial TLInstance containing only preservable properties, or null\n *\n * @internal\n */\nexport function pluckPreservingValues(val?: TLInstance | null): null | Partial<TLInstance> {\n\treturn val\n\t\t? (filterEntries(val, (key) => {\n\t\t\t\treturn shouldKeyBePreservedBetweenSessions[key as keyof TLInstance]\n\t\t\t}) as Partial<TLInstance>)\n\t\t: null\n}\n\n/**\n * A unique identifier for TLInstance records.\n *\n * TLInstance IDs are always the constant 'instance:instance' since there\n * is exactly one instance record per browser tab.\n *\n * @public\n */\nexport type TLInstanceId = RecordId<TLInstance>\n\n/**\n * Validator for TLInstanceId values. Ensures the ID follows the correct\n * format for instance records.\n *\n * @example\n * ```ts\n * const isValid = instanceIdValidator.isValid('instance:instance') // true\n * const isValid2 = instanceIdValidator.isValid('invalid') // false\n * ```\n *\n * @public\n */\nexport const instanceIdValidator = idValidator<TLInstanceId>('instance')\n\n/**\n * Creates the record type definition for TLInstance records, including validation\n * and default properties. The function takes a map of available style properties\n * to configure validation for the stylesForNextShape field.\n *\n * @param stylesById - Map of style property IDs to their corresponding StyleProp definitions\n * @returns A configured RecordType for TLInstance records\n *\n * @example\n * ```ts\n * const stylesMap = new Map([['color', DefaultColorStyle]])\n * const InstanceRecordType = createInstanceRecordType(stylesMap)\n *\n * const instance = InstanceRecordType.create({\n *   id: 'instance:instance',\n *   currentPageId: 'page:page1'\n * })\n * ```\n *\n * @public\n */\nexport function createInstanceRecordType(stylesById: Map<string, StyleProp<unknown>>) {\n\tconst stylesForNextShapeValidators = {} as Record<string, T.Validator<unknown>>\n\tfor (const [id, style] of stylesById) {\n\t\tstylesForNextShapeValidators[id] = T.optional(style)\n\t}\n\n\tconst instanceTypeValidator: T.Validator<TLInstance> = T.model(\n\t\t'instance',\n\t\tT.object({\n\t\t\ttypeName: T.literal('instance'),\n\t\t\tid: idValidator<TLInstanceId>('instance'),\n\t\t\tcurrentPageId: pageIdValidator,\n\t\t\tfollowingUserId: T.string.nullable(),\n\t\t\tbrush: boxModelValidator.nullable(),\n\t\t\topacityForNextShape: opacityValidator,\n\t\t\tstylesForNextShape: T.object(stylesForNextShapeValidators),\n\t\t\tcursor: cursorValidator,\n\t\t\tscribbles: T.arrayOf(scribbleValidator),\n\t\t\tisFocusMode: T.boolean,\n\t\t\tisDebugMode: T.boolean,\n\t\t\tisToolLocked: T.boolean,\n\t\t\texportBackground: T.boolean,\n\t\t\tscreenBounds: boxModelValidator,\n\t\t\tinsets: T.arrayOf(T.boolean),\n\t\t\tzoomBrush: boxModelValidator.nullable(),\n\t\t\tisPenMode: T.boolean,\n\t\t\tisGridMode: T.boolean,\n\t\t\tchatMessage: T.string,\n\t\t\tisChatting: T.boolean,\n\t\t\thighlightedUserIds: T.arrayOf(T.string),\n\t\t\tisFocused: T.boolean,\n\t\t\tdevicePixelRatio: T.number,\n\t\t\tisCoarsePointer: T.boolean,\n\t\t\tisHoveringCanvas: T.boolean.nullable(),\n\t\t\topenMenus: T.arrayOf(T.string),\n\t\t\tisChangingStyle: T.boolean,\n\t\t\tisReadonly: T.boolean,\n\t\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t\t\tduplicateProps: T.object({\n\t\t\t\tshapeIds: T.arrayOf(idValidator<TLShapeId>('shape')),\n\t\t\t\toffset: T.object({\n\t\t\t\t\tx: T.number,\n\t\t\t\t\ty: T.number,\n\t\t\t\t}),\n\t\t\t}).nullable(),\n\t\t})\n\t)\n\n\treturn createRecordType<TLInstance>('instance', {\n\t\tvalidator: instanceTypeValidator,\n\t\tscope: 'session',\n\t\tephemeralKeys: {\n\t\t\tcurrentPageId: false,\n\t\t\tmeta: false,\n\n\t\t\tfollowingUserId: true,\n\t\t\topacityForNextShape: true,\n\t\t\tstylesForNextShape: true,\n\t\t\tbrush: true,\n\t\t\tcursor: true,\n\t\t\tscribbles: true,\n\t\t\tisFocusMode: true,\n\t\t\tisDebugMode: true,\n\t\t\tisToolLocked: true,\n\t\t\texportBackground: true,\n\t\t\tscreenBounds: true,\n\t\t\tinsets: true,\n\t\t\tzoomBrush: true,\n\t\t\tisPenMode: true,\n\t\t\tisGridMode: true,\n\t\t\tchatMessage: true,\n\t\t\tisChatting: true,\n\t\t\thighlightedUserIds: true,\n\t\t\tisFocused: true,\n\t\t\tdevicePixelRatio: true,\n\t\t\tisCoarsePointer: true,\n\t\t\tisHoveringCanvas: true,\n\t\t\topenMenus: true,\n\t\t\tisChangingStyle: true,\n\t\t\tisReadonly: true,\n\t\t\tduplicateProps: true,\n\t\t},\n\t}).withDefaultProperties(\n\t\t(): Omit<TLInstance, 'typeName' | 'id' | 'currentPageId'> => ({\n\t\t\tfollowingUserId: null,\n\t\t\topacityForNextShape: 1,\n\t\t\tstylesForNextShape: {},\n\t\t\tbrush: null,\n\t\t\tscribbles: [],\n\t\t\tcursor: {\n\t\t\t\ttype: 'default',\n\t\t\t\trotation: 0,\n\t\t\t},\n\t\t\tisFocusMode: false,\n\t\t\texportBackground: false,\n\t\t\tisDebugMode: false,\n\t\t\tisToolLocked: false,\n\t\t\tscreenBounds: { x: 0, y: 0, w: 1080, h: 720 },\n\t\t\tinsets: [false, false, false, false],\n\t\t\tzoomBrush: null,\n\t\t\tisGridMode: false,\n\t\t\tisPenMode: false,\n\t\t\tchatMessage: '',\n\t\t\tisChatting: false,\n\t\t\thighlightedUserIds: [],\n\t\t\tisFocused: false,\n\t\t\tdevicePixelRatio: typeof window === 'undefined' ? 1 : window.devicePixelRatio,\n\t\t\tisCoarsePointer: false,\n\t\t\tisHoveringCanvas: null,\n\t\t\topenMenus: [] as string[],\n\t\t\tisChangingStyle: false,\n\t\t\tisReadonly: false,\n\t\t\tmeta: {},\n\t\t\tduplicateProps: null,\n\t\t})\n\t)\n}\n\n/**\n * Migration version identifiers for TLInstance records. Each version represents\n * a schema change that requires data transformation when loading older documents.\n *\n * The versions track the evolution of the instance record structure over time,\n * enabling backward and forward compatibility.\n *\n * @public\n */\nexport const instanceVersions = createMigrationIds('com.tldraw.instance', {\n\tAddTransparentExportBgs: 1,\n\tRemoveDialog: 2,\n\tAddToolLockMode: 3,\n\tRemoveExtraPropsForNextShape: 4,\n\tAddLabelColor: 5,\n\tAddFollowingUserId: 6,\n\tRemoveAlignJustify: 7,\n\tAddZoom: 8,\n\tAddVerticalAlign: 9,\n\tAddScribbleDelay: 10,\n\tRemoveUserId: 11,\n\tAddIsPenModeAndIsGridMode: 12,\n\tHoistOpacity: 13,\n\tAddChat: 14,\n\tAddHighlightedUserIds: 15,\n\tReplacePropsForNextShapeWithStylesForNextShape: 16,\n\tAddMeta: 17,\n\tRemoveCursorColor: 18,\n\tAddLonelyProperties: 19,\n\tReadOnlyReadonly: 20,\n\tAddHoveringCanvas: 21,\n\tAddScribbles: 22,\n\tAddInset: 23,\n\tAddDuplicateProps: 24,\n\tRemoveCanMoveCamera: 25,\n} as const)\n\n// TODO: rewrite these to use mutation\n\n/**\n * Migration sequence for TLInstance records. Defines how to transform instance\n * records between different schema versions, ensuring data compatibility when\n * loading documents created with different versions of tldraw.\n *\n * Each migration includes an 'up' function to migrate forward and optionally\n * a 'down' function for reverse migration.\n *\n * @example\n * ```ts\n * // Migrations are applied automatically when loading documents\n * const migratedInstance = instanceMigrations.migrate(oldInstance, targetVersion)\n * ```\n *\n * @public\n */\nexport const instanceMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance',\n\trecordType: 'instance',\n\tsequence: [\n\t\t{\n\t\t\tid: instanceVersions.AddTransparentExportBgs,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, exportBackground: true }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveDialog,\n\t\t\tup: ({ dialog: _, ...instance }: any) => {\n\t\t\t\treturn instance\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tid: instanceVersions.AddToolLockMode,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, isToolLocked: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveExtraPropsForNextShape,\n\t\t\tup: ({ propsForNextShape, ...instance }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: Object.fromEntries(\n\t\t\t\t\t\tObject.entries(propsForNextShape).filter(([key]) =>\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t'color',\n\t\t\t\t\t\t\t\t'labelColor',\n\t\t\t\t\t\t\t\t'dash',\n\t\t\t\t\t\t\t\t'fill',\n\t\t\t\t\t\t\t\t'size',\n\t\t\t\t\t\t\t\t'font',\n\t\t\t\t\t\t\t\t'align',\n\t\t\t\t\t\t\t\t'verticalAlign',\n\t\t\t\t\t\t\t\t'icon',\n\t\t\t\t\t\t\t\t'geo',\n\t\t\t\t\t\t\t\t'arrowheadStart',\n\t\t\t\t\t\t\t\t'arrowheadEnd',\n\t\t\t\t\t\t\t\t'spline',\n\t\t\t\t\t\t\t].includes(key)\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddLabelColor,\n\t\t\tup: ({ propsForNextShape, ...instance }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...propsForNextShape,\n\t\t\t\t\t\tlabelColor: 'black',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddFollowingUserId,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, followingUserId: null }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveAlignJustify,\n\t\t\tup: (instance: any) => {\n\t\t\t\tlet newAlign = instance.propsForNextShape.align\n\t\t\t\tif (newAlign === 'justify') {\n\t\t\t\t\tnewAlign = 'start'\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...instance.propsForNextShape,\n\t\t\t\t\t\talign: newAlign,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddZoom,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, zoomBrush: null }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddVerticalAlign,\n\t\t\tup: (instance: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...instance,\n\t\t\t\t\tpropsForNextShape: {\n\t\t\t\t\t\t...instance.propsForNextShape,\n\t\t\t\t\t\tverticalAlign: 'middle',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddScribbleDelay,\n\t\t\tup: (instance: any) => {\n\t\t\t\tif (instance.scribble !== null) {\n\t\t\t\t\treturn { ...instance, scribble: { ...instance.scribble, delay: 0 } }\n\t\t\t\t}\n\t\t\t\treturn { ...instance }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveUserId,\n\t\t\tup: ({ userId: _, ...instance }: any) => {\n\t\t\t\treturn instance\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddIsPenModeAndIsGridMode,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, isPenMode: false, isGridMode: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.HoistOpacity,\n\t\t\tup: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }: any) => {\n\t\t\t\treturn { ...instance, opacityForNextShape: Number(opacity ?? '1'), propsForNextShape }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddChat,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, chatMessage: '', isChatting: false }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddHighlightedUserIds,\n\t\t\tup: (instance) => {\n\t\t\t\treturn { ...instance, highlightedUserIds: [] }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,\n\t\t\tup: ({ propsForNextShape: _, ...instance }: any) => {\n\t\t\t\treturn { ...instance, stylesForNextShape: {} }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tmeta: {},\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveCursorColor,\n\t\t\tup: (record: any) => {\n\t\t\t\tconst { color: _, ...cursor } = record.cursor\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tcursor,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddLonelyProperties,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tcanMoveCamera: true,\n\t\t\t\t\tisFocused: false,\n\t\t\t\t\tdevicePixelRatio: 1,\n\t\t\t\t\tisCoarsePointer: false,\n\t\t\t\t\topenMenus: [],\n\t\t\t\t\tisChangingStyle: false,\n\t\t\t\t\tisReadOnly: false,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.ReadOnlyReadonly,\n\t\t\tup: ({ isReadOnly: _isReadOnly, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tisReadonly: _isReadOnly,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddHoveringCanvas,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tisHoveringCanvas: null,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddScribbles,\n\t\t\tup: ({ scribble: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tscribbles: [],\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddInset,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tinsets: [false, false, false, false],\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ insets: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.AddDuplicateProps,\n\t\t\tup: (record) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t\tduplicateProps: null,\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: ({ duplicateProps: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instanceVersions.RemoveCanMoveCamera,\n\t\t\tup: ({ canMoveCamera: _, ...record }: any) => {\n\t\t\t\treturn {\n\t\t\t\t\t...record,\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (instance) => {\n\t\t\t\treturn { ...instance, canMoveCamera: true }\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * The constant ID used for the singleton TLInstance record.\n *\n * Since each browser tab has exactly one instance, this constant ID\n * is used universally across the application.\n *\n * @example\n * ```ts\n * const instance = store.get(TLINSTANCE_ID)\n * if (instance) {\n *   console.log('Current page:', instance.currentPageId)\n * }\n * ```\n *\n * @public\n */\nexport const TLINSTANCE_ID = 'instance:instance' as TLInstanceId\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2254, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLPageState.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\nimport { shapeIdValidator } from '../shapes/TLBaseShape'\nimport { pageIdValidator, TLPage } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/**\n * State that is unique to a particular page within a particular browser tab.\n * This record tracks all page-specific interaction state including selected shapes,\n * editing state, hover state, and other transient UI state that is tied to\n * both a specific page and a specific browser session.\n *\n * Each combination of page and browser tab has its own TLInstancePageState record.\n *\n * @example\n * ```ts\n * const pageState: TLInstancePageState = {\n *   id: 'instance_page_state:page1',\n *   typeName: 'instance_page_state',\n *   pageId: 'page:page1',\n *   selectedShapeIds: ['shape:rect1', 'shape:circle2'],\n *   hoveredShapeId: 'shape:text3',\n *   editingShapeId: null,\n *   focusedGroupId: null\n * }\n * ```\n *\n * @public\n */\nexport interface TLInstancePageState\n\textends BaseRecord<'instance_page_state', TLInstancePageStateId> {\n\tpageId: RecordId<TLPage>\n\tselectedShapeIds: TLShapeId[]\n\thintingShapeIds: TLShapeId[]\n\terasingShapeIds: TLShapeId[]\n\thoveredShapeId: TLShapeId | null\n\teditingShapeId: TLShapeId | null\n\tcroppingShapeId: TLShapeId | null\n\tfocusedGroupId: TLShapeId | null\n\tmeta: JsonObject\n}\n\n/**\n * Runtime validator for TLInstancePageState records. Validates the structure\n * and types of all instance page state properties to ensure data integrity.\n *\n * @example\n * ```ts\n * const pageState = {\n *   id: 'instance_page_state:page1',\n *   typeName: 'instance_page_state',\n *   pageId: 'page:page1',\n *   selectedShapeIds: ['shape:rect1'],\n *   // ... other properties\n * }\n * const isValid = instancePageStateValidator.isValid(pageState) // true\n * ```\n *\n * @public\n */\nexport const instancePageStateValidator: T.Validator<TLInstancePageState> = T.model(\n\t'instance_page_state',\n\tT.object({\n\t\ttypeName: T.literal('instance_page_state'),\n\t\tid: idValidator<TLInstancePageStateId>('instance_page_state'),\n\t\tpageId: pageIdValidator,\n\t\tselectedShapeIds: T.arrayOf(shapeIdValidator),\n\t\thintingShapeIds: T.arrayOf(shapeIdValidator),\n\t\terasingShapeIds: T.arrayOf(shapeIdValidator),\n\t\thoveredShapeId: shapeIdValidator.nullable(),\n\t\teditingShapeId: shapeIdValidator.nullable(),\n\t\tcroppingShapeId: shapeIdValidator.nullable(),\n\t\tfocusedGroupId: shapeIdValidator.nullable(),\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Migration version identifiers for TLInstancePageState records. Each version\n * represents a schema change that requires data transformation when loading\n * older documents.\n *\n * @public\n */\nexport const instancePageStateVersions = createMigrationIds('com.tldraw.instance_page_state', {\n\tAddCroppingId: 1,\n\tRemoveInstanceIdAndCameraId: 2,\n\tAddMeta: 3,\n\tRenameProperties: 4,\n\tRenamePropertiesAgain: 5,\n} as const)\n\n/**\n * Migration sequence for TLInstancePageState records. Defines how to transform\n * instance page state records between different schema versions, ensuring data\n * compatibility when loading documents created with different versions.\n *\n * @example\n * ```ts\n * // Migrations are applied automatically when loading documents\n * const migrated = instancePageStateMigrations.migrate(oldState, targetVersion)\n * ```\n *\n * @public\n */\nexport const instancePageStateMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance_page_state',\n\trecordType: 'instance_page_state',\n\tsequence: [\n\t\t{\n\t\t\tid: instancePageStateVersions.AddCroppingId,\n\t\t\tup(instance: any) {\n\t\t\t\tinstance.croppingShapeId = null\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RemoveInstanceIdAndCameraId,\n\t\t\tup(instance: any) {\n\t\t\t\tdelete instance.instanceId\n\t\t\t\tdelete instance.cameraId\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RenameProperties,\n\t\t\t// this migration is cursed: it was written wrong and doesn't do anything.\n\t\t\t// rather than replace it, I've added another migration below that fixes it.\n\t\t\tup: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (_record) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePageStateVersions.RenamePropertiesAgain,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.selectedShapeIds = record.selectedIds\n\t\t\t\tdelete record.selectedIds\n\t\t\t\trecord.hintingShapeIds = record.hintingIds\n\t\t\t\tdelete record.hintingIds\n\t\t\t\trecord.erasingShapeIds = record.erasingIds\n\t\t\t\tdelete record.erasingIds\n\t\t\t\trecord.hoveredShapeId = record.hoveredId\n\t\t\t\tdelete record.hoveredId\n\t\t\t\trecord.editingShapeId = record.editingId\n\t\t\t\tdelete record.editingId\n\t\t\t\trecord.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null\n\t\t\t\tdelete record.croppingId\n\t\t\t\trecord.focusedGroupId = record.focusLayerId\n\t\t\t\tdelete record.focusLayerId\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\trecord.selectedIds = record.selectedShapeIds\n\t\t\t\tdelete record.selectedShapeIds\n\t\t\t\trecord.hintingIds = record.hintingShapeIds\n\t\t\t\tdelete record.hintingShapeIds\n\t\t\t\trecord.erasingIds = record.erasingShapeIds\n\t\t\t\tdelete record.erasingShapeIds\n\t\t\t\trecord.hoveredId = record.hoveredShapeId\n\t\t\t\tdelete record.hoveredShapeId\n\t\t\t\trecord.editingId = record.editingShapeId\n\t\t\t\tdelete record.editingShapeId\n\t\t\t\trecord.croppingId = record.croppingShapeId\n\t\t\t\tdelete record.croppingShapeId\n\t\t\t\trecord.focusLayerId = record.focusedGroupId\n\t\t\t\tdelete record.focusedGroupId\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * The RecordType definition for TLInstancePageState records. Defines validation,\n * scope, and default properties for instance page state records.\n *\n * Instance page states are scoped to the session level, meaning they are\n * specific to a browser tab and don't persist across sessions or sync\n * in collaborative environments.\n *\n * @example\n * ```ts\n * const pageState = InstancePageStateRecordType.create({\n *   id: 'instance_page_state:page1',\n *   pageId: 'page:page1',\n *   selectedShapeIds: ['shape:rect1']\n * })\n * ```\n *\n * @public\n */\nexport const InstancePageStateRecordType = createRecordType<TLInstancePageState>(\n\t'instance_page_state',\n\t{\n\t\tvalidator: instancePageStateValidator,\n\t\tscope: 'session',\n\t\tephemeralKeys: {\n\t\t\tpageId: false,\n\t\t\tselectedShapeIds: false,\n\t\t\teditingShapeId: false,\n\t\t\tcroppingShapeId: false,\n\t\t\tmeta: false,\n\n\t\t\thintingShapeIds: true,\n\t\t\terasingShapeIds: true,\n\t\t\thoveredShapeId: true,\n\t\t\tfocusedGroupId: true,\n\t\t},\n\t}\n).withDefaultProperties(\n\t(): Omit<TLInstancePageState, 'id' | 'typeName' | 'pageId'> => ({\n\t\teditingShapeId: null,\n\t\tcroppingShapeId: null,\n\t\tselectedShapeIds: [],\n\t\thoveredShapeId: null,\n\t\terasingShapeIds: [],\n\t\thintingShapeIds: [],\n\t\tfocusedGroupId: null,\n\t\tmeta: {},\n\t})\n)\n\n/**\n * A unique identifier for TLInstancePageState records.\n *\n * Instance page state IDs follow the format 'instance_page_state:' followed\n * by a unique identifier, typically related to the page ID.\n *\n * @example\n * ```ts\n * const stateId: TLInstancePageStateId = 'instance_page_state:page1'\n * ```\n *\n * @public\n */\nexport type TLInstancePageStateId = RecordId<TLInstancePageState>\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2394, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLPointer.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { idValidator } from '../misc/id-validator'\n\n/**\n * Represents the current pointer/cursor position and activity state.\n * This record tracks the mouse or touch pointer coordinates and when\n * the pointer was last active, useful for cursor synchronization in\n * collaborative environments.\n *\n * There is typically one pointer record per browser tab that gets updated\n * as the user moves their mouse or touches the screen.\n *\n * @example\n * ```ts\n * const pointer: TLPointer = {\n *   id: 'pointer:pointer',\n *   typeName: 'pointer',\n *   x: 150,\n *   y: 200,\n *   lastActivityTimestamp: Date.now(),\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport interface TLPointer extends BaseRecord<'pointer', TLPointerId> {\n\tx: number\n\ty: number\n\tlastActivityTimestamp: number\n\tmeta: JsonObject\n}\n\n/**\n * A unique identifier for TLPointer records.\n *\n * Pointer IDs follow the format 'pointer:' followed by a unique identifier.\n * Typically there is one pointer record with a constant ID per session.\n *\n * @example\n * ```ts\n * const pointerId: TLPointerId = 'pointer:pointer'\n * ```\n *\n * @public\n */\nexport type TLPointerId = RecordId<TLPointer>\n\n/**\n * Runtime validator for TLPointer records. Validates the structure\n * and types of all pointer properties to ensure data integrity.\n *\n * @example\n * ```ts\n * const pointer = {\n *   id: 'pointer:pointer',\n *   typeName: 'pointer',\n *   x: 100,\n *   y: 200,\n *   lastActivityTimestamp: Date.now(),\n *   meta: {}\n * }\n * const isValid = pointerValidator.isValid(pointer) // true\n * ```\n *\n * @public\n */\nexport const pointerValidator: T.Validator<TLPointer> = T.model(\n\t'pointer',\n\tT.object({\n\t\ttypeName: T.literal('pointer'),\n\t\tid: idValidator<TLPointerId>('pointer'),\n\t\tx: T.number,\n\t\ty: T.number,\n\t\tlastActivityTimestamp: T.number,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Migration version identifiers for TLPointer records. Each version\n * represents a schema change that requires data transformation when\n * loading older documents.\n *\n * @public\n */\nexport const pointerVersions = createMigrationIds('com.tldraw.pointer', {\n\tAddMeta: 1,\n})\n\n/**\n * Migration sequence for TLPointer records. Defines how to transform\n * pointer records between different schema versions, ensuring data\n * compatibility when loading documents created with different versions.\n *\n * @example\n * ```ts\n * // Migrations are applied automatically when loading documents\n * const migratedPointer = pointerMigrations.migrate(oldPointer, targetVersion)\n * ```\n *\n * @public\n */\nexport const pointerMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.pointer',\n\trecordType: 'pointer',\n\tsequence: [\n\t\t{\n\t\t\tid: pointerVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * The RecordType definition for TLPointer records. Defines validation,\n * scope, and default properties for pointer records in the tldraw store.\n *\n * Pointer records are scoped to the session level, meaning they are\n * specific to a browser tab and don't persist across sessions.\n *\n * @example\n * ```ts\n * const pointer = PointerRecordType.create({\n *   id: 'pointer:pointer',\n *   x: 0,\n *   y: 0\n * })\n * ```\n *\n * @public\n */\nexport const PointerRecordType = createRecordType<TLPointer>('pointer', {\n\tvalidator: pointerValidator,\n\tscope: 'session',\n}).withDefaultProperties(\n\t(): Omit<TLPointer, 'id' | 'typeName'> => ({\n\t\tx: 0,\n\t\ty: 0,\n\t\tlastActivityTimestamp: 0,\n\t\tmeta: {},\n\t})\n)\n\n/**\n * The constant ID used for the singleton TLPointer record.\n *\n * Since each browser tab typically has one pointer, this constant ID\n * is used universally across the application.\n *\n * @example\n * ```ts\n * const pointer = store.get(TLPOINTER_ID)\n * if (pointer) {\n *   console.log('Pointer at:', pointer.x, pointer.y)\n * }\n * ```\n *\n * @public\n */\nexport const TLPOINTER_ID = PointerRecordType.createId('pointer')\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;AAQA,SAAS,SAAS;AAClB,SAAS,mBAAmB;;;;AAkErB,MAAM,mBAA2C,8MAAA,CAAE,KAAA,CACzD,WACA,8MAAA,CAAE,MAAA,CAAO;IACR,UAAU,8MAAA,CAAE,OAAA,CAAQ,SAAS;IAC7B,QAAI,iMAAA,EAAyB,SAAS;IACtC,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,uBAAuB,8MAAA,CAAE,MAAA;IACzB,MAAM,8MAAA,CAAE,SAAA;AACT,CAAC;AAUK,MAAM,sBAAkB,4LAAA,EAAmB,sBAAsB;IACvE,SAAS;AACV,CAAC;AAeM,MAAM,wBAAoB,uMAAA,EAA8B;IAC9D,YAAY;IACZ,YAAY;IACZ,UAAU;QACT;YACC,IAAI,gBAAgB,OAAA;YACpB,IAAI,CAAC,WAAgB;gBACpB,OAAO,IAAA,GAAO,CAAC;YAChB;QACD;KACD;AACD,CAAC;AAoBM,MAAM,wBAAoB,6LAAA,EAA4B,WAAW;IACvE,WAAW;IACX,OAAO;AACR,CAAC,EAAE,qBAAA,CACF,IAAA,CAA2C;QAC1C,GAAG;QACH,GAAG;QACH,uBAAuB;QACvB,MAAM,CAAC;IACR,CAAA;AAmBM,MAAM,eAAe,kBAAkB,QAAA,CAAS,SAAS","debugId":null}},
    {"offset": {"line": 2454, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLPresence.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { BoxModel, boxModelValidator } from '../misc/geometry-types'\nimport { idValidator } from '../misc/id-validator'\nimport { cursorTypeValidator, TLCursor } from '../misc/TLCursor'\nimport { scribbleValidator, TLScribble } from '../misc/TLScribble'\nimport { TLPageId } from './TLPage'\nimport { TLShapeId } from './TLShape'\n\n/**\n * Represents the presence state of a user in a collaborative tldraw session.\n * This record tracks what another user is doing: their cursor position, selected\n * shapes, current page, and other real-time activity indicators.\n *\n * Instance presence records are used in multiplayer environments to show\n * where other collaborators are working and what they're doing.\n *\n * @example\n * ```ts\n * const presence: TLInstancePresence = {\n *   id: 'instance_presence:user123',\n *   typeName: 'instance_presence',\n *   userId: 'user123',\n *   userName: 'Alice',\n *   color: '#FF6B6B',\n *   cursor: { x: 100, y: 150, type: 'default', rotation: 0 },\n *   currentPageId: 'page:main',\n *   selectedShapeIds: ['shape:rect1']\n * }\n * ```\n *\n * @public\n */\nexport interface TLInstancePresence extends BaseRecord<'instance_presence', TLInstancePresenceID> {\n\tuserId: string\n\tuserName: string\n\tlastActivityTimestamp: number | null\n\tcolor: string // can be any hex color\n\tcamera: { x: number; y: number; z: number } | null\n\tselectedShapeIds: TLShapeId[]\n\tcurrentPageId: TLPageId\n\tbrush: BoxModel | null\n\tscribbles: TLScribble[]\n\tscreenBounds: BoxModel | null\n\tfollowingUserId: string | null\n\tcursor: {\n\t\tx: number\n\t\ty: number\n\t\ttype: TLCursor['type']\n\t\trotation: number\n\t} | null\n\tchatMessage: string\n\tmeta: JsonObject\n}\n\n/**\n * A unique identifier for TLInstancePresence records.\n *\n * Instance presence IDs follow the format 'instance_presence:' followed\n * by a unique identifier, typically the user ID.\n *\n * @example\n * ```ts\n * const presenceId: TLInstancePresenceID = 'instance_presence:user123'\n * ```\n *\n * @public\n */\nexport type TLInstancePresenceID = RecordId<TLInstancePresence>\n\n/**\n * Runtime validator for TLInstancePresence records. Validates the structure\n * and types of all instance presence properties to ensure data integrity.\n *\n * @example\n * ```ts\n * const presence = {\n *   id: 'instance_presence:user1',\n *   typeName: 'instance_presence',\n *   userId: 'user1',\n *   userName: 'John',\n *   color: '#007AFF',\n *   cursor: { x: 0, y: 0, type: 'default', rotation: 0 },\n *   currentPageId: 'page:main',\n *   selectedShapeIds: []\n * }\n * const isValid = instancePresenceValidator.isValid(presence) // true\n * ```\n *\n * @public\n */\nexport const instancePresenceValidator: T.Validator<TLInstancePresence> = T.model(\n\t'instance_presence',\n\tT.object({\n\t\ttypeName: T.literal('instance_presence'),\n\t\tid: idValidator<TLInstancePresenceID>('instance_presence'),\n\t\tuserId: T.string,\n\t\tuserName: T.string,\n\t\tlastActivityTimestamp: T.number.nullable(),\n\t\tfollowingUserId: T.string.nullable(),\n\t\tcursor: T.object({\n\t\t\tx: T.number,\n\t\t\ty: T.number,\n\t\t\ttype: cursorTypeValidator,\n\t\t\trotation: T.number,\n\t\t}).nullable(),\n\t\tcolor: T.string,\n\t\tcamera: T.object({\n\t\t\tx: T.number,\n\t\t\ty: T.number,\n\t\t\tz: T.number,\n\t\t}).nullable(),\n\t\tscreenBounds: boxModelValidator.nullable(),\n\t\tselectedShapeIds: T.arrayOf(idValidator<TLShapeId>('shape')),\n\t\tcurrentPageId: idValidator<TLPageId>('page'),\n\t\tbrush: boxModelValidator.nullable(),\n\t\tscribbles: T.arrayOf(scribbleValidator),\n\t\tchatMessage: T.string,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Migration version identifiers for TLInstancePresence records. Each version\n * represents a schema change that requires data transformation when loading\n * older documents.\n *\n * @public\n */\nexport const instancePresenceVersions = createMigrationIds('com.tldraw.instance_presence', {\n\tAddScribbleDelay: 1,\n\tRemoveInstanceId: 2,\n\tAddChatMessage: 3,\n\tAddMeta: 4,\n\tRenameSelectedShapeIds: 5,\n\tNullableCameraCursor: 6,\n} as const)\n\n/**\n * Migration sequence for TLInstancePresence records. Defines how to transform\n * instance presence records between different schema versions, ensuring data\n * compatibility when loading documents created with different versions.\n *\n * @example\n * ```ts\n * // Migrations are applied automatically when loading documents\n * const migrated = instancePresenceMigrations.migrate(oldPresence, targetVersion)\n * ```\n *\n * @public\n */\nexport const instancePresenceMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.instance_presence',\n\trecordType: 'instance_presence',\n\tsequence: [\n\t\t{\n\t\t\tid: instancePresenceVersions.AddScribbleDelay,\n\t\t\tup: (instance: any) => {\n\t\t\t\tif (instance.scribble !== null) {\n\t\t\t\t\tinstance.scribble.delay = 0\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.RemoveInstanceId,\n\t\t\tup: (instance: any) => {\n\t\t\t\tdelete instance.instanceId\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.AddChatMessage,\n\t\t\tup: (instance: any) => {\n\t\t\t\tinstance.chatMessage = ''\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.AddMeta,\n\t\t\tup: (record: any) => {\n\t\t\t\trecord.meta = {}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.RenameSelectedShapeIds,\n\t\t\tup: (_record) => {\n\t\t\t\t// noop, whoopsie\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: instancePresenceVersions.NullableCameraCursor,\n\t\t\tup: (_record: any) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: (record: any) => {\n\t\t\t\tif (record.camera === null) {\n\t\t\t\t\trecord.camera = { x: 0, y: 0, z: 1 }\n\t\t\t\t}\n\t\t\t\tif (record.lastActivityTimestamp === null) {\n\t\t\t\t\trecord.lastActivityTimestamp = 0\n\t\t\t\t}\n\t\t\t\tif (record.cursor === null) {\n\t\t\t\t\trecord.cursor = { type: 'default', x: 0, y: 0, rotation: 0 }\n\t\t\t\t}\n\t\t\t\tif (record.screenBounds === null) {\n\t\t\t\t\trecord.screenBounds = { x: 0, y: 0, w: 1, h: 1 }\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * The RecordType definition for TLInstancePresence records. Defines validation,\n * scope, and default properties for instance presence records.\n *\n * Instance presence records are scoped to the presence level, meaning they\n * represent real-time collaborative state that is ephemeral and tied to\n * active user sessions.\n *\n * @example\n * ```ts\n * const presence = InstancePresenceRecordType.create({\n *   id: 'instance_presence:user1',\n *   userId: 'user1',\n *   userName: 'Alice',\n *   color: '#FF6B6B',\n *   currentPageId: 'page:main'\n * })\n * ```\n *\n * @public\n */\nexport const InstancePresenceRecordType = createRecordType<TLInstancePresence>(\n\t'instance_presence',\n\t{\n\t\tvalidator: instancePresenceValidator,\n\t\tscope: 'presence',\n\t}\n).withDefaultProperties(() => ({\n\tlastActivityTimestamp: null,\n\tfollowingUserId: null,\n\tcolor: '#FF0000',\n\tcamera: null,\n\tcursor: null,\n\tscreenBounds: null,\n\tselectedShapeIds: [],\n\tbrush: null,\n\tscribbles: [],\n\tchatMessage: '',\n\tmeta: {},\n}))\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2604, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/createPresenceStateDerivation.ts"],"sourcesContent":["import { Signal, computed } from '@tldraw/state'\nimport { TLStore } from './TLStore'\nimport { CameraRecordType } from './records/TLCamera'\nimport { TLINSTANCE_ID } from './records/TLInstance'\nimport { InstancePageStateRecordType } from './records/TLPageState'\nimport { TLPOINTER_ID } from './records/TLPointer'\nimport { InstancePresenceRecordType, TLInstancePresence } from './records/TLPresence'\n\n/**\n * The information about a user which is used for multiplayer features.\n * @public\n */\nexport interface TLPresenceUserInfo {\n\t/**\n\t * id - A unique identifier for the user. This should be the same across all devices and sessions.\n\t */\n\tid: string\n\t/**\n\t * The user's display name.\n\t */\n\tname?: string | null\n\t/**\n\t * The user's color. If not given, a random color will be assigned.\n\t */\n\tcolor?: string | null\n}\n\n/**\n * Creates a derivation that represents the current presence state of the current user.\n *\n * This function returns a derivation factory that, when given a store, creates a computed signal\n * containing the user's current presence state. The presence state includes information like cursor\n * position, selected shapes, camera position, and user metadata that gets synchronized in\n * multiplayer scenarios.\n *\n * @param $user - A reactive signal containing the user information\n * @param instanceId - Optional custom instance ID. If not provided, one will be generated based on the store ID\n * @returns A function that takes a store and returns a computed signal of the user's presence state\n *\n * @example\n * ```ts\n * import { createPresenceStateDerivation } from '@tldraw/tlschema'\n * import { atom } from '@tldraw/state'\n *\n * const userSignal = atom('user', { id: 'user-123', name: 'Alice', color: '#ff0000' })\n * const presenceDerivation = createPresenceStateDerivation(userSignal)\n *\n * // Use with a store to get reactive presence state\n * const presenceState = presenceDerivation(store)\n * console.log(presenceState.get()) // Current user presence or null\n * ```\n *\n * @public\n */\nexport function createPresenceStateDerivation(\n\t$user: Signal<TLPresenceUserInfo>,\n\tinstanceId?: TLInstancePresence['id']\n) {\n\treturn (store: TLStore): Signal<TLInstancePresence | null> => {\n\t\treturn computed('instancePresence', () => {\n\t\t\tconst user = $user.get()\n\t\t\tif (!user) return null\n\n\t\t\tconst state = getDefaultUserPresence(store, user)\n\t\t\tif (!state) return null\n\n\t\t\treturn InstancePresenceRecordType.create({\n\t\t\t\t...state,\n\t\t\t\tid: instanceId ?? InstancePresenceRecordType.createId(store.id),\n\t\t\t})\n\t\t})\n\t}\n}\n\n/**\n * The shape of data used to create a presence record.\n *\n * This type represents all the properties needed to construct a TLInstancePresence record.\n * It includes user information, cursor state, camera position, selected shapes, and other\n * presence-related data that gets synchronized across multiplayer clients.\n *\n * @public\n */\nexport type TLPresenceStateInfo = Parameters<(typeof InstancePresenceRecordType)['create']>[0]\n\n/**\n * Creates default presence state information for a user based on the current store state.\n *\n * This function extracts the current state from various store records (instance, page state,\n * camera, pointer) and combines them with user information to create a complete presence\n * state object. This is commonly used as a starting point for custom presence implementations.\n *\n * @param store - The tldraw store containing the current editor state\n * @param user - The user information to include in the presence state\n * @returns The default presence state info, or null if required store records are missing\n *\n * @example\n * ```ts\n * import { getDefaultUserPresence } from '@tldraw/tlschema'\n *\n * const user = { id: 'user-123', name: 'Alice', color: '#ff0000' }\n * const presenceInfo = getDefaultUserPresence(store, user)\n *\n * if (presenceInfo) {\n *   console.log('Current cursor:', presenceInfo.cursor)\n *   console.log('Selected shapes:', presenceInfo.selectedShapeIds)\n *   console.log('Camera position:', presenceInfo.camera)\n * }\n * ```\n *\n * @example\n * ```ts\n * // Common pattern: customize default presence\n * const customPresence = {\n *   ...getDefaultUserPresence(store, user),\n *   // Remove camera for privacy\n *   camera: undefined,\n *   // Add custom metadata\n *   customField: 'my-data'\n * }\n * ```\n *\n * @public\n */\nexport function getDefaultUserPresence(store: TLStore, user: TLPresenceUserInfo) {\n\tconst instance = store.get(TLINSTANCE_ID)\n\tconst pageState = store.get(InstancePageStateRecordType.createId(instance?.currentPageId))\n\tconst camera = store.get(CameraRecordType.createId(instance?.currentPageId))\n\tconst pointer = store.get(TLPOINTER_ID)\n\tif (!pageState || !instance || !camera || !pointer) {\n\t\treturn null\n\t}\n\n\treturn {\n\t\tselectedShapeIds: pageState.selectedShapeIds,\n\t\tbrush: instance.brush,\n\t\tscribbles: instance.scribbles,\n\t\tuserId: user.id,\n\t\tuserName: user.name ?? '',\n\t\tfollowingUserId: instance.followingUserId,\n\t\tcamera: {\n\t\t\tx: camera.x,\n\t\t\ty: camera.y,\n\t\t\tz: camera.z,\n\t\t},\n\t\tcolor: user.color ?? '#FF0000',\n\t\tcurrentPageId: instance.currentPageId,\n\t\tcursor: {\n\t\t\tx: pointer.x,\n\t\t\ty: pointer.y,\n\t\t\trotation: instance.cursor.rotation,\n\t\t\ttype: instance.cursor.type,\n\t\t},\n\t\tlastActivityTimestamp: pointer.lastActivityTimestamp,\n\t\tscreenBounds: instance.screenBounds,\n\t\tchatMessage: instance.chatMessage,\n\t\tmeta: {},\n\t} satisfies TLPresenceStateInfo\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAiB,gBAAgB;AAEjC,SAAS,wBAAwB;AACjC,SAAS,qBAAqB;AAC9B,SAAS,mCAAmC;AAC5C,SAAS,oBAAoB;AAC7B,SAAS,kCAAsD;;;;;;;AAgDxD,SAAS,8BACf,KAAA,EACA,UAAA,EACC;IACD,OAAO,CAAC,UAAsD;QAC7D,WAAO,mLAAA,EAAS,oBAAoB,MAAM;YACzC,MAAM,OAAO,MAAM,GAAA,CAAI;YACvB,IAAI,CAAC,KAAM,CAAA,OAAO;YAElB,MAAM,QAAQ,uBAAuB,OAAO,IAAI;YAChD,IAAI,CAAC,MAAO,CAAA,OAAO;YAEnB,OAAO,8MAAA,CAA2B,MAAA,CAAO;gBACxC,GAAG,KAAA;gBACH,IAAI,cAAc,8MAAA,CAA2B,QAAA,CAAS,MAAM,EAAE;YAC/D,CAAC;QACF,CAAC;IACF;AACD;AAoDO,SAAS,uBAAuB,KAAA,EAAgB,IAAA,EAA0B;IAChF,MAAM,WAAW,MAAM,GAAA,CAAI,iMAAa;IACxC,MAAM,YAAY,MAAM,GAAA,CAAI,gNAAA,CAA4B,QAAA,CAAS,UAAU,aAAa,CAAC;IACzF,MAAM,SAAS,MAAM,GAAA,CAAI,kMAAA,CAAiB,QAAA,CAAS,UAAU,aAAa,CAAC;IAC3E,MAAM,UAAU,MAAM,GAAA,CAAI,+LAAY;IACtC,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,UAAU,CAAC,SAAS;QACnD,OAAO;IACR;IAEA,OAAO;QACN,kBAAkB,UAAU,gBAAA;QAC5B,OAAO,SAAS,KAAA;QAChB,WAAW,SAAS,SAAA;QACpB,QAAQ,KAAK,EAAA;QACb,UAAU,KAAK,IAAA,IAAQ;QACvB,iBAAiB,SAAS,eAAA;QAC1B,QAAQ;YACP,GAAG,OAAO,CAAA;YACV,GAAG,OAAO,CAAA;YACV,GAAG,OAAO,CAAA;QACX;QACA,OAAO,KAAK,KAAA,IAAS;QACrB,eAAe,SAAS,aAAA;QACxB,QAAQ;YACP,GAAG,QAAQ,CAAA;YACX,GAAG,QAAQ,CAAA;YACX,UAAU,SAAS,MAAA,CAAO,QAAA;YAC1B,MAAM,SAAS,MAAA,CAAO,IAAA;QACvB;QACA,uBAAuB,QAAQ,qBAAA;QAC/B,cAAc,SAAS,YAAA;QACvB,aAAa,SAAS,WAAA;QACtB,MAAM,CAAC;IACR;AACD","debugId":null}},
    {"offset": {"line": 2677, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLDocument.ts"],"sourcesContent":["import {\n\tBaseRecord,\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n\tUnknownRecord,\n} from '@tldraw/store'\nimport { JsonObject } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\n\n/**\n * Document record containing global settings and metadata for a tldraw document.\n * There is exactly one document record per tldraw instance with a fixed ID.\n *\n * @example\n * ```ts\n * const document: TLDocument = {\n *   id: 'document:document',\n *   typeName: 'document',\n *   gridSize: 20,        // Grid snap size in pixels\n *   name: 'My Drawing',  // Document name\n *   meta: {\n *     createdAt: Date.now(),\n *     author: 'user123',\n *     version: '1.0.0'\n *   }\n * }\n *\n * // Update document settings\n * editor.updateDocumentSettings({\n *   name: 'Updated Drawing',\n *   gridSize: 25\n * })\n * ```\n *\n * @public\n */\nexport interface TLDocument extends BaseRecord<'document', RecordId<TLDocument>> {\n\t/** Grid snap size in pixels. Used for shape positioning and alignment */\n\tgridSize: number\n\t/** Human-readable name of the document */\n\tname: string\n\t/** User-defined metadata for the document */\n\tmeta: JsonObject\n}\n\n/**\n * Validator for TLDocument records that ensures runtime type safety.\n * Enforces the fixed document ID and validates all document properties.\n *\n * @example\n * ```ts\n * // Validation happens automatically when document is stored\n * try {\n *   const validatedDocument = documentValidator.validate(documentData)\n *   store.put([validatedDocument])\n * } catch (error) {\n *   console.error('Document validation failed:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const documentValidator: T.Validator<TLDocument> = T.model(\n\t'document',\n\tT.object({\n\t\ttypeName: T.literal('document'),\n\t\tid: T.literal('document:document' as RecordId<TLDocument>),\n\t\tgridSize: T.number,\n\t\tname: T.string,\n\t\tmeta: T.jsonValue as T.ObjectValidator<JsonObject>,\n\t})\n)\n\n/**\n * Type guard to check if a record is a TLDocument.\n * Useful for filtering or type narrowing when working with mixed record types.\n *\n * @param record - The record to check\n * @returns True if the record is a document, false otherwise\n *\n * @example\n * ```ts\n * // Type guard usage\n * function processRecord(record: UnknownRecord) {\n *   if (isDocument(record)) {\n *     // record is now typed as TLDocument\n *     console.log(`Document: ${record.name}, Grid: ${record.gridSize}px`)\n *   }\n * }\n *\n * // Filter documents from mixed records\n * const allRecords = store.allRecords()\n * const documents = allRecords.filter(isDocument) // Should be exactly one\n * ```\n *\n * @public\n */\nexport function isDocument(record?: UnknownRecord): record is TLDocument {\n\tif (!record) return false\n\treturn record.typeName === 'document'\n}\n\n/**\n * Migration version identifiers for document record schema evolution.\n * Each version represents a breaking change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if document needs migration\n * const needsNameMigration = currentVersion < documentVersions.AddName\n * const needsMetaMigration = currentVersion < documentVersions.AddMeta\n * ```\n *\n * @public\n */\nexport const documentVersions = createMigrationIds('com.tldraw.document', {\n\tAddName: 1,\n\tAddMeta: 2,\n} as const)\n\n/**\n * Migration sequence for evolving document record structure over time.\n * Handles converting document records from older schema versions to current format.\n *\n * @example\n * ```ts\n * // Migration is applied automatically when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n *\n * // The migrations:\n * // v1: Added 'name' property with empty string default\n * // v2: Added 'meta' property with empty object default\n * ```\n *\n * @public\n */\nexport const documentMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.document',\n\trecordType: 'document',\n\tsequence: [\n\t\t{\n\t\t\tid: documentVersions.AddName,\n\t\t\tup: (document) => {\n\t\t\t\t;(document as any).name = ''\n\t\t\t},\n\t\t\tdown: (document) => {\n\t\t\t\tdelete (document as any).name\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: documentVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Record type definition for TLDocument with validation and default properties.\n * Configures the document as a document-scoped record that persists across sessions.\n *\n * @example\n * ```ts\n * // Create a document record (usually done automatically)\n * const documentRecord = DocumentRecordType.create({\n *   id: TLDOCUMENT_ID,\n *   name: 'My Drawing',\n *   gridSize: 20,\n *   meta: { createdAt: Date.now() }\n * })\n *\n * // Create with defaults\n * const defaultDocument = DocumentRecordType.create({\n *   id: TLDOCUMENT_ID\n *   // gridSize: 10, name: '', meta: {} are applied as defaults\n * })\n *\n * // Store the document\n * store.put([documentRecord])\n * ```\n *\n * @public\n */\nexport const DocumentRecordType = createRecordType<TLDocument>('document', {\n\tvalidator: documentValidator,\n\tscope: 'document',\n}).withDefaultProperties(\n\t(): Omit<TLDocument, 'id' | 'typeName'> => ({\n\t\tgridSize: 10,\n\t\tname: '',\n\t\tmeta: {},\n\t})\n)\n\n/**\n * The fixed ID for the singleton document record in every tldraw store.\n * All document records use this same ID: 'document:document'\n *\n * @example\n * ```ts\n * // Get the document from store\n * const document = store.get(TLDOCUMENT_ID)\n *\n * // Update document settings\n * store.put([{\n *   ...document,\n *   name: 'Updated Name',\n *   gridSize: 25\n * }])\n *\n * // Access via editor\n * const documentSettings = editor.getDocumentSettings()\n * editor.updateDocumentSettings({ name: 'New Name' })\n * ```\n *\n * @public\n */\nexport const TLDOCUMENT_ID: RecordId<TLDocument> = DocumentRecordType.createId('document')\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AASA,SAAS,SAAS;;;AAuDX,MAAM,oBAA6C,8MAAA,CAAE,KAAA,CAC3D,YACA,8MAAA,CAAE,MAAA,CAAO;IACR,UAAU,8MAAA,CAAE,OAAA,CAAQ,UAAU;IAC9B,IAAI,8MAAA,CAAE,OAAA,CAAQ,mBAA2C;IACzD,UAAU,8MAAA,CAAE,MAAA;IACZ,MAAM,8MAAA,CAAE,MAAA;IACR,MAAM,8MAAA,CAAE,SAAA;AACT,CAAC;AA2BK,SAAS,WAAW,MAAA,EAA8C;IACxE,IAAI,CAAC,OAAQ,CAAA,OAAO;IACpB,OAAO,OAAO,QAAA,KAAa;AAC5B;AAeO,MAAM,uBAAmB,4LAAA,EAAmB,uBAAuB;IACzE,SAAS;IACT,SAAS;AACV,CAAU;AAqBH,MAAM,yBAAqB,uMAAA,EAA8B;IAC/D,YAAY;IACZ,YAAY;IACZ,UAAU;QACT;YACC,IAAI,iBAAiB,OAAA;YACrB,IAAI,CAAC,aAAa;;gBACf,SAAiB,IAAA,GAAO;YAC3B;YACA,MAAM,CAAC,aAAa;gBACnB,OAAQ,SAAiB,IAAA;YAC1B;QACD;QACA;YACC,IAAI,iBAAiB,OAAA;YACrB,IAAI,CAAC,WAAW;;gBACb,OAAe,IAAA,GAAO,CAAC;YAC1B;QACD;KACD;AACD,CAAC;AA4BM,MAAM,yBAAqB,6LAAA,EAA6B,YAAY;IAC1E,WAAW;IACX,OAAO;AACR,CAAC,EAAE,qBAAA,CACF,IAAA,CAA4C;QAC3C,UAAU;QACV,MAAM;QACN,MAAM,CAAC;IACR,CAAA;AA0BM,MAAM,gBAAsC,mBAAmB,QAAA,CAAS,UAAU","debugId":null}},
    {"offset": {"line": 2751, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/TLStore.ts"],"sourcesContent":["import { Signal } from '@tldraw/state'\nimport {\n\tSerializedStore,\n\tStore,\n\tStoreSchema,\n\tStoreSnapshot,\n\tStoreValidationFailure,\n} from '@tldraw/store'\nimport { IndexKey, JsonObject, annotateError, sortByIndex, structuredClone } from '@tldraw/utils'\nimport { TLAsset, TLAssetId } from './records/TLAsset'\nimport { CameraRecordType, TLCameraId } from './records/TLCamera'\nimport { DocumentRecordType, TLDOCUMENT_ID } from './records/TLDocument'\nimport { TLINSTANCE_ID } from './records/TLInstance'\nimport { PageRecordType, TLPageId } from './records/TLPage'\nimport { InstancePageStateRecordType, TLInstancePageStateId } from './records/TLPageState'\nimport { PointerRecordType, TLPOINTER_ID } from './records/TLPointer'\nimport { TLRecord } from './records/TLRecord'\n\n/**\n * Redacts the source of an asset record for error reporting.\n *\n * @param record - The asset record to redact\n * @returns The redacted record\n * @internal\n */\nexport function redactRecordForErrorReporting(record: any) {\n\tif (record.typeName === 'asset') {\n\t\tif ('src' in record) {\n\t\t\trecord.src = '<redacted>'\n\t\t}\n\n\t\tif ('src' in record.props) {\n\t\t\trecord.props.src = '<redacted>'\n\t\t}\n\t}\n}\n\n/**\n * The complete schema type for a tldraw store, defining the structure and validation rules\n * for all tldraw records and store properties.\n *\n * @public\n * @example\n * ```ts\n * import { createTLSchema } from '@tldraw/tlschema'\n *\n * const schema = createTLSchema()\n * const storeSchema: TLStoreSchema = schema\n * ```\n */\nexport type TLStoreSchema = StoreSchema<TLRecord, TLStoreProps>\n\n/**\n * A serialized representation of a tldraw store that can be persisted or transmitted.\n * Contains all store records in a JSON-serializable format.\n *\n * @public\n * @example\n * ```ts\n * // Serialize a store\n * const serializedStore: TLSerializedStore = store.serialize()\n *\n * // Save to localStorage\n * localStorage.setItem('drawing', JSON.stringify(serializedStore))\n * ```\n */\nexport type TLSerializedStore = SerializedStore<TLRecord>\n\n/**\n * A snapshot of a tldraw store at a specific point in time, containing all records\n * and metadata. Used for persistence, synchronization, and creating store backups.\n *\n * @public\n * @example\n * ```ts\n * // Create a snapshot\n * const snapshot: TLStoreSnapshot = store.getSnapshot()\n *\n * // Restore from snapshot\n * store.loadSnapshot(snapshot)\n * ```\n */\nexport type TLStoreSnapshot = StoreSnapshot<TLRecord>\n\n/**\n * Context information provided when resolving asset URLs, containing details about\n * the current rendering environment and user's connection to optimize asset delivery.\n *\n * @public\n * @example\n * ```ts\n * const assetStore: TLAssetStore = {\n *   async resolve(asset, context: TLAssetContext) {\n *     // Use low resolution for slow connections\n *     if (context.networkEffectiveType === 'slow-2g') {\n *       return `${asset.props.src}?quality=low`\n *     }\n *     // Use high DPI version for retina displays\n *     if (context.dpr > 1) {\n *       return `${asset.props.src}@2x`\n *     }\n *     return asset.props.src\n *   }\n * }\n * ```\n */\nexport interface TLAssetContext {\n\t/**\n\t * The scale at which the asset is being rendered on-screen relative to its native dimensions.\n\t * If the asset is 1000px wide, but it's been resized/zoom so it takes 500px on-screen, this\n\t * will be 0.5.\n\t *\n\t * The scale measures CSS pixels, not device pixels.\n\t */\n\tscreenScale: number\n\t/** The {@link TLAssetContext.screenScale}, stepped to the nearest power-of-2 multiple. */\n\tsteppedScreenScale: number\n\t/** The device pixel ratio - how many CSS pixels are in one device pixel? */\n\tdpr: number\n\t/**\n\t * An alias for\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType | `navigator.connection.effectiveType` }\n\t * if it's available in the current browser. Use this to e.g. serve lower-resolution images to\n\t * users on slow connections.\n\t */\n\tnetworkEffectiveType: string | null\n\t/**\n\t * In some circumstances, we need to resolve a URL that points to the original version of a\n\t * particular asset. This is used when the asset will leave the current tldraw instance - e.g.\n\t * for copy/paste, or exports.\n\t */\n\tshouldResolveToOriginal: boolean\n}\n\n/**\n * Interface for storing and managing assets (images, videos, etc.) in tldraw.\n * Provides methods for uploading, resolving, and removing assets from storage.\n *\n * A `TLAssetStore` sits alongside the main {@link TLStore} and is responsible for storing and\n * retrieving large assets such as images. Generally, this should be part of a wider sync system:\n *\n * - By default, the store is in-memory only, so `TLAssetStore` converts images to data URLs\n * - When using\n *   {@link @tldraw/editor#TldrawEditorWithoutStoreProps.persistenceKey | `persistenceKey`}, the\n *   store is synced to the browser's local IndexedDB, so `TLAssetStore` stores images there too\n * - When using a multiplayer sync server, you would implement `TLAssetStore` to upload images to\n *   e.g. an S3 bucket.\n *\n * @public\n * @example\n * ```ts\n * // Simple in-memory asset store\n * const assetStore: TLAssetStore = {\n *   async upload(asset, file) {\n *     const dataUrl = await fileToDataUrl(file)\n *     return { src: dataUrl }\n *   },\n *\n *   async resolve(asset, context) {\n *     return asset.props.src\n *   },\n *\n *   async remove(assetIds) {\n *     // Clean up if needed\n *   }\n * }\n * ```\n */\nexport interface TLAssetStore {\n\t/**\n\t * Upload an asset to your storage, returning a URL that can be used to refer to the asset\n\t * long-term.\n\t *\n\t * @param asset - Information & metadata about the asset being uploaded\n\t * @param file - The `File` to be uploaded\n\t * @returns A promise that resolves to the URL of the uploaded asset\n\t */\n\tupload(\n\t\tasset: TLAsset,\n\t\tfile: File,\n\t\tabortSignal?: AbortSignal\n\t): Promise<{ src: string; meta?: JsonObject }>\n\t/**\n\t * Resolve an asset to a URL. This is used when rendering the asset in the editor. By default,\n\t * this will just use `asset.props.src`, the URL returned by `upload()`. This can be used to\n\t * rewrite that URL to add access credentials, or optimized the asset for how it's currently\n\t * being displayed using the {@link TLAssetContext | information provided}.\n\t *\n\t * @param asset - the asset being resolved\n\t * @param ctx - information about the current environment and where the asset is being used\n\t * @returns The URL of the resolved asset, or `null` if the asset is not available\n\t */\n\tresolve?(asset: TLAsset, ctx: TLAssetContext): Promise<string | null> | string | null\n\t/**\n\t * Remove an asset from storage. This is called when the asset is no longer needed, e.g. when\n\t * the user deletes it from the editor.\n\t * @param asset - the asset being removed\n\t * @returns A promise that resolves when the asset has been removed\n\t */\n\tremove?(assetIds: TLAssetId[]): Promise<void>\n}\n\n/**\n * Configuration properties for a tldraw store, defining its behavior and integrations.\n * These props are passed when creating a new store instance.\n *\n * @public\n * @example\n * ```ts\n * const storeProps: TLStoreProps = {\n *   defaultName: 'My Drawing',\n *   assets: myAssetStore,\n *   onMount: (editor) => {\n *     console.log('Editor mounted')\n *     return () => console.log('Editor unmounted')\n *   },\n *   collaboration: {\n *     status: statusSignal,\n *     mode: modeSignal\n *   }\n * }\n *\n * const store = new Store({ schema, props: storeProps })\n * ```\n */\nexport interface TLStoreProps {\n\t/** Default name for new documents created in this store */\n\tdefaultName: string\n\t/** Asset store implementation for handling file uploads and storage */\n\tassets: Required<TLAssetStore>\n\t/**\n\t * Called when an {@link @tldraw/editor#Editor} connected to this store is mounted.\n\t * Can optionally return a cleanup function that will be called when unmounted.\n\t *\n\t * @param editor - The editor instance that was mounted\n\t * @returns Optional cleanup function\n\t */\n\tonMount(editor: unknown): void | (() => void)\n\t/** Optional collaboration configuration for multiplayer features */\n\tcollaboration?: {\n\t\t/** Signal indicating online/offline collaboration status */\n\t\tstatus: Signal<'online' | 'offline'> | null\n\t\t/** Signal indicating collaboration mode permissions */\n\t\tmode?: Signal<'readonly' | 'readwrite'> | null\n\t}\n}\n\n/**\n * The main tldraw store type, representing a reactive database of tldraw records\n * with associated store properties. This is the central data structure that holds\n * all shapes, assets, pages, and user state.\n *\n * @public\n * @example\n * ```ts\n * import { Store } from '@tldraw/store'\n * import { createTLSchema } from '@tldraw/tlschema'\n *\n * const schema = createTLSchema()\n * const store: TLStore = new Store({\n *   schema,\n *   props: {\n *     defaultName: 'Untitled',\n *     assets: myAssetStore,\n *     onMount: () => console.log('Store mounted')\n *   }\n * })\n * ```\n */\nexport type TLStore = Store<TLRecord, TLStoreProps>\n\n/**\n * Default validation failure handler for tldraw stores. This function is called\n * when a record fails validation during store operations. It annotates errors\n * with debugging information and determines whether to allow invalid records\n * during store initialization.\n *\n * @param options - The validation failure details\n *   - error - The validation error that occurred\n *   - phase - The store operation phase when validation failed\n *   - record - The invalid record that caused the failure\n *   - recordBefore - The previous state of the record (if applicable)\n * @returns The record to use (typically throws the annotated error)\n * @throws The original validation error with additional debugging context\n *\n * @public\n * @example\n * ```ts\n * const store = new Store({\n *   schema,\n *   props: storeProps,\n *   onValidationFailure // Use this as the validation failure handler\n * })\n *\n * // The handler will be called automatically when validation fails\n * try {\n *   store.put([invalidRecord])\n * } catch (error) {\n *   // Error will contain debugging information added by onValidationFailure\n * }\n * ```\n */\nexport function onValidationFailure({\n\terror,\n\tphase,\n\trecord,\n\trecordBefore,\n}: StoreValidationFailure<TLRecord>): TLRecord {\n\tconst isExistingValidationIssue =\n\t\t// if we're initializing the store for the first time, we should\n\t\t// allow invalid records so people can load old buggy data:\n\t\tphase === 'initialize'\n\n\tannotateError(error, {\n\t\ttags: {\n\t\t\torigin: 'store.validateRecord',\n\t\t\tstorePhase: phase,\n\t\t\tisExistingValidationIssue,\n\t\t},\n\t\textras: {\n\t\t\trecordBefore: recordBefore\n\t\t\t\t? redactRecordForErrorReporting(structuredClone(recordBefore))\n\t\t\t\t: undefined,\n\t\t\trecordAfter: redactRecordForErrorReporting(structuredClone(record)),\n\t\t},\n\t})\n\n\tthrow error\n}\n\nfunction getDefaultPages() {\n\treturn [\n\t\tPageRecordType.create({\n\t\t\tid: 'page:page' as TLPageId,\n\t\t\tname: 'Page 1',\n\t\t\tindex: 'a1' as IndexKey,\n\t\t\tmeta: {},\n\t\t}),\n\t]\n}\n\n/**\n * Creates an integrity checker function that ensures the tldraw store maintains\n * a consistent and usable state. The checker validates that required records exist\n * and relationships between records are maintained.\n *\n * The integrity checker ensures:\n * - Document and pointer records exist\n * - At least one page exists\n * - Instance state references valid pages\n * - Page states and cameras exist for all pages\n * - Shape references in page states are valid\n *\n * @param store - The tldraw store to check for integrity\n * @returns A function that when called, validates and fixes store integrity\n *\n * @internal\n * @example\n * ```ts\n * const checker = createIntegrityChecker(store)\n *\n * // Run integrity check (typically called automatically)\n * checker()\n *\n * // The checker will create missing records and fix invalid references\n * ```\n */\nexport function createIntegrityChecker(store: Store<TLRecord, TLStoreProps>): () => void {\n\tconst $pageIds = store.query.ids('page')\n\tconst $pageStates = store.query.records('instance_page_state')\n\n\tconst ensureStoreIsUsable = (): void => {\n\t\t// make sure we have exactly one document\n\t\tif (!store.has(TLDOCUMENT_ID)) {\n\t\t\tstore.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\tif (!store.has(TLPOINTER_ID)) {\n\t\t\tstore.put([PointerRecordType.create({ id: TLPOINTER_ID })])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\t// make sure there is at least one page\n\t\tconst pageIds = $pageIds.get()\n\t\tif (pageIds.size === 0) {\n\t\t\tstore.put(getDefaultPages())\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\tconst getFirstPageId = () => [...pageIds].map((id) => store.get(id)!).sort(sortByIndex)[0].id!\n\n\t\t// make sure we have state for the current user's current tab\n\t\tconst instanceState = store.get(TLINSTANCE_ID)\n\t\tif (!instanceState) {\n\t\t\tstore.put([\n\t\t\t\tstore.schema.types.instance.create({\n\t\t\t\t\tid: TLINSTANCE_ID,\n\t\t\t\t\tcurrentPageId: getFirstPageId(),\n\t\t\t\t\texportBackground: true,\n\t\t\t\t}),\n\t\t\t])\n\n\t\t\treturn ensureStoreIsUsable()\n\t\t} else if (!pageIds.has(instanceState.currentPageId)) {\n\t\t\tstore.put([{ ...instanceState, currentPageId: getFirstPageId() }])\n\t\t\treturn ensureStoreIsUsable()\n\t\t}\n\n\t\t// make sure we have page states and cameras for all the pages\n\t\tconst missingPageStateIds = new Set<TLInstancePageStateId>()\n\t\tconst missingCameraIds = new Set<TLCameraId>()\n\t\tfor (const id of pageIds) {\n\t\t\tconst pageStateId = InstancePageStateRecordType.createId(id)\n\t\t\tconst pageState = store.get(pageStateId)\n\t\t\tif (!pageState) {\n\t\t\t\tmissingPageStateIds.add(pageStateId)\n\t\t\t}\n\t\t\tconst cameraId = CameraRecordType.createId(id)\n\t\t\tif (!store.has(cameraId)) {\n\t\t\t\tmissingCameraIds.add(cameraId)\n\t\t\t}\n\t\t}\n\n\t\tif (missingPageStateIds.size > 0) {\n\t\t\tstore.put(\n\t\t\t\t[...missingPageStateIds].map((id) =>\n\t\t\t\t\tInstancePageStateRecordType.create({\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tpageId: InstancePageStateRecordType.parseId(id) as TLPageId,\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tif (missingCameraIds.size > 0) {\n\t\t\tstore.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })))\n\t\t}\n\n\t\tconst pageStates = $pageStates.get()\n\t\tfor (const pageState of pageStates) {\n\t\t\tif (!pageIds.has(pageState.pageId)) {\n\t\t\t\tstore.remove([pageState.id])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {\n\t\t\t\tstore.put([{ ...pageState, croppingShapeId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tif (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {\n\t\t\t\tstore.put([{ ...pageState, focusedGroupId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tif (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {\n\t\t\t\tstore.put([{ ...pageState, hoveredShapeId: null }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredHintingIds.length !== pageState.hintingShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, hintingShapeIds: filteredHintingIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t\tconst filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id))\n\t\t\tif (filteredErasingIds.length !== pageState.erasingShapeIds.length) {\n\t\t\t\tstore.put([{ ...pageState, erasingShapeIds: filteredErasingIds }])\n\t\t\t\treturn ensureStoreIsUsable()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ensureStoreIsUsable\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2962, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/assets/TLBookmarkAsset.ts"],"sourcesContent":["import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset used for URL bookmarks, used by the TLBookmarkShape.\n *\n *  @public */\nexport type TLBookmarkAsset = TLBaseAsset<\n\t'bookmark',\n\t{\n\t\ttitle: string\n\t\tdescription: string\n\t\timage: string\n\t\tfavicon: string\n\t\tsrc: string | null\n\t}\n>\n\n/**\n * Validator for TLBookmarkAsset records. Validates the structure and data types\n * of bookmark asset properties including title, description, image, favicon, and source URL.\n *\n * @example\n * ```ts\n * const bookmarkData = {\n *   id: 'asset:bookmark1',\n *   typeName: 'asset',\n *   type: 'bookmark',\n *   props: {\n *     title: 'Example Website',\n *     description: 'A great example site',\n *     image: 'https://example.com/preview.jpg',\n *     favicon: 'https://example.com/favicon.ico',\n *     src: 'https://example.com'\n *   }\n * }\n *\n * const isValid = bookmarkAssetValidator.isValid(bookmarkData)\n * ```\n *\n * @public\n */\nexport const bookmarkAssetValidator: T.Validator<TLBookmarkAsset> = createAssetValidator(\n\t'bookmark',\n\tT.object({\n\t\ttitle: T.string,\n\t\tdescription: T.string,\n\t\timage: T.string,\n\t\tfavicon: T.string,\n\t\tsrc: T.srcUrl.nullable(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.bookmark', {\n\tMakeUrlsValid: 1,\n\tAddFavicon: 2,\n} as const)\n\n/**\n * Migration version identifiers for bookmark assets. These versions track\n * the evolution of the bookmark asset schema over time.\n *\n * Available versions:\n * - `MakeUrlsValid` (v1): Ensures src URLs are valid or empty\n * - `AddFavicon` (v2): Adds favicon property to bookmark assets\n *\n * @example\n * ```ts\n * import { bookmarkAssetVersions } from '@tldraw/tlschema'\n *\n * // Check if a migration exists\n * console.log(bookmarkAssetVersions.AddFavicon) // 2\n * ```\n *\n * @public\n */\nexport { Versions as bookmarkAssetVersions }\n\n/**\n * Migration sequence for bookmark assets. Handles the evolution of bookmark asset\n * data structure over time, ensuring backward and forward compatibility.\n *\n * The migration sequence includes:\n * 1. **MakeUrlsValid** (v1): Validates and cleans up src URLs, setting invalid URLs to empty string\n * 2. **AddFavicon** (v2): Adds the favicon property and validates it, setting invalid favicons to empty string\n *\n * @public\n */\nexport const bookmarkAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.bookmark',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'bookmark',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFavicon,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.favicon)) {\n\t\t\t\t\tasset.props.favicon = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.favicon\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,oBAAoB,qCAAqC;;AAClE,SAAS,SAAS;AAElB,SAAsB,4BAA4B;;;;AAyC3C,MAAM,6BAAuD,wMAAA,EACnE,YACA,8MAAA,CAAE,MAAA,CAAO;IACR,OAAO,8MAAA,CAAE,MAAA;IACT,aAAa,8MAAA,CAAE,MAAA;IACf,OAAO,8MAAA,CAAE,MAAA;IACT,SAAS,8MAAA,CAAE,MAAA;IACX,KAAK,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;AACxB,CAAC;AAGF,MAAM,eAAW,4LAAA,EAAmB,6BAA6B;IAChE,eAAe;IACf,YAAY;AACb,CAAU;AAgCH,MAAM,8BAA0B,uMAAA,EAA8B;IACpE,YAAY;IACZ,YAAY;IACZ,QAAQ,CAAC,QAAW,MAAkB,IAAA,KAAS;IAC/C,UAAU;QACT;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,CAAC,8MAAA,CAAE,MAAA,CAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,GAAG,GAAG;oBACvC,MAAM,KAAA,CAAM,GAAA,GAAM;gBACnB;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,CAAC,8MAAA,CAAE,MAAA,CAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,OAAO,GAAG;oBAC3C,MAAM,KAAA,CAAM,OAAA,GAAU;gBACvB;YACD;YACA,MAAM,CAAC,UAAe;gBACrB,OAAO,MAAM,KAAA,CAAM,OAAA;YACpB;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3022, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/assets/TLImageAsset.ts"],"sourcesContent":["import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset for images such as PNGs and JPEGs, used by the TLImageShape.\n *\n * @public */\nexport type TLImageAsset = TLBaseAsset<\n\t'image',\n\t{\n\t\tw: number\n\t\th: number\n\t\tname: string\n\t\tisAnimated: boolean\n\t\tmimeType: string | null\n\t\tsrc: string | null\n\t\tfileSize?: number\n\t}\n>\n\n/**\n * Validator for image assets. Validates the structure and properties of TLImageAsset records\n * to ensure data integrity when image assets are stored or retrieved from the tldraw store.\n *\n * @example\n * ```ts\n * import { imageAssetValidator } from '@tldraw/tlschema'\n *\n * const imageAsset = {\n *   id: 'asset:image123',\n *   typeName: 'asset',\n *   type: 'image',\n *   props: {\n *     w: 800,\n *     h: 600,\n *     name: 'photo.jpg',\n *     isAnimated: false,\n *     mimeType: 'image/jpeg',\n *     src: 'https://example.com/photo.jpg',\n *     fileSize: 156000\n *   },\n *   meta: {}\n * }\n *\n * // Validate the asset\n * const isValid = imageAssetValidator.validate(imageAsset)\n * ```\n *\n * @public\n */\nexport const imageAssetValidator: T.Validator<TLImageAsset> = createAssetValidator(\n\t'image',\n\tT.object({\n\t\tw: T.number,\n\t\th: T.number,\n\t\tname: T.string,\n\t\tisAnimated: T.boolean,\n\t\tmimeType: T.string.nullable(),\n\t\tsrc: T.srcUrl.nullable(),\n\t\tfileSize: T.nonZeroNumber.optional(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.image', {\n\tAddIsAnimated: 1,\n\tRenameWidthHeight: 2,\n\tMakeUrlsValid: 3,\n\tAddFileSize: 4,\n\tMakeFileSizeOptional: 5,\n} as const)\n\n/**\n * Migration version identifiers for image assets. These define the different schema versions\n * that image assets have gone through during the evolution of the tldraw data model.\n *\n * @example\n * ```ts\n * import { imageAssetVersions } from '@tldraw/tlschema'\n *\n * // Access specific version IDs\n * console.log(imageAssetVersions.AddIsAnimated) // Version when isAnimated was added\n * console.log(imageAssetVersions.RenameWidthHeight) // Version when width/height became w/h\n * ```\n *\n * @public\n */\nexport { Versions as imageAssetVersions }\n\n/**\n * Migration sequence for image assets. Handles the evolution of the image asset schema\n * over time, providing both forward (up) and backward (down) migration functions to\n * maintain compatibility across different versions of the tldraw data model.\n *\n * The sequence includes migrations for:\n * - Adding the `isAnimated` property to track animated images\n * - Renaming `width`/`height` properties to shorter `w`/`h` names\n * - Ensuring URLs are valid format\n * - Adding file size tracking\n * - Making file size optional\n *\n *\n * @public\n */\nexport const imageAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.image',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'image',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddIsAnimated,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.isAnimated = false\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.isAnimated\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.RenameWidthHeight,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.w = asset.props.width\n\t\t\t\tasset.props.h = asset.props.height\n\t\t\t\tdelete asset.props.width\n\t\t\t\tdelete asset.props.height\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tasset.props.width = asset.props.w\n\t\t\t\tasset.props.height = asset.props.h\n\t\t\t\tdelete asset.props.w\n\t\t\t\tdelete asset.props.h\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFileSize,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.fileSize = -1\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.fileSize\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeFileSizeOptional,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === -1) {\n\t\t\t\t\tasset.props.fileSize = undefined\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === undefined) {\n\t\t\t\t\tasset.props.fileSize = -1\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,oBAAoB,qCAAqC;;AAClE,SAAS,SAAS;AAElB,SAAsB,4BAA4B;;;;AAiD3C,MAAM,0BAAiD,wMAAA,EAC7D,SACA,8MAAA,CAAE,MAAA,CAAO;IACR,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,MAAM,8MAAA,CAAE,MAAA;IACR,YAAY,8MAAA,CAAE,OAAA;IACd,UAAU,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;IAC5B,KAAK,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;IACvB,UAAU,8MAAA,CAAE,aAAA,CAAc,QAAA,CAAS;AACpC,CAAC;AAGF,MAAM,eAAW,4LAAA,EAAmB,0BAA0B;IAC7D,eAAe;IACf,mBAAmB;IACnB,eAAe;IACf,aAAa;IACb,sBAAsB;AACvB,CAAU;AAkCH,MAAM,2BAAuB,uMAAA,EAA8B;IACjE,YAAY;IACZ,YAAY;IACZ,QAAQ,CAAC,QAAW,MAAkB,IAAA,KAAS;IAC/C,UAAU;QACT;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,UAAA,GAAa;YAC1B;YACA,MAAM,CAAC,UAAe;gBACrB,OAAO,MAAM,KAAA,CAAM,UAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,iBAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,KAAA;gBAC5B,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,MAAA;gBAC5B,OAAO,MAAM,KAAA,CAAM,KAAA;gBACnB,OAAO,MAAM,KAAA,CAAM,MAAA;YACpB;YACA,MAAM,CAAC,UAAe;gBACrB,MAAM,KAAA,CAAM,KAAA,GAAQ,MAAM,KAAA,CAAM,CAAA;gBAChC,MAAM,KAAA,CAAM,MAAA,GAAS,MAAM,KAAA,CAAM,CAAA;gBACjC,OAAO,MAAM,KAAA,CAAM,CAAA;gBACnB,OAAO,MAAM,KAAA,CAAM,CAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,CAAC,8MAAA,CAAE,MAAA,CAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,GAAG,GAAG;oBACvC,MAAM,KAAA,CAAM,GAAA,GAAM;gBACnB;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,QAAA,GAAW,CAAA;YACxB;YACA,MAAM,CAAC,UAAe;gBACrB,OAAO,MAAM,KAAA,CAAM,QAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,oBAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,MAAM,KAAA,CAAM,QAAA,KAAa,CAAA,GAAI;oBAChC,MAAM,KAAA,CAAM,QAAA,GAAW,KAAA;gBACxB;YACD;YACA,MAAM,CAAC,UAAe;gBACrB,IAAI,MAAM,KAAA,CAAM,QAAA,KAAa,KAAA,GAAW;oBACvC,MAAM,KAAA,CAAM,QAAA,GAAW,CAAA;gBACxB;YACD;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3122, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/assets/TLVideoAsset.ts"],"sourcesContent":["import { createMigrationIds, createRecordMigrationSequence } from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLAsset } from '../records/TLAsset'\nimport { TLBaseAsset, createAssetValidator } from './TLBaseAsset'\n\n/**\n * An asset record representing video files that can be displayed in video shapes.\n * Video assets store metadata about video files including dimensions, MIME type,\n * animation status, and file source information. They are referenced by TLVideoShape\n * instances to display video content on the canvas.\n *\n * @example\n * ```ts\n * import { TLVideoAsset } from '@tldraw/tlschema'\n *\n * const videoAsset: TLVideoAsset = {\n *   id: 'asset:video123',\n *   typeName: 'asset',\n *   type: 'video',\n *   props: {\n *     w: 1920,\n *     h: 1080,\n *     name: 'my-video.mp4',\n *     isAnimated: true,\n *     mimeType: 'video/mp4',\n *     src: 'https://example.com/video.mp4',\n *     fileSize: 5242880\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLVideoAsset = TLBaseAsset<\n\t'video',\n\t{\n\t\t/** The width of the video in pixels */\n\t\tw: number\n\t\t/** The height of the video in pixels */\n\t\th: number\n\t\t/** The original filename or display name of the video */\n\t\tname: string\n\t\t/** Whether the video contains animation/motion (true for most videos) */\n\t\tisAnimated: boolean\n\t\t/** The MIME type of the video file (e.g., 'video/mp4', 'video/webm'), null if unknown */\n\t\tmimeType: string | null\n\t\t/** The source URL or data URI for the video file, null if not yet available */\n\t\tsrc: string | null\n\t\t/** The file size in bytes, optional for backward compatibility */\n\t\tfileSize?: number\n\t}\n>\n\n/**\n * Runtime validator for TLVideoAsset records. This validator ensures that video asset\n * data conforms to the expected structure and types, providing type safety at runtime.\n * It validates dimensions, file metadata, and ensures URLs are properly formatted.\n *\n * @example\n * ```ts\n * import { videoAssetValidator } from '@tldraw/tlschema'\n *\n * // Validate a video asset object\n * const validAsset = videoAssetValidator.validate({\n *   id: 'asset:video123',\n *   typeName: 'asset',\n *   type: 'video',\n *   props: {\n *     w: 1920,\n *     h: 1080,\n *     name: 'video.mp4',\n *     isAnimated: true,\n *     mimeType: 'video/mp4',\n *     src: 'https://example.com/video.mp4',\n *     fileSize: 1024000\n *   },\n *   meta: {}\n * })\n * ```\n *\n * @public\n */\nexport const videoAssetValidator: T.Validator<TLVideoAsset> = createAssetValidator(\n\t'video',\n\tT.object({\n\t\tw: T.number,\n\t\th: T.number,\n\t\tname: T.string,\n\t\tisAnimated: T.boolean,\n\t\tmimeType: T.string.nullable(),\n\t\tsrc: T.srcUrl.nullable(),\n\t\tfileSize: T.number.optional(),\n\t})\n)\n\nconst Versions = createMigrationIds('com.tldraw.asset.video', {\n\tAddIsAnimated: 1,\n\tRenameWidthHeight: 2,\n\tMakeUrlsValid: 3,\n\tAddFileSize: 4,\n\tMakeFileSizeOptional: 5,\n} as const)\n\n/**\n * Version identifiers for video asset migration sequences. These versions track\n * the evolution of the video asset schema over time, enabling proper data migration\n * when the asset structure changes.\n *\n * @example\n * ```ts\n * import { videoAssetVersions } from '@tldraw/tlschema'\n *\n * // Check the current version of a specific migration\n * console.log(videoAssetVersions.AddFileSize) // 4\n * ```\n *\n * @public\n */\nexport { Versions as videoAssetVersions }\n\n/**\n * Migration sequence for video assets that handles schema evolution over time.\n * This sequence defines how video asset data should be transformed when upgrading\n * or downgrading between different schema versions. Each migration step handles\n * specific changes like adding properties, renaming fields, or changing data formats.\n *\n * The migrations handle:\n * - Adding animation detection (isAnimated property)\n * - Renaming width/height properties to w/h for consistency\n * - Ensuring URL validity for src properties\n * - Adding file size tracking\n * - Making file size optional for backward compatibility\n *\n * @public\n */\nexport const videoAssetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset.video',\n\trecordType: 'asset',\n\tfilter: (asset) => (asset as TLAsset).type === 'video',\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddIsAnimated,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.isAnimated = false\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.isAnimated\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.RenameWidthHeight,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.w = asset.props.width\n\t\t\t\tasset.props.h = asset.props.height\n\t\t\t\tdelete asset.props.width\n\t\t\t\tdelete asset.props.height\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tasset.props.width = asset.props.w\n\t\t\t\tasset.props.height = asset.props.h\n\t\t\t\tdelete asset.props.w\n\t\t\t\tdelete asset.props.h\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (!T.srcUrl.isValid(asset.props.src)) {\n\t\t\t\t\tasset.props.src = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_asset) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFileSize,\n\t\t\tup: (asset: any) => {\n\t\t\t\tasset.props.fileSize = -1\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tdelete asset.props.fileSize\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeFileSizeOptional,\n\t\t\tup: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === -1) {\n\t\t\t\t\tasset.props.fileSize = undefined\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (asset: any) => {\n\t\t\t\tif (asset.props.fileSize === undefined) {\n\t\t\t\t\tasset.props.fileSize = -1\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,oBAAoB,qCAAqC;;AAClE,SAAS,SAAS;AAElB,SAAsB,4BAA4B;;;;AAgF3C,MAAM,0BAAiD,wMAAA,EAC7D,SACA,8MAAA,CAAE,MAAA,CAAO;IACR,GAAG,8MAAA,CAAE,MAAA;IACL,GAAG,8MAAA,CAAE,MAAA;IACL,MAAM,8MAAA,CAAE,MAAA;IACR,YAAY,8MAAA,CAAE,OAAA;IACd,UAAU,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;IAC5B,KAAK,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;IACvB,UAAU,8MAAA,CAAE,MAAA,CAAO,QAAA,CAAS;AAC7B,CAAC;AAGF,MAAM,eAAW,4LAAA,EAAmB,0BAA0B;IAC7D,eAAe;IACf,mBAAmB;IACnB,eAAe;IACf,aAAa;IACb,sBAAsB;AACvB,CAAU;AAkCH,MAAM,2BAAuB,uMAAA,EAA8B;IACjE,YAAY;IACZ,YAAY;IACZ,QAAQ,CAAC,QAAW,MAAkB,IAAA,KAAS;IAC/C,UAAU;QACT;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,UAAA,GAAa;YAC1B;YACA,MAAM,CAAC,UAAe;gBACrB,OAAO,MAAM,KAAA,CAAM,UAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,iBAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,KAAA;gBAC5B,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,MAAA;gBAC5B,OAAO,MAAM,KAAA,CAAM,KAAA;gBACnB,OAAO,MAAM,KAAA,CAAM,MAAA;YACpB;YACA,MAAM,CAAC,UAAe;gBACrB,MAAM,KAAA,CAAM,KAAA,GAAQ,MAAM,KAAA,CAAM,CAAA;gBAChC,MAAM,KAAA,CAAM,MAAA,GAAS,MAAM,KAAA,CAAM,CAAA;gBACjC,OAAO,MAAM,KAAA,CAAM,CAAA;gBACnB,OAAO,MAAM,KAAA,CAAM,CAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,CAAC,8MAAA,CAAE,MAAA,CAAO,OAAA,CAAQ,MAAM,KAAA,CAAM,GAAG,GAAG;oBACvC,MAAM,KAAA,CAAM,GAAA,GAAM;gBACnB;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAe;gBACnB,MAAM,KAAA,CAAM,QAAA,GAAW,CAAA;YACxB;YACA,MAAM,CAAC,UAAe;gBACrB,OAAO,MAAM,KAAA,CAAM,QAAA;YACpB;QACD;QACA;YACC,IAAI,SAAS,oBAAA;YACb,IAAI,CAAC,UAAe;gBACnB,IAAI,MAAM,KAAA,CAAM,QAAA,KAAa,CAAA,GAAI;oBAChC,MAAM,KAAA,CAAM,QAAA,GAAW,KAAA;gBACxB;YACD;YACA,MAAM,CAAC,UAAe;gBACrB,IAAI,MAAM,KAAA,CAAM,QAAA,KAAa,KAAA,GAAW;oBACvC,MAAM,KAAA,CAAM,QAAA,GAAW,CAAA;gBACxB;YACD;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3222, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/records/TLAsset.ts"],"sourcesContent":["import {\n\tcreateMigrationIds,\n\tcreateRecordMigrationSequence,\n\tcreateRecordType,\n\tRecordId,\n} from '@tldraw/store'\nimport { T } from '@tldraw/validate'\nimport { TLBaseAsset } from '../assets/TLBaseAsset'\nimport { bookmarkAssetValidator, TLBookmarkAsset } from '../assets/TLBookmarkAsset'\nimport { imageAssetValidator, TLImageAsset } from '../assets/TLImageAsset'\nimport { TLVideoAsset, videoAssetValidator } from '../assets/TLVideoAsset'\nimport { TLShape } from './TLShape'\n\n/**\n * Union type representing all possible asset types in tldraw.\n * Assets represent external resources like images, videos, or bookmarks that can be referenced by shapes.\n *\n * @example\n * ```ts\n * const imageAsset: TLAsset = {\n *   id: 'asset:image123',\n *   typeName: 'asset',\n *   type: 'image',\n *   props: {\n *     src: 'https://example.com/image.jpg',\n *     w: 800,\n *     h: 600,\n *     mimeType: 'image/jpeg',\n *     isAnimated: false\n *   },\n *   meta: {}\n * }\n * ```\n *\n * @public\n */\nexport type TLAsset = TLImageAsset | TLVideoAsset | TLBookmarkAsset\n\n/**\n * Validator for TLAsset records that ensures runtime type safety.\n * Uses a discriminated union based on the 'type' field to validate different asset types.\n *\n * @example\n * ```ts\n * // Validation happens automatically when assets are stored\n * try {\n *   const validatedAsset = assetValidator.validate(assetData)\n *   store.put([validatedAsset])\n * } catch (error) {\n *   console.error('Asset validation failed:', error.message)\n * }\n * ```\n *\n * @public\n */\nexport const assetValidator: T.Validator<TLAsset> = T.model(\n\t'asset',\n\tT.union('type', {\n\t\timage: imageAssetValidator,\n\t\tvideo: videoAssetValidator,\n\t\tbookmark: bookmarkAssetValidator,\n\t})\n)\n\n/**\n * Migration version identifiers for asset record schema evolution.\n * Each version represents a breaking change that requires data migration.\n *\n * @example\n * ```ts\n * // Check if a migration is needed\n * const needsMigration = currentVersion < assetVersions.AddMeta\n * ```\n *\n * @public\n */\nexport const assetVersions = createMigrationIds('com.tldraw.asset', {\n\tAddMeta: 1,\n} as const)\n\n/**\n * Migration sequence for evolving asset record structure over time.\n * Handles converting asset records from older schema versions to current format.\n *\n * @example\n * ```ts\n * // Migration is applied automatically when loading old documents\n * const migratedStore = migrator.migrateStoreSnapshot({\n *   schema: oldSchema,\n *   store: oldStoreSnapshot\n * })\n * ```\n *\n * @public\n */\nexport const assetMigrations = createRecordMigrationSequence({\n\tsequenceId: 'com.tldraw.asset',\n\trecordType: 'asset',\n\tsequence: [\n\t\t{\n\t\t\tid: assetVersions.AddMeta,\n\t\t\tup: (record) => {\n\t\t\t\t;(record as any).meta = {}\n\t\t\t},\n\t\t},\n\t],\n})\n\n/**\n * Partial type for TLAsset allowing optional properties except id and type.\n * Useful for creating or updating assets where not all properties need to be specified.\n *\n * @example\n * ```ts\n * // Create a partial asset for updating\n * const partialAsset: TLAssetPartial<TLImageAsset> = {\n *   id: 'asset:image123',\n *   type: 'image',\n *   props: {\n *     w: 800 // Only updating width\n *   }\n * }\n *\n * // Use in asset updates\n * editor.updateAssets([partialAsset])\n * ```\n *\n * @public\n */\nexport type TLAssetPartial<T extends TLAsset = TLAsset> = T extends T\n\t? {\n\t\t\tid: TLAssetId\n\t\t\ttype: T['type']\n\t\t\tprops?: Partial<T['props']>\n\t\t\tmeta?: Partial<T['meta']>\n\t\t} & Partial<Omit<T, 'type' | 'id' | 'props' | 'meta'>>\n\t: never\n\n/**\n * Record type definition for TLAsset with validation and default properties.\n * Configures assets as document-scoped records that persist across sessions.\n *\n * @example\n * ```ts\n * // Create a new asset record\n * const assetRecord = AssetRecordType.create({\n *   id: 'asset:image123',\n *   type: 'image',\n *   props: {\n *     src: 'https://example.com/image.jpg',\n *     w: 800,\n *     h: 600,\n *     mimeType: 'image/jpeg',\n *     isAnimated: false\n *   }\n * })\n *\n * // Store the asset\n * store.put([assetRecord])\n * ```\n *\n * @public\n */\nexport const AssetRecordType = createRecordType<TLAsset>('asset', {\n\tvalidator: assetValidator,\n\tscope: 'document',\n}).withDefaultProperties(() => ({\n\tmeta: {},\n}))\n\n/**\n * Branded string type for asset record identifiers.\n * Prevents mixing asset IDs with other types of record IDs at compile time.\n *\n * @example\n * ```ts\n * import { createAssetId } from '@tldraw/tlschema'\n *\n * // Create a new asset ID\n * const assetId: TLAssetId = createAssetId()\n *\n * // Use in asset records\n * const asset: TLAsset = {\n *   id: assetId,\n *   // ... other properties\n * }\n *\n * // Reference in shapes\n * const imageShape: TLImageShape = {\n *   props: {\n *     assetId: assetId,\n *     // ... other properties\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type TLAssetId = RecordId<TLBaseAsset<any, any>>\n\n/**\n * Union type of all shapes that reference assets through an assetId property.\n * Includes image shapes, video shapes, and any other shapes that depend on external assets.\n *\n * @example\n * ```ts\n * // Function that works with any asset-based shape\n * function handleAssetShape(shape: TLAssetShape) {\n *   const assetId = shape.props.assetId\n *   if (assetId) {\n *     const asset = editor.getAsset(assetId)\n *     // Handle the asset...\n *   }\n * }\n *\n * // Use with image or video shapes\n * const imageShape: TLImageShape = { props: { assetId: 'asset:img1' } }\n * const videoShape: TLVideoShape = { props: { assetId: 'asset:vid1' } }\n * handleAssetShape(imageShape) // Works\n * handleAssetShape(videoShape) // Works\n * ```\n *\n * @public\n */\nexport type TLAssetShape = Extract<TLShape, { props: { assetId: TLAssetId } }>\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAMA,SAAS,SAAS;AAElB,SAAS,8BAA+C;AACxD,SAAS,2BAAyC;AAClD,SAAuB,2BAA2B;;;;;;AA6C3C,MAAM,iBAAuC,8MAAA,CAAE,KAAA,CACrD,SACA,8MAAA,CAAE,KAAA,CAAM,QAAQ;IACf,OAAO,wMAAA;IACP,OAAO,wMAAA;IACP,UAAU,8MAAA;AACX,CAAC;AAeK,MAAM,oBAAgB,4LAAA,EAAmB,oBAAoB;IACnE,SAAS;AACV,CAAU;AAiBH,MAAM,sBAAkB,uMAAA,EAA8B;IAC5D,YAAY;IACZ,YAAY;IACZ,UAAU;QACT;YACC,IAAI,cAAc,OAAA;YAClB,IAAI,CAAC,WAAW;;gBACb,OAAe,IAAA,GAAO,CAAC;YAC1B;QACD;KACD;AACD,CAAC;AAyDM,MAAM,sBAAkB,6LAAA,EAA0B,SAAS;IACjE,WAAW;IACX,OAAO;AACR,CAAC,EAAE,qBAAA,CAAsB,IAAA,CAAO;QAC/B,MAAM,CAAC;IACR,CAAA,CAAE","debugId":null}},
    {"offset": {"line": 3278, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLBookmarkShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Properties for the bookmark shape, which displays website bookmarks as interactive cards.\n *\n * @public\n */\nexport interface TLBookmarkShapeProps {\n\t/** Width of the bookmark shape in pixels */\n\tw: number\n\t/** Height of the bookmark shape in pixels */\n\th: number\n\t/** Asset ID for the bookmark's preview image, or null if no image is available */\n\tassetId: TLAssetId | null\n\t/** The URL that this bookmark points to */\n\turl: string\n}\n\n/**\n * A bookmark shape represents a website link with optional preview content.\n * Bookmark shapes display as cards showing the page title, description, and preview image.\n *\n * @public\n * @example\n * ```ts\n * const bookmarkShape: TLBookmarkShape = {\n *   id: createShapeId(),\n *   typeName: 'shape',\n *   type: 'bookmark',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:page1',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     w: 300,\n *     h: 320,\n *     assetId: 'asset:bookmark123',\n *     url: 'https://www.example.com'\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLBookmarkShape = TLBaseShape<'bookmark', TLBookmarkShapeProps>\n\n/**\n * Validation schema for bookmark shape properties.\n *\n * @public\n * @example\n * ```ts\n * // Validates bookmark shape properties\n * const isValid = bookmarkShapeProps.url.isValid('https://example.com')\n * ```\n */\nexport const bookmarkShapeProps: RecordProps<TLBookmarkShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tassetId: assetIdValidator.nullable(),\n\turl: T.linkUrl,\n}\n\nconst Versions = createShapePropsMigrationIds('bookmark', {\n\tNullAssetId: 1,\n\tMakeUrlsValid: 2,\n})\n\n/**\n * Version identifiers for bookmark shape migrations.\n *\n * @public\n */\nexport { Versions as bookmarkShapeVersions }\n\n/**\n * Migration sequence for bookmark shape properties across different schema versions.\n * Handles backwards compatibility when bookmark shape structure changes.\n *\n * @public\n */\nexport const bookmarkShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.NullAssetId,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.assetId === undefined) {\n\t\t\t\t\tprops.assetId = null\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAS,wBAAwB;AAEjC,SAAS,8BAA8B,yCAAyC;;;;AA4DzE,MAAM,qBAAmD;IAC/D,GAAG,8MAAA,CAAE,aAAA;IACL,GAAG,8MAAA,CAAE,aAAA;IACL,SAAS,oMAAA,CAAiB,QAAA,CAAS;IACnC,KAAK,8MAAA,CAAE,OAAA;AACR;AAEA,MAAM,eAAW,6MAAA,EAA6B,YAAY;IACzD,aAAa;IACb,eAAe;AAChB,CAAC;AAeM,MAAM,8BAA0B,kNAAA,EAAkC;IACxE,UAAU;QACT;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,MAAM,OAAA,KAAY,KAAA,GAAW;oBAChC,MAAM,OAAA,GAAU;gBACjB;YACD;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,CAAC,8MAAA,CAAE,OAAA,CAAQ,OAAA,CAAQ,MAAM,GAAG,GAAG;oBAClC,MAAM,GAAA,GAAM;gBACb;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3331, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLDrawShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { VecModel, vecModelValidator } from '../misc/geometry-types'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * A segment of a draw shape representing either freehand drawing or straight line segments.\n *\n * @public\n */\nexport interface TLDrawShapeSegment {\n\t/** Type of drawing segment - 'free' for freehand curves, 'straight' for line segments */\n\ttype: 'free' | 'straight'\n\t/** Array of points defining the segment path with x, y coordinates and pressure (z) */\n\tpoints: VecModel[]\n}\n\n/**\n * Validator for draw shape segments ensuring proper structure and data types.\n *\n * @public\n * @example\n * ```ts\n * const segment: TLDrawShapeSegment = {\n *   type: 'free',\n *   points: [{ x: 0, y: 0, z: 0.5 }, { x: 10, y: 10, z: 0.7 }]\n * }\n * const isValid = DrawShapeSegment.isValid(segment)\n * ```\n */\nexport const DrawShapeSegment: T.ObjectValidator<TLDrawShapeSegment> = T.object({\n\ttype: T.literalEnum('free', 'straight'),\n\tpoints: T.arrayOf(vecModelValidator),\n})\n\n/**\n * Properties for the draw shape, which represents freehand drawing and sketching.\n *\n * @public\n */\nexport interface TLDrawShapeProps {\n\t/** Color style for the drawing stroke */\n\tcolor: TLDefaultColorStyle\n\t/** Fill style for closed drawing shapes */\n\tfill: TLDefaultFillStyle\n\t/** Dash pattern style for the stroke */\n\tdash: TLDefaultDashStyle\n\t/** Size/thickness of the drawing stroke */\n\tsize: TLDefaultSizeStyle\n\t/** Array of segments that make up the complete drawing path */\n\tsegments: TLDrawShapeSegment[]\n\t/** Whether the drawing is complete (user finished drawing) */\n\tisComplete: boolean\n\t/** Whether the drawing path forms a closed shape */\n\tisClosed: boolean\n\t/** Whether this drawing was created with a pen/stylus device */\n\tisPen: boolean\n\t/** Scale factor applied to the drawing */\n\tscale: number\n}\n\n/**\n * A draw shape represents freehand drawing, sketching, and pen input on the canvas.\n * Draw shapes are composed of segments that can be either smooth curves or straight lines.\n *\n * @public\n * @example\n * ```ts\n * const drawShape: TLDrawShape = {\n *   id: createShapeId(),\n *   typeName: 'shape',\n *   type: 'draw',\n *   x: 50,\n *   y: 50,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:page1',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     color: 'black',\n *     fill: 'none',\n *     dash: 'solid',\n *     size: 'm',\n *     segments: [{\n *       type: 'free',\n *       points: [{ x: 0, y: 0, z: 0.5 }, { x: 20, y: 15, z: 0.6 }]\n *     }],\n *     isComplete: true,\n *     isClosed: false,\n *     isPen: false,\n *     scale: 1\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLDrawShape = TLBaseShape<'draw', TLDrawShapeProps>\n\n/**\n * Validation schema for draw shape properties.\n *\n * @public\n * @example\n * ```ts\n * // Validate draw shape properties\n * const props = {\n *   color: 'red',\n *   fill: 'solid',\n *   segments: [{ type: 'free', points: [] }],\n *   isComplete: true\n * }\n * const isValid = drawShapeProps.color.isValid(props.color)\n * ```\n */\nexport const drawShapeProps: RecordProps<TLDrawShape> = {\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tsegments: T.arrayOf(DrawShapeSegment),\n\tisComplete: T.boolean,\n\tisClosed: T.boolean,\n\tisPen: T.boolean,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('draw', {\n\tAddInPen: 1,\n\tAddScale: 2,\n})\n\n/**\n * Version identifiers for draw shape migrations.\n *\n * @public\n */\nexport { Versions as drawShapeVersions }\n\n/**\n * Migration sequence for draw shape properties across different schema versions.\n * Handles adding pen detection and scale properties to existing draw shapes.\n *\n * @public\n */\nexport const drawShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddInPen,\n\t\t\tup: (props) => {\n\t\t\t\t// Rather than checking to see whether the shape is a pen at runtime,\n\t\t\t\t// from now on we're going to use the type of device reported to us\n\t\t\t\t// as well as the pressure data received; but for existing shapes we\n\t\t\t\t// need to check the pressure data to see if it's a pen or not.\n\n\t\t\t\tconst { points } = props.segments[0]\n\n\t\t\t\tif (points.length === 0) {\n\t\t\t\t\tprops.isPen = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tlet isPen = !(points[0].z === 0 || points[0].z === 0.5)\n\n\t\t\t\tif (points[1]) {\n\t\t\t\t\t// Double check if we have a second point (we probably should)\n\t\t\t\t\tisPen = isPen && !(points[1].z === 0 || points[1].z === 0.5)\n\t\t\t\t}\n\t\t\t\tprops.isPen = isPen\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAmB,yBAAyB;AAC5C,SAAS,8BAA8B,yCAAyC;AAEhF,SAAS,yBAA8C;AACvD,SAAS,wBAA4C;AACrD,SAAS,wBAA4C;AACrD,SAAS,wBAA4C;;;;;;;;AA4B9C,MAAM,mBAA0D,8MAAA,CAAE,MAAA,CAAO;IAC/E,MAAM,8MAAA,CAAE,WAAA,CAAY,QAAQ,UAAU;IACtC,QAAQ,8MAAA,CAAE,OAAA,CAAQ,yMAAiB;AACpC,CAAC;AAkFM,MAAM,iBAA2C;IACvD,OAAO,sMAAA;IACP,MAAM,oMAAA;IACN,MAAM,oMAAA;IACN,MAAM,oMAAA;IACN,UAAU,8MAAA,CAAE,OAAA,CAAQ,gBAAgB;IACpC,YAAY,8MAAA,CAAE,OAAA;IACd,UAAU,8MAAA,CAAE,OAAA;IACZ,OAAO,8MAAA,CAAE,OAAA;IACT,OAAO,8MAAA,CAAE,aAAA;AACV;AAEA,MAAM,eAAW,6MAAA,EAA6B,QAAQ;IACrD,UAAU;IACV,UAAU;AACX,CAAC;AAeM,MAAM,0BAAsB,kNAAA,EAAkC;IACpE,UAAU;QACT;YACC,IAAI,SAAS,QAAA;YACb,IAAI,CAAC,UAAU;gBAMd,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,MAAM,QAAA,CAAS,CAAC,CAAA;gBAEnC,IAAI,OAAO,MAAA,KAAW,GAAG;oBACxB,MAAM,KAAA,GAAQ;oBACd;gBACD;gBAEA,IAAI,QAAQ,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA,CAAE,CAAA,KAAM,KAAK,MAAA,CAAO,CAAC,CAAA,CAAE,CAAA,KAAM,GAAA;gBAEnD,IAAI,MAAA,CAAO,CAAC,CAAA,EAAG;oBAEd,QAAQ,SAAS,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA,CAAE,CAAA,KAAM,KAAK,MAAA,CAAO,CAAC,CAAA,CAAE,CAAA,KAAM,GAAA;gBACzD;gBACA,MAAM,KAAA,GAAQ;YACf;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,QAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,KAAA,GAAQ;YACf;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,KAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3410, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLEmbedShape.ts"],"sourcesContent":["import { safeParseUrl } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n// Only allow multiplayer embeds. If we add additional routes later for example '/help' this won't match\nconst TLDRAW_APP_RE = /(^\\/r\\/[^/]+\\/?$)/\n\nconst EMBED_DEFINITIONS = [\n\t{\n\t\thostnames: ['beta.tldraw.com', 'tldraw.com', 'localhost:3000'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['figma.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/?$/)) {\n\t\t\t\tconst outUrl = urlObj.searchParams.get('url')\n\t\t\t\tif (outUrl) {\n\t\t\t\t\treturn outUrl\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (!urlObj) return\n\n\t\t\tconst matches = urlObj.pathname.match(/^\\/maps\\/embed\\/v1\\/view\\/?$/)\n\t\t\tif (matches && urlObj.searchParams.has('center') && urlObj.searchParams.get('zoom')) {\n\t\t\t\tconst zoom = urlObj.searchParams.get('zoom')\n\t\t\t\tconst [lat, lon] = urlObj.searchParams.get('center')!.split(',')\n\t\t\t\treturn `https://www.google.com/maps/@${lat},${lon},${zoom}z`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['val.town'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\t// e.g. extract \"steveruizok/mathFact\" from https://www.val.town/v/steveruizok/mathFact\n\t\t\tconst matches = urlObj && urlObj.pathname.match(/\\/embed\\/(.+)\\/?/)\n\t\t\tif (matches) {\n\t\t\t\treturn `https://www.val.town/v/${matches[1]}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['codesandbox.io'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tconst matches = urlObj && urlObj.pathname.match(/\\/embed\\/([^/]+)\\/?/)\n\t\t\tif (matches) {\n\t\t\t\treturn `https://codesandbox.io/s/${matches[1]}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['codepen.io'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst CODEPEN_EMBED_REGEXP = /https:\\/\\/codepen.io\\/([^/]+)\\/embed\\/([^/]+)/\n\t\t\tconst matches = url.match(CODEPEN_EMBED_REGEXP)\n\t\t\tif (matches) {\n\t\t\t\tconst [_, user, id] = matches\n\t\t\t\treturn `https://codepen.io/${user}/pen/${id}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['scratch.mit.edu'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst SCRATCH_EMBED_REGEXP = /https:\\/\\/scratch.mit.edu\\/projects\\/embed\\/([^/]+)/\n\t\t\tconst matches = url.match(SCRATCH_EMBED_REGEXP)\n\t\t\tif (matches) {\n\t\t\t\tconst [_, id] = matches\n\t\t\t\treturn `https://scratch.mit.edu/projects/${id}`\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['*.youtube.com', 'youtube.com', 'youtu.be'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (!urlObj) return\n\n\t\t\tconst hostname = urlObj.hostname.replace(/^www./, '')\n\t\t\tif (hostname === 'youtube.com') {\n\t\t\t\tconst matches = urlObj.pathname.match(/^\\/embed\\/([^/]+)\\/?/)\n\t\t\t\tif (matches) {\n\t\t\t\t\treturn `https://www.youtube.com/watch?v=${matches[1]}`\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['calendar.google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tconst srcQs = urlObj?.searchParams.get('src')\n\n\t\t\tif (urlObj?.pathname.match(/\\/calendar\\/embed/) && srcQs) {\n\t\t\t\turlObj.pathname = '/calendar/u/0'\n\t\t\t\tconst keys = Array.from(urlObj.searchParams.keys())\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\turlObj.searchParams.delete(key)\n\t\t\t\t}\n\t\t\t\turlObj.searchParams.set('cid', srcQs)\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['docs.google.*'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\n\t\t\tif (urlObj?.pathname.match(/^\\/presentation/) && urlObj?.pathname.match(/\\/embed\\/?$/)) {\n\t\t\t\turlObj.pathname = urlObj.pathname.replace(/\\/embed$/, '/pub')\n\t\t\t\tconst keys = Array.from(urlObj.searchParams.keys())\n\t\t\t\tfor (const key of keys) {\n\t\t\t\t\turlObj.searchParams.delete(key)\n\t\t\t\t}\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['gist.github.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/\\/([^/]+)\\/([^/]+)/)) {\n\t\t\t\tif (!url.split('/').pop()) return\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['replit.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (\n\t\t\t\turlObj &&\n\t\t\t\turlObj.pathname.match(/\\/@([^/]+)\\/([^/]+)/) &&\n\t\t\t\turlObj.searchParams.has('embed')\n\t\t\t) {\n\t\t\t\turlObj.searchParams.delete('embed')\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['felt.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/map\\//)) {\n\t\t\t\turlObj.pathname = urlObj.pathname.replace(/^\\/embed/, '')\n\t\t\t\treturn urlObj.href\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['open.spotify.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/(artist|album)\\//)) {\n\t\t\t\treturn urlObj.origin + urlObj.pathname.replace(/^\\/embed/, '')\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['vimeo.com', 'player.vimeo.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.hostname === 'player.vimeo.com') {\n\t\t\t\tconst matches = urlObj.pathname.match(/^\\/video\\/([^/]+)\\/?$/)\n\t\t\t\tif (matches) {\n\t\t\t\t\treturn 'https://vimeo.com/' + matches[1]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['excalidraw.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.hash.match(/#room=/)) {\n\t\t\t\treturn url\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['observablehq.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/@([^/]+)\\/([^/]+)\\/?$/)) {\n\t\t\t\treturn `${urlObj.origin}${urlObj.pathname.replace('/embed', '')}#cell-*`\n\t\t\t}\n\t\t\tif (urlObj && urlObj.pathname.match(/^\\/embed\\/([^/]+)\\/?$/)) {\n\t\t\t\treturn `${urlObj.origin}${urlObj.pathname.replace('/embed', '/d')}#cell-*`\n\t\t\t}\n\n\t\t\treturn\n\t\t},\n\t},\n\t{\n\t\thostnames: ['desmos.com'],\n\t\tfromEmbedUrl: (url: string) => {\n\t\t\tconst urlObj = safeParseUrl(url)\n\t\t\tif (\n\t\t\t\turlObj &&\n\t\t\t\turlObj.hostname === 'www.desmos.com' &&\n\t\t\t\turlObj.pathname.match(/^\\/calculator\\/([^/]+)\\/?$/) &&\n\t\t\t\turlObj.search === '?embed' &&\n\t\t\t\turlObj.hash === ''\n\t\t\t) {\n\t\t\t\treturn url.replace('?embed', '')\n\t\t\t}\n\t\t\treturn\n\t\t},\n\t},\n]\n\n/**\n * Properties for the embed shape, which displays embedded content from external services.\n *\n * @public\n */\nexport interface TLEmbedShapeProps {\n\t/** Width of the embed shape in pixels */\n\tw: number\n\t/** Height of the embed shape in pixels */\n\th: number\n\t/** URL of the content to embed (supports YouTube, Figma, CodePen, etc.) */\n\turl: string\n}\n\n/**\n * An embed shape displays external content like YouTube videos, Figma designs, CodePen demos,\n * and other embeddable content within the tldraw canvas.\n *\n * @public\n * @example\n * ```ts\n * const embedShape: TLEmbedShape = {\n *   id: createShapeId(),\n *   typeName: 'shape',\n *   type: 'embed',\n *   x: 200,\n *   y: 200,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:page1',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     w: 560,\n *     h: 315,\n *     url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLEmbedShape = TLBaseShape<'embed', TLEmbedShapeProps>\n\n/**\n * Validation schema for embed shape properties.\n *\n * @public\n * @example\n * ```ts\n * // Validate embed shape properties\n * const isValidUrl = embedShapeProps.url.isValid('https://youtube.com/watch?v=abc123')\n * const isValidSize = embedShapeProps.w.isValid(560)\n * ```\n */\nexport const embedShapeProps: RecordProps<TLEmbedShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\turl: T.string,\n}\n\nconst Versions = createShapePropsMigrationIds('embed', {\n\tGenOriginalUrlInEmbed: 1,\n\tRemoveDoesResize: 2,\n\tRemoveTmpOldUrl: 3,\n\tRemovePermissionOverrides: 4,\n})\n\n/**\n * Version identifiers for embed shape migrations.\n *\n * @public\n */\nexport { Versions as embedShapeVersions }\n\n/**\n * Migration sequence for embed shape properties across different schema versions.\n * Handles URL transformations and removal of deprecated properties.\n *\n * @public\n */\nexport const embedShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.GenOriginalUrlInEmbed,\n\t\t\t// add tmpOldUrl property\n\t\t\tup: (props) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst url = props.url\n\t\t\t\t\tconst host = new URL(url).host.replace('www.', '')\n\t\t\t\t\tlet originalUrl\n\t\t\t\t\tfor (const localEmbedDef of EMBED_DEFINITIONS) {\n\t\t\t\t\t\tif (localEmbedDef.hostnames.includes(host)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\toriginalUrl = localEmbedDef.fromEmbedUrl(url)\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tconsole.warn(err)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tprops.tmpOldUrl = props.url\n\t\t\t\t\tprops.url = originalUrl ?? ''\n\t\t\t\t} catch {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t\tprops.tmpOldUrl = props.url\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveDoesResize,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.doesResize\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveTmpOldUrl,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.tmpOldUrl\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemovePermissionOverrides,\n\t\t\tup: (props) => {\n\t\t\t\tdelete props.overridePermissions\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t],\n})\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3757, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLFrameShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Properties for the frame shape, which provides a container for organizing other shapes.\n *\n * @public\n */\nexport interface TLFrameShapeProps {\n\t/** Width of the frame in pixels */\n\tw: number\n\t/** Height of the frame in pixels */\n\th: number\n\t/** Display name for the frame (shown in UI) */\n\tname: string\n\t/** Color style for the frame border and label */\n\tcolor: TLDefaultColorStyle\n}\n\n/**\n * A frame shape provides a container for organizing and grouping other shapes.\n * Frames can be used to create sections, organize content, or define specific areas.\n *\n * @public\n * @example\n * ```ts\n * const frameShape: TLFrameShape = {\n *   id: createShapeId(),\n *   typeName: 'shape',\n *   type: 'frame',\n *   x: 0,\n *   y: 0,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:page1',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     w: 400,\n *     h: 300,\n *     name: 'Header Section',\n *     color: 'blue'\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLFrameShape = TLBaseShape<'frame', TLFrameShapeProps>\n\n/**\n * Validation schema for frame shape properties.\n *\n * @public\n * @example\n * ```ts\n * // Validate frame properties\n * const isValidName = frameShapeProps.name.isValid('My Frame')\n * const isValidColor = frameShapeProps.color.isValid('red')\n * ```\n */\nexport const frameShapeProps: RecordProps<TLFrameShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tname: T.string,\n\t// because shape colors are an option, we don't want them to be picked up by the editor as a\n\t// style prop by default, so instead of a proper style we just supply an equivalent validator.\n\t// Check `FrameShapeUtil.configure` for how we replace this with the original\n\t// `DefaultColorStyle` style when the option is turned on.\n\tcolor: T.literalEnum(...DefaultColorStyle.values),\n}\n\nconst Versions = createShapePropsMigrationIds('frame', {\n\tAddColorProp: 1,\n})\n\n/**\n * Version identifiers for frame shape migrations.\n *\n * @public\n */\nexport { Versions as frameShapeVersions }\n\n/**\n * Migration sequence for frame shape properties across different schema versions.\n * Handles adding color properties to existing frame shapes.\n *\n * @public\n */\nexport const frameShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddColorProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.color = 'black'\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.color\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAS,8BAA8B,yCAAyC;AAEhF,SAAS,yBAA8C;;;;AA4DhD,MAAM,kBAA6C;IACzD,GAAG,8MAAA,CAAE,aAAA;IACL,GAAG,8MAAA,CAAE,aAAA;IACL,MAAM,8MAAA,CAAE,MAAA;IAAA,4FAAA;IAAA,8FAAA;IAAA,6EAAA;IAAA,0DAAA;IAKR,OAAO,8MAAA,CAAE,WAAA,CAAY,GAAG,sMAAA,CAAkB,MAAM;AACjD;AAEA,MAAM,eAAW,6MAAA,EAA6B,SAAS;IACtD,cAAc;AACf,CAAC;AAeM,MAAM,2BAAuB,kNAAA,EAAkC;IACrE,UAAU;QACT;YACC,IAAI,SAAS,YAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,KAAA,GAAQ;YACf;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,KAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 3804, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLHorizontalAlignStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default horizontal alignment style property used by tldraw shapes for text positioning.\n * Controls how text content is horizontally aligned within shape boundaries.\n *\n * Available values:\n * - `start` - Align text to the start (left in LTR, right in RTL)\n * - `middle` - Center text horizontally\n * - `end` - Align text to the end (right in LTR, left in RTL)\n * - `start-legacy` - Legacy start alignment (deprecated)\n * - `end-legacy` - Legacy end alignment (deprecated)\n * - `middle-legacy` - Legacy middle alignment (deprecated)\n *\n * @example\n * ```ts\n * import { DefaultHorizontalAlignStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyTextShapeProps {\n *   align: typeof DefaultHorizontalAlignStyle\n *   // other props...\n * }\n *\n * // Create a shape with center-aligned text\n * const textShape = {\n *   // ... other properties\n *   props: {\n *     align: 'middle' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultHorizontalAlignStyle = StyleProp.defineEnum('tldraw:horizontalAlign', {\n\tdefaultValue: 'middle',\n\tvalues: ['start', 'middle', 'end', 'start-legacy', 'end-legacy', 'middle-legacy'],\n})\n\n/**\n * Type representing a default horizontal alignment style value.\n * This is a union type of all available horizontal alignment options.\n *\n * @example\n * ```ts\n * import { TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema'\n *\n * // Valid horizontal alignment values\n * const leftAlign: TLDefaultHorizontalAlignStyle = 'start'\n * const centerAlign: TLDefaultHorizontalAlignStyle = 'middle'\n * const rightAlign: TLDefaultHorizontalAlignStyle = 'end'\n *\n * // Use in a function parameter\n * function setTextAlignment(align: TLDefaultHorizontalAlignStyle) {\n *   // Apply horizontal alignment to text\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultHorizontalAlignStyle = T.TypeOf<typeof DefaultHorizontalAlignStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAoCnB,MAAM,8BAA8B,2LAAA,CAAU,UAAA,CAAW,0BAA0B;IACzF,cAAc;IACd,QAAQ;QAAC;QAAS;QAAU;QAAO;QAAgB;QAAc,eAAe;KAAA;AACjF,CAAC","debugId":null}},
    {"offset": {"line": 3827, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLVerticalAlignStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default vertical alignment style property used by tldraw shapes for text positioning.\n * Controls how text content is vertically aligned within shape boundaries.\n *\n * Available values:\n * - `start` - Align text to the top\n * - `middle` - Center text vertically (default)\n * - `end` - Align text to the bottom\n *\n * @example\n * ```ts\n * import { DefaultVerticalAlignStyle } from '@tldraw/tlschema'\n *\n * // Use in shape props definition\n * interface MyShapeProps {\n *   verticalAlign: typeof DefaultVerticalAlignStyle\n *   // other props...\n * }\n *\n * // Create a shape with top-aligned text\n * const shape = {\n *   // ... other properties\n *   props: {\n *     verticalAlign: 'start' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultVerticalAlignStyle = StyleProp.defineEnum('tldraw:verticalAlign', {\n\tdefaultValue: 'middle',\n\tvalues: ['start', 'middle', 'end'],\n})\n\n/**\n * Type representing a default vertical alignment style value.\n * This is a union type of all available vertical alignment options.\n *\n * @example\n * ```ts\n * import { TLDefaultVerticalAlignStyle } from '@tldraw/tlschema'\n *\n * // Valid vertical alignment values\n * const topAlign: TLDefaultVerticalAlignStyle = 'start'\n * const centerAlign: TLDefaultVerticalAlignStyle = 'middle'\n * const bottomAlign: TLDefaultVerticalAlignStyle = 'end'\n *\n * // Use in a function parameter\n * function setVerticalAlignment(align: TLDefaultVerticalAlignStyle) {\n *   // Apply vertical alignment to text\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultVerticalAlignStyle = T.TypeOf<typeof DefaultVerticalAlignStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAiCnB,MAAM,4BAA4B,2LAAA,CAAU,UAAA,CAAW,wBAAwB;IACrF,cAAc;IACd,QAAQ;QAAC;QAAS;QAAU,KAAK;KAAA;AAClC,CAAC","debugId":null}},
    {"offset": {"line": 3847, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLGeoShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { TLRichText, richTextValidator, toRichText } from '../misc/TLRichText'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultFillStyle, TLDefaultFillStyle } from '../styles/TLFillStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport {\n\tDefaultHorizontalAlignStyle,\n\tTLDefaultHorizontalAlignStyle,\n} from '../styles/TLHorizontalAlignStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport {\n\tDefaultVerticalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n} from '../styles/TLVerticalAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Style property defining the geometric shape type for geo shapes.\n * Provides a variety of built-in geometric forms including basic shapes,\n * polygons, arrows, and special shapes.\n *\n * @public\n * @example\n * ```ts\n * // Use in shape props\n * const props = {\n *   geo: 'rectangle', // or 'ellipse', 'triangle', etc.\n *   // other properties...\n * }\n * ```\n */\nexport const GeoShapeGeoStyle = StyleProp.defineEnum('tldraw:geo', {\n\tdefaultValue: 'rectangle',\n\tvalues: [\n\t\t'cloud',\n\t\t'rectangle',\n\t\t'ellipse',\n\t\t'triangle',\n\t\t'diamond',\n\t\t'pentagon',\n\t\t'hexagon',\n\t\t'octagon',\n\t\t'star',\n\t\t'rhombus',\n\t\t'rhombus-2',\n\t\t'oval',\n\t\t'trapezoid',\n\t\t'arrow-right',\n\t\t'arrow-left',\n\t\t'arrow-up',\n\t\t'arrow-down',\n\t\t'x-box',\n\t\t'check-box',\n\t\t'heart',\n\t],\n})\n\n/**\n * Type representing valid geometric shape styles for geo shapes.\n *\n * @public\n */\nexport type TLGeoShapeGeoStyle = T.TypeOf<typeof GeoShapeGeoStyle>\n\n/**\n * Properties for the geo shape, which renders various geometric forms with styling and text.\n *\n * @public\n */\nexport interface TLGeoShapeProps {\n\t/** Geometric shape type (rectangle, ellipse, triangle, etc.) */\n\tgeo: TLGeoShapeGeoStyle\n\t/** Dash pattern style for the shape outline */\n\tdash: TLDefaultDashStyle\n\t/** URL link associated with the shape */\n\turl: string\n\t/** Width of the shape in pixels */\n\tw: number\n\t/** Height of the shape in pixels */\n\th: number\n\t/** Additional vertical growth for text content */\n\tgrowY: number\n\t/** Scale factor applied to the shape */\n\tscale: number\n\n\t/** Color style for text label */\n\tlabelColor: TLDefaultColorStyle\n\t/** Color style for the shape outline */\n\tcolor: TLDefaultColorStyle\n\t/** Fill style for the shape interior */\n\tfill: TLDefaultFillStyle\n\t/** Size/thickness style for outline and text */\n\tsize: TLDefaultSizeStyle\n\t/** Font style for text content */\n\tfont: TLDefaultFontStyle\n\t/** Horizontal alignment for text content */\n\talign: TLDefaultHorizontalAlignStyle\n\t/** Vertical alignment for text content */\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\t/** Rich text content displayed within the shape */\n\trichText: TLRichText\n}\n\n/**\n * A geo shape represents geometric forms like rectangles, ellipses, triangles, and other\n * predefined shapes. Geo shapes support styling, text content, and can act as containers.\n *\n * @public\n * @example\n * ```ts\n * const geoShape: TLGeoShape = {\n *   id: createShapeId(),\n *   typeName: 'shape',\n *   type: 'geo',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:page1',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     geo: 'rectangle',\n *     w: 200,\n *     h: 100,\n *     color: 'black',\n *     fill: 'solid',\n *     dash: 'solid',\n *     size: 'm',\n *     font: 'draw',\n *     align: 'middle',\n *     verticalAlign: 'middle',\n *     richText: toRichText('Hello World'),\n *     labelColor: 'black',\n *     url: '',\n *     growY: 0,\n *     scale: 1\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLGeoShape = TLBaseShape<'geo', TLGeoShapeProps>\n\n/**\n * Validation schema for geo shape properties.\n *\n * @public\n * @example\n * ```ts\n * // Validate geo shape properties\n * const isValidGeo = geoShapeProps.geo.isValid('rectangle')\n * const isValidSize = geoShapeProps.w.isValid(100)\n * const isValidText = geoShapeProps.richText.isValid(toRichText('Hello'))\n * ```\n */\nexport const geoShapeProps: RecordProps<TLGeoShape> = {\n\tgeo: GeoShapeGeoStyle,\n\tdash: DefaultDashStyle,\n\turl: T.linkUrl,\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tgrowY: T.positiveNumber,\n\tscale: T.nonZeroNumber,\n\n\t// Text properties\n\tlabelColor: DefaultLabelColorStyle,\n\tcolor: DefaultColorStyle,\n\tfill: DefaultFillStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\talign: DefaultHorizontalAlignStyle,\n\tverticalAlign: DefaultVerticalAlignStyle,\n\trichText: richTextValidator,\n}\n\nconst geoShapeVersions = createShapePropsMigrationIds('geo', {\n\tAddUrlProp: 1,\n\tAddLabelColor: 2,\n\tRemoveJustify: 3,\n\tAddCheckBox: 4,\n\tAddVerticalAlign: 5,\n\tMigrateLegacyAlign: 6,\n\tAddCloud: 7,\n\tMakeUrlsValid: 8,\n\tAddScale: 9,\n\tAddRichText: 10,\n})\n\n/**\n * Version identifiers for geo shape migrations.\n *\n * @public\n */\nexport { geoShapeVersions as geoShapeVersions }\n\n/**\n * Migration sequence for geo shape properties across different schema versions.\n * Handles evolution of geo shapes including URL support, label colors, alignment changes,\n * and the transition from plain text to rich text.\n *\n * @public\n */\nexport const geoShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: geoShapeVersions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddCheckBox,\n\t\t\tup: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddVerticalAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.verticalAlign = 'middle'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.MigrateLegacyAlign,\n\t\t\tup: (props) => {\n\t\t\t\tlet newAlign: TLDefaultHorizontalAlignStyle\n\t\t\t\tswitch (props.align) {\n\t\t\t\t\tcase 'start':\n\t\t\t\t\t\tnewAlign = 'start-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase 'end':\n\t\t\t\t\t\tnewAlign = 'end-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnewAlign = 'middle-legacy'\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tprops.align = newAlign\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddCloud,\n\t\t\tup: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: geoShapeVersions.AddRichText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.richText = toRichText(props.text)\n\t\t\t\tdelete props.text\n\t\t\t},\n\t\t\t// N.B. Explicitly no down state so that we force clients to update.\n\t\t\t// down: (props) => {\n\t\t\t// \tdelete props.richText\n\t\t\t// },\n\t\t},\n\t],\n})\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4029, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLGroupShape.ts"],"sourcesContent":["import { createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Properties for a group shape. Group shapes are used to organize and manage collections of shapes as a single unit.\n * Group shapes themselves have no visual properties and serve only as containers.\n *\n * @public\n * @example\n * ```ts\n * const groupProps: TLGroupShapeProps = {}\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TLGroupShapeProps {}\n\n/**\n * A group shape that acts as a container for organizing multiple shapes into a single logical unit.\n * Groups enable users to move, transform, and manage collections of shapes together while maintaining\n * their relative positions and properties.\n *\n * @public\n * @example\n * ```ts\n * const groupShape: TLGroupShape = {\n *   id: 'shape:group1',\n *   type: 'group',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {},\n *   meta: {},\n *   typeName: 'shape'\n * }\n * ```\n */\nexport type TLGroupShape = TLBaseShape<'group', TLGroupShapeProps>\n\n/**\n * Validation schema for group shape properties. Since group shapes have no visual properties,\n * this is an empty object that serves as a placeholder for the schema system.\n *\n * @public\n * @example\n * ```ts\n * import { groupShapeProps } from '@tldraw/tlschema'\n *\n * // Used internally by the validation system\n * const validator = T.object(groupShapeProps)\n * ```\n */\nexport const groupShapeProps: RecordProps<TLGroupShape> = {}\n\n/**\n * Migration sequence for group shapes. Currently contains no migrations.\n *\n * @public\n */\nexport const groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] })\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,yCAAyC;;AAwD3C,MAAM,kBAA6C,CAAC;AAOpD,MAAM,2BAAuB,kNAAA,EAAkC;IAAE,UAAU,CAAC,CAAA;AAAE,CAAC","debugId":null}},
    {"offset": {"line": 4047, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLHighlightShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\nimport { DrawShapeSegment, TLDrawShapeSegment } from './TLDrawShape'\n\n/**\n * Properties for a highlight shape. Highlight shapes represent highlighting strokes made with\n * a highlighting tool, typically used to emphasize or mark up content.\n *\n * @public\n * @example\n * ```ts\n * const highlightProps: TLHighlightShapeProps = {\n *   color: 'yellow',\n *   size: 'm',\n *   segments: [{ type: 'straight', points: [{ x: 0, y: 0, z: 0.5 }] }],\n *   isComplete: true,\n *   isPen: false,\n *   scale: 1\n * }\n * ```\n */\nexport interface TLHighlightShapeProps {\n\t/** The color style of the highlight stroke */\n\tcolor: TLDefaultColorStyle\n\t/** The size style determining the thickness of the highlight stroke */\n\tsize: TLDefaultSizeStyle\n\t/** Array of segments that make up the highlight stroke path */\n\tsegments: TLDrawShapeSegment[]\n\t/** Whether the highlight stroke has been completed by the user */\n\tisComplete: boolean\n\t/** Whether the highlight was drawn with a pen/stylus (affects rendering style) */\n\tisPen: boolean\n\t/** Scale factor applied to the highlight shape for display */\n\tscale: number\n}\n\n/**\n * A highlight shape representing a highlighting stroke drawn by the user. Highlight shapes\n * are typically semi-transparent and used for marking up or emphasizing content on the canvas.\n *\n * @public\n * @example\n * ```ts\n * const highlightShape: TLHighlightShape = {\n *   id: 'shape:highlight1',\n *   type: 'highlight',\n *   x: 100,\n *   y: 50,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 0.7,\n *   props: {\n *     color: 'yellow',\n *     size: 'l',\n *     segments: [],\n *     isComplete: false,\n *     isPen: false,\n *     scale: 1\n *   },\n *   meta: {},\n *   typeName: 'shape'\n * }\n * ```\n */\nexport type TLHighlightShape = TLBaseShape<'highlight', TLHighlightShapeProps>\n\n/**\n * Validation schema for highlight shape properties. Defines the runtime validation rules\n * for all properties of highlight shapes.\n *\n * @public\n * @example\n * ```ts\n * import { highlightShapeProps } from '@tldraw/tlschema'\n *\n * // Used internally by the validation system\n * const validator = T.object(highlightShapeProps)\n * const validatedProps = validator.validate(someHighlightProps)\n * ```\n */\nexport const highlightShapeProps: RecordProps<TLHighlightShape> = {\n\tcolor: DefaultColorStyle,\n\tsize: DefaultSizeStyle,\n\tsegments: T.arrayOf(DrawShapeSegment),\n\tisComplete: T.boolean,\n\tisPen: T.boolean,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('highlight', {\n\tAddScale: 1,\n})\n\n/**\n * Version identifiers for highlight shape migrations. These version numbers track\n * schema changes over time to enable proper data migration.\n *\n * @public\n */\nexport { Versions as highlightShapeVersions }\n\n/**\n * Migration sequence for highlight shapes. Handles schema evolution over time by defining\n * how to upgrade and downgrade highlight shape data between different versions.\n *\n * @public\n */\nexport const highlightShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAS,8BAA8B,yCAAyC;AAEhF,SAAS,yBAA8C;AACvD,SAAS,wBAA4C;AAErD,SAAS,wBAA4C;;;;;;AAgF9C,MAAM,sBAAqD;IACjE,OAAO,sMAAA;IACP,MAAM,oMAAA;IACN,UAAU,8MAAA,CAAE,OAAA,CAAQ,oMAAgB;IACpC,YAAY,8MAAA,CAAE,OAAA;IACd,OAAO,8MAAA,CAAE,OAAA;IACT,OAAO,8MAAA,CAAE,aAAA;AACV;AAEA,MAAM,eAAW,6MAAA,EAA6B,aAAa;IAC1D,UAAU;AACX,CAAC;AAgBM,MAAM,+BAA2B,kNAAA,EAAkC;IACzE,UAAU;QACT;YACC,IAAI,SAAS,QAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,KAAA,GAAQ;YACf;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,KAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 4096, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLImageShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { vecModelValidator } from '../misc/geometry-types'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLShapeCrop } from './ShapeWithCrop'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Validator for image shape crop data. Defines the structure for cropping an image,\n * specifying the visible region within the original image bounds.\n *\n * @public\n * @example\n * ```ts\n * const cropData: TLShapeCrop = {\n *   topLeft: { x: 0.1, y: 0.1 },\n *   bottomRight: { x: 0.9, y: 0.9 },\n *   isCircle: false\n * }\n *\n * const isValid = ImageShapeCrop.isValid(cropData)\n * ```\n */\nexport const ImageShapeCrop: T.ObjectValidator<TLShapeCrop> = T.object({\n\ttopLeft: vecModelValidator,\n\tbottomRight: vecModelValidator,\n\tisCircle: T.boolean.optional(),\n})\n\n/**\n * Properties for an image shape. Image shapes display raster images on the canvas,\n * with support for cropping, flipping, and asset management.\n *\n * @public\n * @example\n * ```ts\n * const imageProps: TLImageShapeProps = {\n *   w: 300,\n *   h: 200,\n *   playing: true,\n *   url: 'https://example.com/image.jpg',\n *   assetId: 'asset:image123',\n *   crop: null,\n *   flipX: false,\n *   flipY: false,\n *   altText: 'A sample image'\n * }\n * ```\n */\nexport interface TLImageShapeProps {\n\t/** Width of the image shape in canvas units */\n\tw: number\n\t/** Height of the image shape in canvas units */\n\th: number\n\t/** Whether animated images (like GIFs) should play */\n\tplaying: boolean\n\t/** URL of the image resource */\n\turl: string\n\t/** ID of the associated asset record, null if no asset */\n\tassetId: TLAssetId | null\n\t/** Crop data defining visible region of the image, null for no cropping */\n\tcrop: TLShapeCrop | null\n\t/** Whether to flip the image horizontally */\n\tflipX: boolean\n\t/** Whether to flip the image vertically */\n\tflipY: boolean\n\t/** Alternative text for accessibility and when image fails to load */\n\taltText: string\n}\n\n/**\n * An image shape representing a raster image on the canvas. Image shapes can display\n * various image formats and support features like cropping, flipping, and asset management.\n *\n * @public\n * @example\n * ```ts\n * const imageShape: TLImageShape = {\n *   id: 'shape:image1',\n *   type: 'image',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     w: 400,\n *     h: 300,\n *     playing: true,\n *     url: '',\n *     assetId: 'asset:photo1',\n *     crop: null,\n *     flipX: false,\n *     flipY: false,\n *     altText: 'Sample photo'\n *   },\n *   meta: {},\n *   typeName: 'shape'\n * }\n * ```\n */\nexport type TLImageShape = TLBaseShape<'image', TLImageShapeProps>\n\n/**\n * Validation schema for image shape properties. Defines the runtime validation rules\n * for all properties of image shapes, ensuring data integrity and type safety.\n *\n * @public\n * @example\n * ```ts\n * import { imageShapeProps } from '@tldraw/tlschema'\n *\n * // Used internally by the validation system\n * const validator = T.object(imageShapeProps)\n * const validatedProps = validator.validate(someImageProps)\n * ```\n */\nexport const imageShapeProps: RecordProps<TLImageShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\tplaying: T.boolean,\n\turl: T.linkUrl,\n\tassetId: assetIdValidator.nullable(),\n\tcrop: ImageShapeCrop.nullable(),\n\tflipX: T.boolean,\n\tflipY: T.boolean,\n\taltText: T.string,\n}\n\nconst Versions = createShapePropsMigrationIds('image', {\n\tAddUrlProp: 1,\n\tAddCropProp: 2,\n\tMakeUrlsValid: 3,\n\tAddFlipProps: 4,\n\tAddAltText: 5,\n})\n\n/**\n * Version identifiers for image shape migrations. These version numbers track\n * schema changes over time to enable proper data migration between versions.\n *\n * @public\n */\nexport { Versions as imageShapeVersions }\n\n/**\n * Migration sequence for image shapes. Handles schema evolution over time by defining\n * how to upgrade and downgrade image shape data between different versions. Includes\n * migrations for URL properties, crop functionality, flip properties, and accessibility features.\n *\n * @public\n */\nexport const imageShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddCropProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.crop = null\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.crop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFlipProps,\n\t\t\tup: (props) => {\n\t\t\t\tprops.flipX = false\n\t\t\t\tprops.flipY = false\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.flipX\n\t\t\t\tdelete props.flipY\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddAltText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.altText = ''\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.altText\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAS,wBAAwB;AACjC,SAAS,yBAAyB;AAElC,SAAS,8BAA8B,yCAAyC;;;;;AAqBzE,MAAM,iBAAiD,8MAAA,CAAE,MAAA,CAAO;IACtE,SAAS,yMAAA;IACT,aAAa,yMAAA;IACb,UAAU,8MAAA,CAAE,OAAA,CAAQ,QAAA,CAAS;AAC9B,CAAC;AA4FM,MAAM,kBAA6C;IACzD,GAAG,8MAAA,CAAE,aAAA;IACL,GAAG,8MAAA,CAAE,aAAA;IACL,SAAS,8MAAA,CAAE,OAAA;IACX,KAAK,8MAAA,CAAE,OAAA;IACP,SAAS,oMAAA,CAAiB,QAAA,CAAS;IACnC,MAAM,eAAe,QAAA,CAAS;IAC9B,OAAO,8MAAA,CAAE,OAAA;IACT,OAAO,8MAAA,CAAE,OAAA;IACT,SAAS,8MAAA,CAAE,MAAA;AACZ;AAEA,MAAM,eAAW,6MAAA,EAA6B,SAAS;IACtD,YAAY;IACZ,aAAa;IACb,eAAe;IACf,cAAc;IACd,YAAY;AACb,CAAC;AAiBM,MAAM,2BAAuB,kNAAA,EAAkC;IACrE,UAAU;QACT;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,GAAA,GAAM;YACb;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,IAAA,GAAO;YACd;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,IAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,CAAC,8MAAA,CAAE,OAAA,CAAQ,OAAA,CAAQ,MAAM,GAAG,GAAG;oBAClC,MAAM,GAAA,GAAM;gBACb;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,YAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,KAAA,GAAQ;gBACd,MAAM,KAAA,GAAQ;YACf;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,KAAA;gBACb,OAAO,MAAM,KAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,OAAA,GAAU;YACjB;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,OAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 4193, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLLineShape.ts"],"sourcesContent":["import { IndexKey, getIndices, objectMapFromEntries, sortByIndex } from '@tldraw/utils'\nimport { T } from '@tldraw/validate'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { StyleProp } from '../styles/StyleProp'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultDashStyle, TLDefaultDashStyle } from '../styles/TLDashStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Style property for line shape spline interpolation. Determines how the line is rendered\n * between points - either as straight line segments or smooth cubic curves.\n *\n * @public\n * @example\n * ```ts\n * // Create a shape with cubic spline interpolation\n * const lineProps = {\n *   spline: 'cubic' as TLLineShapeSplineStyle,\n *   // other props...\n * }\n * ```\n */\nexport const LineShapeSplineStyle = StyleProp.defineEnum('tldraw:spline', {\n\tdefaultValue: 'line',\n\tvalues: ['cubic', 'line'],\n})\n\n/**\n * Type representing the spline style options for line shapes.\n * - 'line': Straight line segments between points\n * - 'cubic': Smooth cubic bezier curves between points\n *\n * @public\n */\nexport type TLLineShapeSplineStyle = T.TypeOf<typeof LineShapeSplineStyle>\n\n/**\n * Represents a single point in a line shape. Line shapes are made up of multiple points\n * that define the path of the line, with each point having coordinates and ordering information.\n *\n * @public\n * @example\n * ```ts\n * const linePoint: TLLineShapePoint = {\n *   id: 'a1',\n *   index: 'a1' as IndexKey,\n *   x: 100,\n *   y: 50\n * }\n * ```\n */\nexport interface TLLineShapePoint {\n\t/** Unique identifier for this point, used for tracking and ordering */\n\tid: string\n\t/** Fractional index key used for ordering points along the line */\n\tindex: IndexKey\n\t/** X coordinate of the point relative to the line shape's origin */\n\tx: number\n\t/** Y coordinate of the point relative to the line shape's origin */\n\ty: number\n}\n\nconst lineShapePointValidator: T.ObjectValidator<TLLineShapePoint> = T.object({\n\tid: T.string,\n\tindex: T.indexKey,\n\tx: T.number,\n\ty: T.number,\n})\n\n/**\n * Properties for a line shape. Line shapes represent multi-point lines or splines\n * that can be drawn by connecting multiple points with either straight segments or curves.\n *\n * @public\n * @example\n * ```ts\n * const lineProps: TLLineShapeProps = {\n *   color: 'black',\n *   dash: 'solid',\n *   size: 'm',\n *   spline: 'line',\n *   points: {\n *     'a1': { id: 'a1', index: 'a1', x: 0, y: 0 },\n *     'a2': { id: 'a2', index: 'a2', x: 100, y: 50 }\n *   },\n *   scale: 1\n * }\n * ```\n */\nexport interface TLLineShapeProps {\n\t/** Color style of the line stroke */\n\tcolor: TLDefaultColorStyle\n\t/** Dash pattern style for the line (solid, dashed, dotted) */\n\tdash: TLDefaultDashStyle\n\t/** Size/thickness style of the line stroke */\n\tsize: TLDefaultSizeStyle\n\t/** Interpolation style between points (straight lines or curved splines) */\n\tspline: TLLineShapeSplineStyle\n\t/** Dictionary of points that make up the line, keyed by point ID */\n\tpoints: Record<string, TLLineShapePoint>\n\t/** Scale factor applied to the line shape for display */\n\tscale: number\n}\n\n/**\n * A line shape that represents a multi-point line or spline on the canvas. Line shapes\n * allow users to draw connected paths with multiple points, supporting both straight\n * line segments and smooth curved splines.\n *\n * @public\n * @example\n * ```ts\n * const lineShape: TLLineShape = {\n *   id: 'shape:line1',\n *   type: 'line',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     color: 'red',\n *     dash: 'dashed',\n *     size: 'l',\n *     spline: 'cubic',\n *     points: {\n *       'start': { id: 'start', index: 'a1', x: 0, y: 0 },\n *       'end': { id: 'end', index: 'a2', x: 200, y: 100 }\n *     },\n *     scale: 1\n *   },\n *   meta: {},\n *   typeName: 'shape'\n * }\n * ```\n */\nexport type TLLineShape = TLBaseShape<'line', TLLineShapeProps>\n\n/**\n * Validation schema for line shape properties. Defines the runtime validation rules\n * for all properties of line shapes, ensuring data integrity and type safety.\n *\n * @public\n * @example\n * ```ts\n * import { lineShapeProps } from '@tldraw/tlschema'\n *\n * // Used internally by the validation system\n * const validator = T.object(lineShapeProps)\n * const validatedProps = validator.validate(someLineProps)\n * ```\n */\nexport const lineShapeProps: RecordProps<TLLineShape> = {\n\tcolor: DefaultColorStyle,\n\tdash: DefaultDashStyle,\n\tsize: DefaultSizeStyle,\n\tspline: LineShapeSplineStyle,\n\tpoints: T.dict(T.string, lineShapePointValidator),\n\tscale: T.nonZeroNumber,\n}\n\n/**\n * Version identifiers for line shape migrations. These version numbers track\n * significant schema changes over time, enabling proper data migration between versions.\n *\n * @public\n */\nexport const lineShapeVersions = createShapePropsMigrationIds('line', {\n\tAddSnapHandles: 1,\n\tRemoveExtraHandleProps: 2,\n\tHandlesToPoints: 3,\n\tPointIndexIds: 4,\n\tAddScale: 5,\n})\n\n/**\n * Migration sequence for line shapes. Handles schema evolution over time by defining\n * how to upgrade and downgrade line shape data between different versions. Includes\n * major structural changes like the transition from handles to points and the addition\n * of scaling support.\n *\n * @public\n */\nexport const lineShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: lineShapeVersions.AddSnapHandles,\n\t\t\tup: (props) => {\n\t\t\t\tfor (const handle of Object.values(props.handles)) {\n\t\t\t\t\t;(handle as any).canSnap = true\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.RemoveExtraHandleProps,\n\t\t\tup: (props) => {\n\t\t\t\tprops.handles = objectMapFromEntries(\n\t\t\t\t\tObject.values(props.handles).map((handle: any) => [\n\t\t\t\t\t\thandle.index,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst handles = Object.entries(props.handles)\n\t\t\t\t\t.map(([index, handle]: any) => ({ index, ...handle }))\n\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\tprops.handles = Object.fromEntries(\n\t\t\t\t\thandles.map((handle, i) => {\n\t\t\t\t\t\tconst id =\n\t\t\t\t\t\t\ti === 0 ? 'start' : i === handles.length - 1 ? 'end' : `handle:${handle.index}`\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t\ttype: 'vertex',\n\t\t\t\t\t\t\t\tcanBind: false,\n\t\t\t\t\t\t\t\tcanSnap: true,\n\t\t\t\t\t\t\t\tindex: handle.index,\n\t\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.HandlesToPoints,\n\t\t\tup: (props) => {\n\t\t\t\tconst sortedHandles = (\n\t\t\t\t\tObject.entries(props.handles) as [IndexKey, { x: number; y: number }][]\n\t\t\t\t)\n\t\t\t\t\t.map(([index, { x, y }]) => ({ x, y, index }))\n\t\t\t\t\t.sort(sortByIndex)\n\n\t\t\t\tprops.points = sortedHandles.map(({ x, y }) => ({ x, y }))\n\t\t\t\tdelete props.handles\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst indices = getIndices(props.points.length)\n\n\t\t\t\tprops.handles = Object.fromEntries(\n\t\t\t\t\tprops.points.map((handle: { x: number; y: number }, i: number) => {\n\t\t\t\t\t\tconst index = indices[i]\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\n\t\t\t\tdelete props.points\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.PointIndexIds,\n\t\t\tup: (props) => {\n\t\t\t\tconst indices = getIndices(props.points.length)\n\n\t\t\t\tprops.points = Object.fromEntries(\n\t\t\t\t\tprops.points.map((point: { x: number; y: number }, i: number) => {\n\t\t\t\t\t\tconst id = indices[i]\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\t\tindex: id,\n\t\t\t\t\t\t\t\tx: point.x,\n\t\t\t\t\t\t\t\ty: point.y,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tconst sortedHandles = (\n\t\t\t\t\tObject.values(props.points) as { x: number; y: number; index: IndexKey }[]\n\t\t\t\t).sort(sortByIndex)\n\n\t\t\t\tprops.points = sortedHandles.map(({ x, y }) => ({ x, y }))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: lineShapeVersions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4364, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLNoteShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { TLRichText, richTextValidator, toRichText } from '../misc/TLRichText'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport {\n\tDefaultColorStyle,\n\tDefaultLabelColorStyle,\n\tTLDefaultColorStyle,\n} from '../styles/TLColorStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport {\n\tDefaultHorizontalAlignStyle,\n\tTLDefaultHorizontalAlignStyle,\n} from '../styles/TLHorizontalAlignStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport {\n\tDefaultVerticalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n} from '../styles/TLVerticalAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Properties for a note shape. Note shapes represent sticky notes or text annotations\n * with rich formatting capabilities and various styling options.\n *\n * @public\n * @example\n * ```ts\n * const noteProps: TLNoteShapeProps = {\n *   color: 'yellow',\n *   labelColor: 'black',\n *   size: 'm',\n *   font: 'draw',\n *   fontSizeAdjustment: 0,\n *   align: 'middle',\n *   verticalAlign: 'middle',\n *   growY: 0,\n *   url: '',\n *   richText: toRichText('Hello **world**!'),\n *   scale: 1\n * }\n * ```\n */\nexport interface TLNoteShapeProps {\n\t/** Background color style of the note */\n\tcolor: TLDefaultColorStyle\n\t/** Text color style for the note content */\n\tlabelColor: TLDefaultColorStyle\n\t/** Size style determining the font size and note dimensions */\n\tsize: TLDefaultSizeStyle\n\t/** Font family style for the note text */\n\tfont: TLDefaultFontStyle\n\t/** Adjustment to the base font size (positive increases, negative decreases) */\n\tfontSizeAdjustment: number\n\t/** Horizontal alignment of text within the note */\n\talign: TLDefaultHorizontalAlignStyle\n\t/** Vertical alignment of text within the note */\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\t/** Additional height growth for the note beyond its base size */\n\tgrowY: number\n\t/** Optional URL associated with the note for linking */\n\turl: string\n\t/** Rich text content with formatting like bold, italic, etc. */\n\trichText: TLRichText\n\t/** Scale factor applied to the note shape for display */\n\tscale: number\n}\n\n/**\n * A note shape representing a sticky note or text annotation on the canvas.\n * Note shapes support rich text formatting, various styling options, and can\n * be used for annotations, reminders, or general text content.\n *\n * @public\n * @example\n * ```ts\n * const noteShape: TLNoteShape = {\n *   id: 'shape:note1',\n *   type: 'note',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     color: 'light-blue',\n *     labelColor: 'black',\n *     size: 's',\n *     font: 'sans',\n *     fontSizeAdjustment: 2,\n *     align: 'start',\n *     verticalAlign: 'start',\n *     growY: 50,\n *     url: 'https://example.com',\n *     richText: toRichText('Important **note**!'),\n *     scale: 1\n *   },\n *   meta: {},\n *   typeName: 'shape'\n * }\n * ```\n */\nexport type TLNoteShape = TLBaseShape<'note', TLNoteShapeProps>\n\n/**\n * Validation schema for note shape properties. Defines the runtime validation rules\n * for all properties of note shapes, ensuring data integrity and type safety.\n *\n * @public\n * @example\n * ```ts\n * import { noteShapeProps } from '@tldraw/tlschema'\n *\n * // Used internally by the validation system\n * const validator = T.object(noteShapeProps)\n * const validatedProps = validator.validate(someNoteProps)\n * ```\n */\nexport const noteShapeProps: RecordProps<TLNoteShape> = {\n\tcolor: DefaultColorStyle,\n\tlabelColor: DefaultLabelColorStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\tfontSizeAdjustment: T.positiveNumber,\n\talign: DefaultHorizontalAlignStyle,\n\tverticalAlign: DefaultVerticalAlignStyle,\n\tgrowY: T.positiveNumber,\n\turl: T.linkUrl,\n\trichText: richTextValidator,\n\tscale: T.nonZeroNumber,\n}\n\nconst Versions = createShapePropsMigrationIds('note', {\n\tAddUrlProp: 1,\n\tRemoveJustify: 2,\n\tMigrateLegacyAlign: 3,\n\tAddVerticalAlign: 4,\n\tMakeUrlsValid: 5,\n\tAddFontSizeAdjustment: 6,\n\tAddScale: 7,\n\tAddLabelColor: 8,\n\tAddRichText: 9,\n})\n\n/**\n * Version identifiers for note shape migrations. These version numbers track\n * significant schema changes over time, enabling proper data migration between versions.\n *\n * @public\n */\nexport { Versions as noteShapeVersions }\n\n/**\n * Migration sequence for note shapes. Handles schema evolution over time by defining\n * how to upgrade and downgrade note shape data between different versions. Includes\n * migrations for URL properties, text alignment changes, vertical alignment addition,\n * font size adjustments, scaling support, label color, and the transition from plain text to rich text.\n *\n * @public\n */\nexport const noteShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MigrateLegacyAlign,\n\t\t\tup: (props) => {\n\t\t\t\tswitch (props.align) {\n\t\t\t\t\tcase 'start':\n\t\t\t\t\t\tprops.align = 'start-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase 'end':\n\t\t\t\t\t\tprops.align = 'end-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprops.align = 'middle-legacy'\n\t\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddVerticalAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.verticalAlign = 'middle'\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddFontSizeAdjustment,\n\t\t\tup: (props) => {\n\t\t\t\tprops.fontSizeAdjustment = 0\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.fontSizeAdjustment\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddScale,\n\t\t\tup: (props) => {\n\t\t\t\tprops.scale = 1\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.scale\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddLabelColor,\n\t\t\tup: (props) => {\n\t\t\t\tprops.labelColor = 'black'\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.labelColor\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddRichText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.richText = toRichText(props.text)\n\t\t\t\tdelete props.text\n\t\t\t},\n\t\t\t// N.B. Explicitly no down state so that we force clients to update.\n\t\t\t// down: (props) => {\n\t\t\t// \tdelete props.richText\n\t\t\t// },\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAqB,mBAAmB,kBAAkB;AAC1D,SAAS,8BAA8B,yCAAyC;AAEhF;AAKA,SAAS,wBAA4C;AACrD;AAIA,SAAS,wBAA4C;AACrD;;;;;;;;;AAyGO,MAAM,iBAA2C;IACvD,OAAO,sMAAA;IACP,YAAY,2MAAA;IACZ,MAAM,oMAAA;IACN,MAAM,oMAAA;IACN,oBAAoB,8MAAA,CAAE,cAAA;IACtB,OAAO,0NAAA;IACP,eAAe,sNAAA;IACf,OAAO,8MAAA,CAAE,cAAA;IACT,KAAK,8MAAA,CAAE,OAAA;IACP,UAAU,kMAAA;IACV,OAAO,8MAAA,CAAE,aAAA;AACV;AAEA,MAAM,eAAW,6MAAA,EAA6B,QAAQ;IACrD,YAAY;IACZ,eAAe;IACf,oBAAoB;IACpB,kBAAkB;IAClB,eAAe;IACf,uBAAuB;IACvB,UAAU;IACV,eAAe;IACf,aAAa;AACd,CAAC;AAkBM,MAAM,0BAAsB,kNAAA,EAAkC;IACpE,UAAU;QACT;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,GAAA,GAAM;YACb;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,MAAM,KAAA,KAAU,WAAW;oBAC9B,MAAM,KAAA,GAAQ;gBACf;YACD;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,kBAAA;YACb,IAAI,CAAC,UAAU;gBACd,OAAQ,MAAM,KAAA,EAAO;oBACpB,KAAK;wBACJ,MAAM,KAAA,GAAQ;wBACd;oBACD,KAAK;wBACJ,MAAM,KAAA,GAAQ;wBACd;oBACD;wBACC,MAAM,KAAA,GAAQ;wBACd;gBACF;YACD;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,gBAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,aAAA,GAAgB;YACvB;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,CAAC,8MAAA,CAAE,OAAA,CAAQ,OAAA,CAAQ,MAAM,GAAG,GAAG;oBAClC,MAAM,GAAA,GAAM;gBACb;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,qBAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,kBAAA,GAAqB;YAC5B;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,kBAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,QAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,KAAA,GAAQ;YACf;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,KAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,UAAA,GAAa;YACpB;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,UAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,QAAA,OAAW,2LAAA,EAAW,MAAM,IAAI;gBACtC,OAAO,MAAM,IAAA;YACd;QAKD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 4506, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/styles/TLTextAlignStyle.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { StyleProp } from './StyleProp'\n\n/**\n * Default text alignment style property used by tldraw text shapes.\n * Controls how text content is aligned within text-based shapes like text boxes and notes.\n *\n * Available values:\n * - `start` - Align text to the start (left in LTR, right in RTL)\n * - `middle` - Center text horizontally\n * - `end` - Align text to the end (right in LTR, left in RTL)\n *\n * @example\n * ```ts\n * import { DefaultTextAlignStyle } from '@tldraw/tlschema'\n *\n * // Use in text shape props definition\n * interface MyTextShapeProps {\n *   textAlign: typeof DefaultTextAlignStyle\n *   // other props...\n * }\n *\n * // Create a text shape with center alignment\n * const textShape = {\n *   // ... other properties\n *   props: {\n *     textAlign: 'middle' as const,\n *     // ... other props\n *   }\n * }\n * ```\n *\n * @public\n */\nexport const DefaultTextAlignStyle = StyleProp.defineEnum('tldraw:textAlign', {\n\tdefaultValue: 'start',\n\tvalues: ['start', 'middle', 'end'],\n})\n\n/**\n * Type representing a default text alignment style value.\n * This is a union type of all available text alignment options.\n *\n * @example\n * ```ts\n * import { TLDefaultTextAlignStyle } from '@tldraw/tlschema'\n *\n * // Valid text alignment values\n * const leftAlign: TLDefaultTextAlignStyle = 'start'\n * const centerAlign: TLDefaultTextAlignStyle = 'middle'\n * const rightAlign: TLDefaultTextAlignStyle = 'end'\n *\n * // Use in a function parameter\n * function setTextAlignment(align: TLDefaultTextAlignStyle) {\n *   // Apply text alignment to text shape\n * }\n * ```\n *\n * @public\n */\nexport type TLDefaultTextAlignStyle = T.TypeOf<typeof DefaultTextAlignStyle>\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAiB;;AAiCnB,MAAM,wBAAwB,2LAAA,CAAU,UAAA,CAAW,oBAAoB;IAC7E,cAAc;IACd,QAAQ;QAAC;QAAS;QAAU,KAAK;KAAA;AAClC,CAAC","debugId":null}},
    {"offset": {"line": 4526, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLTextShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { TLRichText, richTextValidator, toRichText } from '../misc/TLRichText'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { DefaultColorStyle, TLDefaultColorStyle } from '../styles/TLColorStyle'\nimport { DefaultFontStyle, TLDefaultFontStyle } from '../styles/TLFontStyle'\nimport { DefaultSizeStyle, TLDefaultSizeStyle } from '../styles/TLSizeStyle'\nimport { DefaultTextAlignStyle, TLDefaultTextAlignStyle } from '../styles/TLTextAlignStyle'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Configuration interface defining properties for text shapes in tldraw.\n * Text shapes support rich formatting, styling, and automatic sizing.\n *\n * @public\n * @example\n * ```ts\n * const textProps: TLTextShapeProps = {\n *   color: 'black',\n *   size: 'm',\n *   font: 'draw',\n *   textAlign: 'start',\n *   w: 200,\n *   richText: toRichText('Hello **bold** text'),\n *   scale: 1,\n *   autoSize: true\n * }\n * ```\n */\nexport interface TLTextShapeProps {\n\tcolor: TLDefaultColorStyle\n\tsize: TLDefaultSizeStyle\n\tfont: TLDefaultFontStyle\n\ttextAlign: TLDefaultTextAlignStyle\n\tw: number\n\trichText: TLRichText\n\tscale: number\n\tautoSize: boolean\n}\n\n/**\n * A text shape that can display formatted text content with various styling options.\n * Text shapes support rich formatting, automatic sizing, and consistent styling through\n * the tldraw style system.\n *\n * @public\n * @example\n * ```ts\n * const textShape: TLTextShape = {\n *   id: 'shape:text123',\n *   typeName: 'shape',\n *   type: 'text',\n *   x: 100,\n *   y: 200,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     color: 'black',\n *     size: 'm',\n *     font: 'draw',\n *     textAlign: 'start',\n *     w: 200,\n *     richText: toRichText('Sample text'),\n *     scale: 1,\n *     autoSize: false\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLTextShape = TLBaseShape<'text', TLTextShapeProps>\n\n/**\n * Validation schema for text shape properties. This defines the runtime validation\n * rules that ensure text shape data integrity when records are stored or transmitted.\n *\n * @public\n * @example\n * ```ts\n * import { textShapeProps } from '@tldraw/tlschema'\n *\n * // Validate text shape properties\n * const isValid = textShapeProps.richText.isValid(myRichText)\n * if (isValid) {\n *   // Properties are valid, safe to use\n * }\n * ```\n */\nexport const textShapeProps: RecordProps<TLTextShape> = {\n\tcolor: DefaultColorStyle,\n\tsize: DefaultSizeStyle,\n\tfont: DefaultFontStyle,\n\ttextAlign: DefaultTextAlignStyle,\n\tw: T.nonZeroNumber,\n\trichText: richTextValidator,\n\tscale: T.nonZeroNumber,\n\tautoSize: T.boolean,\n}\n\nconst Versions = createShapePropsMigrationIds('text', {\n\tRemoveJustify: 1,\n\tAddTextAlign: 2,\n\tAddRichText: 3,\n})\n\n/**\n * Version identifiers for text shape migrations. These constants track\n * the evolution of the text shape schema over time.\n *\n * @public\n * @example\n * ```ts\n * import { textShapeVersions } from '@tldraw/tlschema'\n *\n * // Check if shape data needs migration\n * if (shapeVersion < textShapeVersions.AddRichText) {\n *   // Apply rich text migration\n * }\n * ```\n */\nexport { Versions as textShapeVersions }\n\n/**\n * Migration sequence for text shape schema evolution. This handles transforming\n * text shape data between different versions as the schema evolves over time.\n *\n * Key migrations include:\n * - RemoveJustify: Replaced 'justify' alignment with 'start'\n * - AddTextAlign: Migrated from 'align' to 'textAlign' property\n * - AddRichText: Converted plain text to rich text format\n *\n * @public\n */\nexport const textShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.RemoveJustify,\n\t\t\tup: (props) => {\n\t\t\t\tif (props.align === 'justify') {\n\t\t\t\t\tprops.align = 'start'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddTextAlign,\n\t\t\tup: (props) => {\n\t\t\t\tprops.textAlign = props.align\n\t\t\t\tdelete props.align\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tprops.align = props.textAlign\n\t\t\t\tdelete props.textAlign\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddRichText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.richText = toRichText(props.text)\n\t\t\t\tdelete props.text\n\t\t\t},\n\t\t\t// N.B. Explicitly no down state so that we force clients to update.\n\t\t\t// down: (props) => {\n\t\t\t// \tdelete props.richText\n\t\t\t// },\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAqB,mBAAmB,kBAAkB;AAC1D,SAAS,8BAA8B,yCAAyC;AAEhF,SAAS,yBAA8C;AACvD,SAAS,wBAA4C;AACrD,SAAS,wBAA4C;AACrD,SAAS,6BAAsD;;;;;;;;AAoFxD,MAAM,iBAA2C;IACvD,OAAO,sMAAA;IACP,MAAM,oMAAA;IACN,MAAM,oMAAA;IACN,WAAW,8MAAA;IACX,GAAG,8MAAA,CAAE,aAAA;IACL,UAAU,kMAAA;IACV,OAAO,8MAAA,CAAE,aAAA;IACT,UAAU,8MAAA,CAAE,OAAA;AACb;AAEA,MAAM,eAAW,6MAAA,EAA6B,QAAQ;IACrD,eAAe;IACf,cAAc;IACd,aAAa;AACd,CAAC;AA8BM,MAAM,0BAAsB,kNAAA,EAAkC;IACpE,UAAU;QACT;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,MAAM,KAAA,KAAU,WAAW;oBAC9B,MAAM,KAAA,GAAQ;gBACf;YACD;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,YAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,SAAA,GAAY,MAAM,KAAA;gBACxB,OAAO,MAAM,KAAA;YACd;YACA,MAAM,CAAC,UAAU;gBAChB,MAAM,KAAA,GAAQ,MAAM,SAAA;gBACpB,OAAO,MAAM,SAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,QAAA,OAAW,2LAAA,EAAW,MAAM,IAAI;gBACtC,OAAO,MAAM,IAAA;YACd;QAKD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 4601, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/shapes/TLVideoShape.ts"],"sourcesContent":["import { T } from '@tldraw/validate'\nimport { assetIdValidator } from '../assets/TLBaseAsset'\nimport { TLAssetId } from '../records/TLAsset'\nimport { createShapePropsMigrationIds, createShapePropsMigrationSequence } from '../records/TLShape'\nimport { RecordProps } from '../recordsWithProps'\nimport { TLBaseShape } from './TLBaseShape'\n\n/**\n * Configuration interface defining properties for video shapes in tldraw.\n * Video shapes can display video content from URLs or asset references,\n * with controls for playback state, timing, and accessibility.\n *\n * @public\n * @example\n * ```ts\n * const videoProps: TLVideoShapeProps = {\n *   w: 640,\n *   h: 480,\n *   time: 0,\n *   playing: false,\n *   autoplay: true,\n *   url: 'https://example.com/video.mp4',\n *   assetId: 'asset:video123',\n *   altText: 'Educational video about shapes'\n * }\n * ```\n */\nexport interface TLVideoShapeProps {\n\tw: number\n\th: number\n\ttime: number\n\tplaying: boolean\n\tautoplay: boolean\n\turl: string\n\tassetId: TLAssetId | null\n\taltText: string\n}\n\n/**\n * A video shape that can display video content with playback controls and timing.\n * Video shapes support both direct URL references and asset-based video storage,\n * with accessibility features and playback state management.\n *\n * @public\n * @example\n * ```ts\n * const videoShape: TLVideoShape = {\n *   id: 'shape:video123',\n *   typeName: 'shape',\n *   type: 'video',\n *   x: 100,\n *   y: 100,\n *   rotation: 0,\n *   index: 'a1',\n *   parentId: 'page:main',\n *   isLocked: false,\n *   opacity: 1,\n *   props: {\n *     w: 640,\n *     h: 480,\n *     time: 15.5,\n *     playing: false,\n *     autoplay: false,\n *     url: 'https://example.com/video.mp4',\n *     assetId: 'asset:video123',\n *     altText: 'Product demo video'\n *   },\n *   meta: {}\n * }\n * ```\n */\nexport type TLVideoShape = TLBaseShape<'video', TLVideoShapeProps>\n\n/**\n * Validation schema for video shape properties. This defines the runtime validation\n * rules that ensure video shape data integrity, including URL validation, numeric\n * constraints, and proper asset ID formatting.\n *\n * @public\n * @example\n * ```ts\n * import { videoShapeProps } from '@tldraw/tlschema'\n *\n * // Validate video URL\n * const isValidUrl = videoShapeProps.url.isValid('https://example.com/video.mp4')\n * const isValidTime = videoShapeProps.time.isValid(42.5)\n *\n * if (isValidUrl && isValidTime) {\n *   // Video properties are valid\n * }\n * ```\n */\nexport const videoShapeProps: RecordProps<TLVideoShape> = {\n\tw: T.nonZeroNumber,\n\th: T.nonZeroNumber,\n\ttime: T.number,\n\tplaying: T.boolean,\n\tautoplay: T.boolean,\n\turl: T.linkUrl,\n\tassetId: assetIdValidator.nullable(),\n\taltText: T.string,\n}\n\nconst Versions = createShapePropsMigrationIds('video', {\n\tAddUrlProp: 1,\n\tMakeUrlsValid: 2,\n\tAddAltText: 3,\n\tAddAutoplay: 4,\n})\n\n/**\n * Version identifiers for video shape migrations. These constants track\n * the evolution of the video shape schema over time.\n *\n * @public\n * @example\n * ```ts\n * import { videoShapeVersions } from '@tldraw/tlschema'\n *\n * // Check if shape data needs migration\n * if (shapeVersion < videoShapeVersions.AddAltText) {\n *   // Apply alt text migration for accessibility\n * }\n * ```\n */\nexport { Versions as videoShapeVersions }\n\n/**\n * Migration sequence for video shape schema evolution. This handles transforming\n * video shape data between different versions as the schema evolves over time.\n *\n * Key migrations include:\n * - AddUrlProp: Added URL property for direct video links\n * - MakeUrlsValid: Ensured all URLs conform to link URL validation\n * - AddAltText: Added accessibility support with alternative text\n * - AddAutoplay: Added autoplay control for video playback\n *\n * @public\n */\nexport const videoShapeMigrations = createShapePropsMigrationSequence({\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.AddUrlProp,\n\t\t\tup: (props) => {\n\t\t\t\tprops.url = ''\n\t\t\t},\n\t\t\tdown: 'retired',\n\t\t},\n\t\t{\n\t\t\tid: Versions.MakeUrlsValid,\n\t\t\tup: (props) => {\n\t\t\t\tif (!T.linkUrl.isValid(props.url)) {\n\t\t\t\t\tprops.url = ''\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: (_props) => {\n\t\t\t\t// noop\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddAltText,\n\t\t\tup: (props) => {\n\t\t\t\tprops.altText = ''\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.altText\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddAutoplay,\n\t\t\tup: (props) => {\n\t\t\t\tprops.autoplay = true\n\t\t\t},\n\t\t\tdown: (props) => {\n\t\t\t\tdelete props.autoplay\n\t\t\t},\n\t\t},\n\t],\n})\n"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,SAAS;AAClB,SAAS,wBAAwB;AAEjC,SAAS,8BAA8B,yCAAyC;;;;AAyFzE,MAAM,kBAA6C;IACzD,GAAG,8MAAA,CAAE,aAAA;IACL,GAAG,8MAAA,CAAE,aAAA;IACL,MAAM,8MAAA,CAAE,MAAA;IACR,SAAS,8MAAA,CAAE,OAAA;IACX,UAAU,8MAAA,CAAE,OAAA;IACZ,KAAK,8MAAA,CAAE,OAAA;IACP,SAAS,oMAAA,CAAiB,QAAA,CAAS;IACnC,SAAS,8MAAA,CAAE,MAAA;AACZ;AAEA,MAAM,eAAW,6MAAA,EAA6B,SAAS;IACtD,YAAY;IACZ,eAAe;IACf,YAAY;IACZ,aAAa;AACd,CAAC;AA+BM,MAAM,2BAAuB,kNAAA,EAAkC;IACrE,UAAU;QACT;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,GAAA,GAAM;YACb;YACA,MAAM;QACP;QACA;YACC,IAAI,SAAS,aAAA;YACb,IAAI,CAAC,UAAU;gBACd,IAAI,CAAC,8MAAA,CAAE,OAAA,CAAQ,OAAA,CAAQ,MAAM,GAAG,GAAG;oBAClC,MAAM,GAAA,GAAM;gBACb;YACD;YACA,MAAM,CAAC,UAEP,CAFkB;QAGnB;QACA;YACC,IAAI,SAAS,UAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,OAAA,GAAU;YACjB;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,OAAA;YACd;QACD;QACA;YACC,IAAI,SAAS,WAAA;YACb,IAAI,CAAC,UAAU;gBACd,MAAM,QAAA,GAAW;YAClB;YACA,MAAM,CAAC,UAAU;gBAChB,OAAO,MAAM,QAAA;YACd;QACD;KACD;AACD,CAAC","debugId":null}},
    {"offset": {"line": 4676, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/store-migrations.ts"],"sourcesContent":["import { createMigrationIds, createMigrationSequence } from '@tldraw/store'\nimport { IndexKey, objectMapEntries } from '@tldraw/utils'\nimport { TLPage } from './records/TLPage'\nimport { TLShape } from './records/TLShape'\nimport { TLLineShape } from './shapes/TLLineShape'\n\n/**\n * Migration version constants for store-level schema changes.\n * Each version represents a breaking change that requires data transformation.\n *\n * @internal\n */\nconst Versions = createMigrationIds('com.tldraw.store', {\n\tRemoveCodeAndIconShapeTypes: 1,\n\tAddInstancePresenceType: 2,\n\tRemoveTLUserAndPresenceAndAddPointer: 3,\n\tRemoveUserDocument: 4,\n\tFixIndexKeys: 5,\n} as const)\n\n/**\n * Migration version identifiers for store-level migrations.\n * These versions track changes to the overall store structure and data model.\n *\n * @example\n * ```ts\n * import { storeVersions } from '@tldraw/tlschema'\n *\n * // Check if a specific migration version exists\n * const hasRemoveCodeShapes = storeVersions.RemoveCodeAndIconShapeTypes\n * ```\n *\n * @public\n */\nexport { Versions as storeVersions }\n\n/**\n * Store-level migration sequence that handles evolution of the tldraw data model.\n * These migrations run when the store schema version changes and ensure backward\n * compatibility by transforming old data structures to new formats.\n *\n * The migrations handle:\n * - Removal of deprecated shape types (code, icon)\n * - Addition of new record types (instance presence)\n * - Cleanup of obsolete user and presence data\n * - Removal of deprecated user document records\n *\n * @example\n * ```ts\n * import { storeMigrations } from '@tldraw/tlschema'\n * import { migrate } from '@tldraw/store'\n *\n * // Apply store migrations to old data\n * const migratedStore = migrate({\n *   store: oldStoreData,\n *   migrations: storeMigrations,\n *   fromVersion: 0,\n *   toVersion: storeMigrations.currentVersion\n * })\n * ```\n *\n * @public\n */\nexport const storeMigrations = createMigrationSequence({\n\tsequenceId: 'com.tldraw.store',\n\tretroactive: false,\n\tsequence: [\n\t\t{\n\t\t\tid: Versions.RemoveCodeAndIconShapeTypes,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\trecord.typeName === 'shape' &&\n\t\t\t\t\t\t((record as TLShape).type === 'icon' || (record as TLShape).type === 'code')\n\t\t\t\t\t) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.AddInstancePresenceType,\n\t\t\tscope: 'store',\n\t\t\tup(_store) {\n\t\t\t\t// noop\n\t\t\t\t// there used to be a down migration for this but we made down migrations optional\n\t\t\t\t// and we don't use them on store-level migrations so we can just remove it\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// remove user and presence records and add pointer records\n\t\t\tid: Versions.RemoveTLUserAndPresenceAndAddPointer,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (record.typeName.match(/^(user|user_presence)$/)) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// remove user document records\n\t\t\tid: Versions.RemoveUserDocument,\n\t\t\tscope: 'store',\n\t\t\tup: (store) => {\n\t\t\t\tfor (const [id, record] of objectMapEntries(store)) {\n\t\t\t\t\tif (record.typeName.match('user_document')) {\n\t\t\t\t\t\tdelete store[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tid: Versions.FixIndexKeys,\n\t\t\tscope: 'record',\n\t\t\tup: (record) => {\n\t\t\t\tif (['shape', 'page'].includes(record.typeName) && 'index' in record) {\n\t\t\t\t\tconst recordWithIndex = record as TLShape | TLPage\n\t\t\t\t\t// Our newer fractional indexed library (more correctly) validates that indices\n\t\t\t\t\t// do not end with 0. ('a0' being an exception)\n\t\t\t\t\tif (recordWithIndex.index.endsWith('0') && recordWithIndex.index !== 'a0') {\n\t\t\t\t\t\trecordWithIndex.index = (recordWithIndex.index.slice(0, -1) +\n\t\t\t\t\t\t\tgetNRandomBase62Digits(3)) as IndexKey\n\t\t\t\t\t}\n\t\t\t\t\t// Line shapes have 'points' that have indices as well.\n\t\t\t\t\tif (record.typeName === 'shape' && (recordWithIndex as TLShape).type === 'line') {\n\t\t\t\t\t\tconst lineShape = recordWithIndex as TLLineShape\n\t\t\t\t\t\tfor (const [_, point] of objectMapEntries(lineShape.props.points)) {\n\t\t\t\t\t\t\tif (point.index.endsWith('0') && point.index !== 'a0') {\n\t\t\t\t\t\t\t\tpoint.index = (point.index.slice(0, -1) + getNRandomBase62Digits(3)) as IndexKey\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdown: () => {\n\t\t\t\t// noop\n\t\t\t\t// Enables tlsync to support older clients so as to not force people to refresh immediately after deploying.\n\t\t\t},\n\t\t},\n\t],\n})\n\nconst BASE_62_DIGITS_WITHOUT_ZERO = '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nconst getRandomBase62Digit = () => {\n\treturn BASE_62_DIGITS_WITHOUT_ZERO.charAt(\n\t\tMath.floor(Math.random() * BASE_62_DIGITS_WITHOUT_ZERO.length)\n\t)\n}\n\nconst getNRandomBase62Digits = (n: number) => {\n\treturn Array.from({ length: n }, getRandomBase62Digit).join('')\n}\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS,oBAAoB,+BAA+B;;AAC5D,SAAmB,wBAAwB;;;AAW3C,MAAM,eAAW,4LAAA,EAAmB,oBAAoB;IACvD,6BAA6B;IAC7B,yBAAyB;IACzB,sCAAsC;IACtC,oBAAoB;IACpB,cAAc;AACf,CAAU;AA6CH,MAAM,sBAAkB,iMAAA,EAAwB;IACtD,YAAY;IACZ,aAAa;IACb,UAAU;QACT;YACC,IAAI,SAAS,2BAAA;YACb,OAAO;YACP,IAAI,CAAC,UAAU;gBACd,KAAA,MAAW,CAAC,IAAI,MAAM,CAAA,QAAK,yLAAA,EAAiB,KAAK,EAAG;oBACnD,IACC,OAAO,QAAA,KAAa,WAAA,CAClB,OAAmB,IAAA,KAAS,UAAW,OAAmB,IAAA,KAAS,MAAA,GACpE;wBACD,OAAO,KAAA,CAAM,EAAE,CAAA;oBAChB;gBACD;YACD;QACD;QACA;YACC,IAAI,SAAS,uBAAA;YACb,OAAO;YACP,IAAG,MAAA,EAAQ,CAIX;QACD;QACA;YAAA,2DAAA;YAEC,IAAI,SAAS,oCAAA;YACb,OAAO;YACP,IAAI,CAAC,UAAU;gBACd,KAAA,MAAW,CAAC,IAAI,MAAM,CAAA,QAAK,yLAAA,EAAiB,KAAK,EAAG;oBACnD,IAAI,OAAO,QAAA,CAAS,KAAA,CAAM,wBAAwB,GAAG;wBACpD,OAAO,KAAA,CAAM,EAAE,CAAA;oBAChB;gBACD;YACD;QACD;QACA;YAAA,+BAAA;YAEC,IAAI,SAAS,kBAAA;YACb,OAAO;YACP,IAAI,CAAC,UAAU;gBACd,KAAA,MAAW,CAAC,IAAI,MAAM,CAAA,QAAK,yLAAA,EAAiB,KAAK,EAAG;oBACnD,IAAI,OAAO,QAAA,CAAS,KAAA,CAAM,eAAe,GAAG;wBAC3C,OAAO,KAAA,CAAM,EAAE,CAAA;oBAChB;gBACD;YACD;QACD;QACA;YACC,IAAI,SAAS,YAAA;YACb,OAAO;YACP,IAAI,CAAC,WAAW;gBACf,IAAI;oBAAC;oBAAS,MAAM;iBAAA,CAAE,QAAA,CAAS,OAAO,QAAQ,KAAK,WAAW,QAAQ;oBACrE,MAAM,kBAAkB;oBAGxB,IAAI,gBAAgB,KAAA,CAAM,QAAA,CAAS,GAAG,KAAK,gBAAgB,KAAA,KAAU,MAAM;wBAC1E,gBAAgB,KAAA,GAAS,gBAAgB,KAAA,CAAM,KAAA,CAAM,GAAG,CAAA,CAAE,IACzD,uBAAuB,CAAC;oBAC1B;oBAEA,IAAI,OAAO,QAAA,KAAa,WAAY,gBAA4B,IAAA,KAAS,QAAQ;wBAChF,MAAM,YAAY;wBAClB,KAAA,MAAW,CAAC,GAAG,KAAK,CAAA,QAAK,yLAAA,EAAiB,UAAU,KAAA,CAAM,MAAM,EAAG;4BAClE,IAAI,MAAM,KAAA,CAAM,QAAA,CAAS,GAAG,KAAK,MAAM,KAAA,KAAU,MAAM;gCACtD,MAAM,KAAA,GAAS,MAAM,KAAA,CAAM,KAAA,CAAM,GAAG,CAAA,CAAE,IAAI,uBAAuB,CAAC;4BACnE;wBACD;oBACD;gBACD;YACD;YACA,MAAM,KAGN,CAHY;QAIb;KACD;AACD,CAAC;AAED,MAAM,8BAA8B;AACpC,MAAM,uBAAuB,MAAM;IAClC,OAAO,4BAA4B,MAAA,CAClC,KAAK,KAAA,CAAM,KAAK,MAAA,CAAO,IAAI,4BAA4B,MAAM;AAE/D;AAEA,MAAM,yBAAyB,CAAC,MAAc;IAC7C,OAAO,MAAM,IAAA,CAAK;QAAE,QAAQ;IAAE,GAAG,oBAAoB,EAAE,IAAA,CAAK,EAAE;AAC/D","debugId":null}},
    {"offset": {"line": 4780, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/createTLSchema.ts"],"sourcesContent":["import { LegacyMigrations, MigrationSequence, StoreSchema, StoreValidator } from '@tldraw/store'\nimport { objectMapValues } from '@tldraw/utils'\nimport { TLStoreProps, createIntegrityChecker, onValidationFailure } from './TLStore'\nimport { bookmarkAssetMigrations } from './assets/TLBookmarkAsset'\nimport { imageAssetMigrations } from './assets/TLImageAsset'\nimport { videoAssetMigrations } from './assets/TLVideoAsset'\nimport { arrowBindingMigrations, arrowBindingProps } from './bindings/TLArrowBinding'\nimport { AssetRecordType, assetMigrations } from './records/TLAsset'\nimport { TLBinding, TLDefaultBinding, createBindingRecordType } from './records/TLBinding'\nimport { CameraRecordType, cameraMigrations } from './records/TLCamera'\nimport { DocumentRecordType, documentMigrations } from './records/TLDocument'\nimport { createInstanceRecordType, instanceMigrations } from './records/TLInstance'\nimport { PageRecordType, pageMigrations } from './records/TLPage'\nimport { InstancePageStateRecordType, instancePageStateMigrations } from './records/TLPageState'\nimport { PointerRecordType, pointerMigrations } from './records/TLPointer'\nimport { InstancePresenceRecordType, instancePresenceMigrations } from './records/TLPresence'\nimport { TLRecord } from './records/TLRecord'\nimport {\n\tTLDefaultShape,\n\tTLShape,\n\tcreateShapeRecordType,\n\tgetShapePropKeysByStyle,\n\trootShapeMigrations,\n} from './records/TLShape'\nimport { TLPropsMigrations, processPropsMigrations } from './recordsWithProps'\nimport { arrowShapeMigrations, arrowShapeProps } from './shapes/TLArrowShape'\nimport { bookmarkShapeMigrations, bookmarkShapeProps } from './shapes/TLBookmarkShape'\nimport { drawShapeMigrations, drawShapeProps } from './shapes/TLDrawShape'\nimport { embedShapeMigrations, embedShapeProps } from './shapes/TLEmbedShape'\nimport { frameShapeMigrations, frameShapeProps } from './shapes/TLFrameShape'\nimport { geoShapeMigrations, geoShapeProps } from './shapes/TLGeoShape'\nimport { groupShapeMigrations, groupShapeProps } from './shapes/TLGroupShape'\nimport { highlightShapeMigrations, highlightShapeProps } from './shapes/TLHighlightShape'\nimport { imageShapeMigrations, imageShapeProps } from './shapes/TLImageShape'\nimport { lineShapeMigrations, lineShapeProps } from './shapes/TLLineShape'\nimport { noteShapeMigrations, noteShapeProps } from './shapes/TLNoteShape'\nimport { textShapeMigrations, textShapeProps } from './shapes/TLTextShape'\nimport { videoShapeMigrations, videoShapeProps } from './shapes/TLVideoShape'\nimport { storeMigrations } from './store-migrations'\nimport { StyleProp } from './styles/StyleProp'\n\n/**\n * Configuration information for a schema type (shape or binding), including its properties,\n * metadata, and migration sequences for data evolution over time.\n *\n * @public\n * @example\n * ```ts\n * import { arrowShapeMigrations, arrowShapeProps } from './shapes/TLArrowShape'\n *\n * const myShapeSchema: SchemaPropsInfo = {\n *   migrations: arrowShapeMigrations,\n *   props: arrowShapeProps,\n *   meta: {\n *     customField: T.string,\n *   },\n * }\n * ```\n */\nexport interface SchemaPropsInfo {\n\t/**\n\t * Migration sequences for handling data evolution over time. Can be legacy migrations,\n\t * props-specific migrations, or general migration sequences.\n\t */\n\tmigrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence\n\n\t/**\n\t * Validation schema for the shape or binding properties. Maps property names to their validators.\n\t */\n\tprops?: Record<string, StoreValidator<any>>\n\n\t/**\n\t * Validation schema for metadata fields. Maps metadata field names to their validators.\n\t */\n\tmeta?: Record<string, StoreValidator<any>>\n}\n\n/**\n * The complete schema definition for a tldraw store, encompassing all record types,\n * validation rules, and migration sequences. This schema defines the structure of\n * the persistent data model used by tldraw.\n *\n * @public\n * @example\n * ```ts\n * import { createTLSchema, defaultShapeSchemas } from '@tldraw/tlschema'\n * import { Store } from '@tldraw/store'\n *\n * const schema: TLSchema = createTLSchema({\n *   shapes: defaultShapeSchemas,\n * })\n *\n * const store = new Store({ schema })\n * ```\n */\nexport type TLSchema = StoreSchema<TLRecord, TLStoreProps>\n\n/**\n * Default shape schema configurations for all built-in tldraw shape types.\n * Each shape type includes its validation props and migration sequences.\n *\n * This object contains schema information for:\n * - arrow: Directional lines that can bind to other shapes\n * - bookmark: Website bookmark cards with preview information\n * - draw: Freehand drawing paths created with drawing tools\n * - embed: Embedded content from external services (YouTube, Figma, etc.)\n * - frame: Container shapes for organizing content\n * - geo: Geometric shapes (rectangles, ellipses, triangles, etc.)\n * - group: Logical groupings of multiple shapes\n * - highlight: Highlighting strokes from the highlighter tool\n * - image: Raster image shapes referencing image assets\n * - line: Multi-point lines and splines\n * - note: Sticky note shapes with text content\n * - text: Rich text shapes with formatting support\n * - video: Video shapes referencing video assets\n *\n * @public\n * @example\n * ```ts\n * import { createTLSchema, defaultShapeSchemas } from '@tldraw/tlschema'\n *\n * // Use all default shapes\n * const schema = createTLSchema({\n *   shapes: defaultShapeSchemas,\n * })\n *\n * // Use only specific default shapes\n * const minimalSchema = createTLSchema({\n *   shapes: {\n *     geo: defaultShapeSchemas.geo,\n *     text: defaultShapeSchemas.text,\n *   },\n * })\n * ```\n */\nexport const defaultShapeSchemas = {\n\tarrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },\n\tbookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },\n\tdraw: { migrations: drawShapeMigrations, props: drawShapeProps },\n\tembed: { migrations: embedShapeMigrations, props: embedShapeProps },\n\tframe: { migrations: frameShapeMigrations, props: frameShapeProps },\n\tgeo: { migrations: geoShapeMigrations, props: geoShapeProps },\n\tgroup: { migrations: groupShapeMigrations, props: groupShapeProps },\n\thighlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },\n\timage: { migrations: imageShapeMigrations, props: imageShapeProps },\n\tline: { migrations: lineShapeMigrations, props: lineShapeProps },\n\tnote: { migrations: noteShapeMigrations, props: noteShapeProps },\n\ttext: { migrations: textShapeMigrations, props: textShapeProps },\n\tvideo: { migrations: videoShapeMigrations, props: videoShapeProps },\n} satisfies { [T in TLDefaultShape['type']]: SchemaPropsInfo }\n\n/**\n * Default binding schema configurations for all built-in tldraw binding types.\n * Bindings represent relationships between shapes, such as arrows connected to shapes.\n *\n * Currently includes:\n * - arrow: Bindings that connect arrow shapes to other shapes at specific anchor points\n *\n * @public\n * @example\n * ```ts\n * import { createTLSchema, defaultBindingSchemas } from '@tldraw/tlschema'\n *\n * // Use default bindings\n * const schema = createTLSchema({\n *   bindings: defaultBindingSchemas,\n * })\n *\n * // Add custom binding alongside defaults\n * const customSchema = createTLSchema({\n *   bindings: {\n *     ...defaultBindingSchemas,\n *     myCustomBinding: {\n *       props: myCustomBindingProps,\n *       migrations: myCustomBindingMigrations,\n *     },\n *   },\n * })\n * ```\n */\nexport const defaultBindingSchemas = {\n\tarrow: { migrations: arrowBindingMigrations, props: arrowBindingProps },\n} satisfies { [T in TLDefaultBinding['type']]: SchemaPropsInfo }\n\n/**\n * Creates a complete TLSchema for use with tldraw stores. This schema defines the structure,\n * validation, and migration sequences for all record types in a tldraw application.\n *\n * The schema includes all core record types (pages, cameras, instances, etc.) plus the\n * shape and binding types you specify. Style properties are automatically collected from\n * all shapes to ensure consistency across the application.\n *\n * @param options - Configuration options for the schema\n *   - shapes - Shape schema configurations. Defaults to defaultShapeSchemas if not provided\n *   - bindings - Binding schema configurations. Defaults to defaultBindingSchemas if not provided\n *   - migrations - Additional migration sequences to include in the schema\n * @returns A complete TLSchema ready for use with Store creation\n *\n * @public\n * @example\n * ```ts\n * import { createTLSchema, defaultShapeSchemas, defaultBindingSchemas } from '@tldraw/tlschema'\n * import { Store } from '@tldraw/store'\n *\n * // Create schema with all default shapes and bindings\n * const schema = createTLSchema()\n *\n * // Create schema with custom shapes added\n * const customSchema = createTLSchema({\n *   shapes: {\n *     ...defaultShapeSchemas,\n *     myCustomShape: {\n *       props: myCustomShapeProps,\n *       migrations: myCustomShapeMigrations,\n *     },\n *   },\n * })\n *\n * // Create schema with only specific shapes\n * const minimalSchema = createTLSchema({\n *   shapes: {\n *     geo: defaultShapeSchemas.geo,\n *     text: defaultShapeSchemas.text,\n *   },\n *   bindings: defaultBindingSchemas,\n * })\n *\n * // Use the schema with a store\n * const store = new Store({\n *   schema: customSchema,\n *   props: {\n *     defaultName: 'My Drawing',\n *   },\n * })\n * ```\n */\nexport function createTLSchema({\n\tshapes = defaultShapeSchemas,\n\tbindings = defaultBindingSchemas,\n\tmigrations,\n}: {\n\tshapes?: Record<string, SchemaPropsInfo>\n\tbindings?: Record<string, SchemaPropsInfo>\n\tmigrations?: readonly MigrationSequence[]\n} = {}): TLSchema {\n\tconst stylesById = new Map<string, StyleProp<unknown>>()\n\tfor (const shape of objectMapValues(shapes)) {\n\t\tfor (const style of getShapePropKeysByStyle(shape.props ?? {}).keys()) {\n\t\t\tif (stylesById.has(style.id) && stylesById.get(style.id) !== style) {\n\t\t\t\tthrow new Error(`Multiple StyleProp instances with the same id: ${style.id}`)\n\t\t\t}\n\t\t\tstylesById.set(style.id, style)\n\t\t}\n\t}\n\n\tconst ShapeRecordType = createShapeRecordType(shapes)\n\tconst BindingRecordType = createBindingRecordType(bindings)\n\tconst InstanceRecordType = createInstanceRecordType(stylesById)\n\n\treturn StoreSchema.create(\n\t\t{\n\t\t\tasset: AssetRecordType,\n\t\t\tbinding: BindingRecordType,\n\t\t\tcamera: CameraRecordType,\n\t\t\tdocument: DocumentRecordType,\n\t\t\tinstance: InstanceRecordType,\n\t\t\tinstance_page_state: InstancePageStateRecordType,\n\t\t\tpage: PageRecordType,\n\t\t\tinstance_presence: InstancePresenceRecordType,\n\t\t\tpointer: PointerRecordType,\n\t\t\tshape: ShapeRecordType,\n\t\t},\n\t\t{\n\t\t\tmigrations: [\n\t\t\t\tstoreMigrations,\n\t\t\t\tassetMigrations,\n\t\t\t\tcameraMigrations,\n\t\t\t\tdocumentMigrations,\n\t\t\t\tinstanceMigrations,\n\t\t\t\tinstancePageStateMigrations,\n\t\t\t\tpageMigrations,\n\t\t\t\tinstancePresenceMigrations,\n\t\t\t\tpointerMigrations,\n\t\t\t\trootShapeMigrations,\n\n\t\t\t\tbookmarkAssetMigrations,\n\t\t\t\timageAssetMigrations,\n\t\t\t\tvideoAssetMigrations,\n\n\t\t\t\t...processPropsMigrations<TLShape>('shape', shapes),\n\t\t\t\t...processPropsMigrations<TLBinding>('binding', bindings),\n\n\t\t\t\t...(migrations ?? []),\n\t\t\t],\n\t\t\tonValidationFailure,\n\t\t\tcreateIntegrityChecker,\n\t\t}\n\t)\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4967, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/misc/TLHandle.ts"],"sourcesContent":["import { IndexKey } from '@tldraw/utils'\nimport { SetValue } from '../util-types'\n\n/**\n * All available handle types used by shapes in the tldraw editor.\n *\n * Handles are interactive control points on shapes that allow users to\n * modify the shape's geometry. Different handle types serve different purposes:\n *\n * - `vertex`: A control point that defines a vertex of the shape\n * - `virtual`: A handle that exists between vertices for adding new points\n * - `create`: A handle for creating new geometry (like extending a line)\n * - `clone`: A handle for duplicating or cloning shape elements\n *\n * @example\n * ```ts\n * // Check if a handle type is valid\n * if (TL_HANDLE_TYPES.has('vertex')) {\n *   console.log('Valid handle type')\n * }\n *\n * // Get all available handle types\n * const allHandleTypes = Array.from(TL_HANDLE_TYPES)\n * ```\n *\n * @public\n */\nexport const TL_HANDLE_TYPES = new Set(['vertex', 'virtual', 'create', 'clone'] as const)\n\n/**\n * A union type representing all available handle types.\n *\n * Handle types determine how a handle behaves when interacted with and\n * what kind of shape modification it enables.\n *\n * @example\n * ```ts\n * const vertexHandle: TLHandleType = 'vertex'\n * const virtualHandle: TLHandleType = 'virtual'\n * const createHandle: TLHandleType = 'create'\n * const cloneHandle: TLHandleType = 'clone'\n * ```\n *\n * @public\n */\nexport type TLHandleType = SetValue<typeof TL_HANDLE_TYPES>\n\n/**\n * A handle object representing an interactive control point on a shape.\n *\n * Handles allow users to manipulate shape geometry by dragging control points.\n * Each handle has a position, type, and various properties that control its\n * behavior during interactions.\n *\n * @example\n * ```ts\n * // A vertex handle for a line endpoint\n * const lineEndHandle: TLHandle = {\n *   id: 'end',\n *   label: 'End point',\n *   type: 'vertex',\n *   canSnap: true,\n *   index: 'a1',\n *   x: 100,\n *   y: 50\n * }\n *\n * // A virtual handle for adding new points\n * const virtualHandle: TLHandle = {\n *   id: 'virtual-1',\n *   type: 'virtual',\n *   canSnap: false,\n *   index: 'a1V',\n *   x: 75,\n *   y: 25\n * }\n *\n * // A create handle for extending geometry\n * const createHandle: TLHandle = {\n *   id: 'create',\n *   type: 'create',\n *   canSnap: true,\n *   index: 'a2',\n *   x: 200,\n *   y: 100\n * }\n * ```\n *\n * @public\n */\nexport interface TLHandle {\n\t/** A unique identifier for the handle within the shape */\n\tid: string\n\t/** Optional human-readable label for the handle */\n\t// TODO(mime): this needs to be required.\n\tlabel?: string\n\t/** The type of handle, determining its behavior and interaction mode */\n\ttype: TLHandleType\n\t/**\n\t * @deprecated Use `snapType` instead. Whether this handle should snap to other geometry during interactions.\n\t */\n\tcanSnap?: boolean\n\t/** The type of snap to use for this handle */\n\tsnapType?: 'point' | 'align'\n\t/** The fractional index used for ordering handles */\n\tindex: IndexKey\n\t/** The x-coordinate of the handle in the shape's local coordinate system */\n\tx: number\n\t/** The y-coordinate of the handle in the shape's local coordinate system */\n\ty: number\n}\n"],"names":[],"mappings":";;;;AA2BO,MAAM,kBAAkB,aAAA,GAAA,IAAI,IAAI;IAAC;IAAU;IAAW;IAAU,OAAO;CAAU","debugId":null}},
    {"offset": {"line": 4983, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/translations/languages.ts"],"sourcesContent":["// This file is automatically generated by internal/scripts/refresh-assets.ts.\n// Do not edit manually. Or do, I'm a comment, not a cop.\n\n/** @public */\nexport const LANGUAGES = [\n\t{ locale: 'id', label: 'Bahasa Indonesia' },\n\t{ locale: 'ms', label: 'Bahasa Melayu' },\n\t{ locale: 'ca', label: 'Catal\u00E0' },\n\t{ locale: 'cs', label: '\u010Ce\u0161tina' },\n\t{ locale: 'da', label: 'Danish' },\n\t{ locale: 'de', label: 'Deutsch' },\n\t{ locale: 'en', label: 'English' },\n\t{ locale: 'es', label: 'Espa\u00F1ol' },\n\t{ locale: 'tl', label: 'Filipino' },\n\t{ locale: 'fr', label: 'Fran\u00E7ais' },\n\t{ locale: 'gl', label: 'Galego' },\n\t{ locale: 'hr', label: 'Hrvatski' },\n\t{ locale: 'it', label: 'Italiano' },\n\t{ locale: 'hu', label: 'Magyar' },\n\t{ locale: 'nl', label: 'Nederlands' },\n\t{ locale: 'no', label: 'Norwegian' },\n\t{ locale: 'pl', label: 'Polski' },\n\t{ locale: 'pt-br', label: 'Portugu\u00EAs - Brasil' },\n\t{ locale: 'pt-pt', label: 'Portugu\u00EAs - Europeu' },\n\t{ locale: 'ro', label: 'Rom\u00E2n\u0103' },\n\t{ locale: 'sl', label: 'Sloven\u0161\u010Dina' },\n\t{ locale: 'so', label: 'Somali' },\n\t{ locale: 'fi', label: 'Suomi' },\n\t{ locale: 'sv', label: 'Svenska' },\n\t{ locale: 'vi', label: 'Ti\u1EBFng Vi\u1EC7t' },\n\t{ locale: 'tr', label: 'T\u00FCrk\u00E7e' },\n\t{ locale: 'el', label: '\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC' },\n\t{ locale: 'ru', label: '\u0420\u0443\u0441\u0441\u043A\u0438\u0439' },\n\t{ locale: 'uk', label: '\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430' },\n\t{ locale: 'he', label: '\u05E2\u05D1\u05E8\u05D9\u05EA' },\n\t{ locale: 'ur', label: '\u0627\u0631\u062F\u0648' },\n\t{ locale: 'ar', label: '\u0639\u0631\u0628\u064A' },\n\t{ locale: 'fa', label: '\u0641\u0627\u0631\u0633\u06CC' },\n\t{ locale: 'ne', label: '\u0928\u0947\u092A\u093E\u0932\u0940' },\n\t{ locale: 'mr', label: '\u092E\u0930\u093E\u0920\u0940' },\n\t{ locale: 'hi-in', label: '\u0939\u093F\u0928\u094D\u0926\u0940' },\n\t{ locale: 'bn', label: '\u09AC\u09BE\u0982\u09B2\u09BE' },\n\t{ locale: 'pa', label: '\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40' },\n\t{ locale: 'gu-in', label: '\u0A97\u0AC1\u0A9C\u0AB0\u0ABE\u0AA4\u0AC0' },\n\t{ locale: 'ta', label: '\u0BA4\u0BAE\u0BBF\u0BB4\u0BCD' },\n\t{ locale: 'te', label: '\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41' },\n\t{ locale: 'kn', label: '\u0C95\u0CA8\u0CCD\u0CA8\u0CA1' },\n\t{ locale: 'ml', label: '\u0D2E\u0D32\u0D2F\u0D3E\u0D33\u0D02' },\n\t{ locale: 'th', label: '\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22' },\n\t{ locale: 'km-kh', label: '\u1797\u17B6\u179F\u17B6\u1781\u17D2\u1798\u17C2\u179A' },\n\t{ locale: 'ko-kr', label: '\uD55C\uAD6D\uC5B4' },\n\t{ locale: 'ja', label: '\u65E5\u672C\u8A9E' },\n\t{ locale: 'zh-cn', label: '\u7B80\u4F53\u4E2D\u6587' },\n\t{ locale: 'zh-tw', label: '\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)' },\n] as const\n"],"names":[],"mappings":";;;;AAIO,MAAM,YAAY;IACxB;QAAE,QAAQ;QAAM,OAAO;IAAmB;IAC1C;QAAE,QAAQ;QAAM,OAAO;IAAgB;IACvC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAW;IAClC;QAAE,QAAQ;QAAM,OAAO;IAAW;IAClC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAW;IAClC;QAAE,QAAQ;QAAM,OAAO;IAAW;IAClC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAa;IACpC;QAAE,QAAQ;QAAM,OAAO;IAAY;IACnC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAS,OAAO;IAAqB;IAC/C;QAAE,QAAQ;QAAS,OAAO;IAAsB;IAChD;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAc;IACrC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAa;IACpC;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAW;IAClC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAM,OAAO;IAAa;IACpC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAO;IAC9B;QAAE,QAAQ;QAAM,OAAO;IAAO;IAC9B;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAS,OAAO;IAAS;IACnC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAS,OAAO;IAAU;IACpC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAQ;IAC/B;QAAE,QAAQ;QAAM,OAAO;IAAS;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAU;IACjC;QAAE,QAAQ;QAAS,OAAO;IAAY;IACtC;QAAE,QAAQ;QAAS,OAAO;IAAM;IAChC;QAAE,QAAQ;QAAM,OAAO;IAAM;IAC7B;QAAE,QAAQ;QAAS,OAAO;IAAO;IACjC;QAAE,QAAQ;QAAS,OAAO;IAAY;CACvC","debugId":null}},
    {"offset": {"line": 5191, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/translations/translations.ts"],"sourcesContent":["import { LANGUAGES } from './languages'\n\n/** @public */\nexport { LANGUAGES }\n\n/**\n * A language definition object representing a supported localization in tldraw.\n *\n * Derived from the LANGUAGES array, this type represents a single language entry\n * containing a locale identifier and human-readable label. The locale follows\n * BCP 47 standards (e.g., 'en', 'fr', 'zh-CN') and the label is in the native language.\n *\n * @example\n * ```ts\n * import { TLLanguage } from '@tldraw/tlschema'\n *\n * // Using TLLanguage type\n * const currentLanguage: TLLanguage = { locale: 'fr', label: 'Fran\u00E7ais' }\n *\n * // Access locale and label\n * console.log(currentLanguage.locale) // \"fr\"\n * console.log(currentLanguage.label)  // \"Fran\u00E7ais\"\n * ```\n *\n * @public\n */\nexport type TLLanguage = (typeof LANGUAGES)[number]\n\n/**\n * Gets the default translation locale based on the user's browser language preferences.\n *\n * This function determines the best matching locale from the user's browser language\n * settings, falling back to English if no suitable match is found. It works in both\n * browser and server-side environments, defaulting to English on the server.\n *\n * The function prioritizes exact matches first, then falls back to language-only\n * matches, and finally uses predefined regional defaults for languages like Chinese,\n * Portuguese, Korean, and Hindi.\n *\n * @returns The locale identifier (e.g., 'en', 'fr', 'zh-cn') that best matches the user's preferences\n *\n * @example\n * ```ts\n * import { getDefaultTranslationLocale } from '@tldraw/tlschema'\n *\n * // Get the user's preferred locale\n * const locale = getDefaultTranslationLocale()\n * console.log(locale) // e.g., \"fr\" or \"en\" or \"zh-cn\"\n *\n * // Use in localization setup\n * const i18n = new I18n({\n *   locale,\n *   // ... other config\n * })\n * ```\n *\n * @example\n * ```ts\n * // Browser with languages: ['fr-CA', 'en-US']\n * const locale = getDefaultTranslationLocale()\n * console.log(locale) // \"fr\" (if French is supported)\n *\n * // Browser with languages: ['zh']\n * const locale = getDefaultTranslationLocale()\n * console.log(locale) // \"zh-cn\" (default region for Chinese)\n * ```\n *\n * @public\n */\nexport function getDefaultTranslationLocale(): TLLanguage['locale'] {\n\tconst locales =\n\t\ttypeof window !== 'undefined' && window.navigator\n\t\t\t? (window.navigator.languages ?? ['en'])\n\t\t\t: ['en']\n\treturn _getDefaultTranslationLocale(locales)\n}\n\n/**\n * Internal function that determines the default translation locale from a list of locale preferences.\n *\n * This function is the core logic for locale resolution, separated from browser-specific code\n * for easier testing and reuse. It iterates through the provided locales in priority order\n * and returns the first supported locale found, or 'en' as the ultimate fallback.\n *\n * @param locales - Array of locale identifiers in preference order (e.g., from navigator.languages)\n * @returns The best matching supported locale identifier\n *\n * @example\n * ```ts\n *\n * // Test locale resolution\n * const locale = _getDefaultTranslationLocale(['fr-CA', 'en-US', 'es'])\n * console.log(locale) // \"fr\" (if French is supported)\n *\n * // No supported locales\n * const fallback = _getDefaultTranslationLocale(['xx-YY', 'zz-AA'])\n * console.log(fallback) // \"en\"\n * ```\n *\n * @internal\n */\nexport function _getDefaultTranslationLocale(locales: readonly string[]): TLLanguage['locale'] {\n\tfor (const locale of locales) {\n\t\tconst supportedLocale = getSupportedLocale(locale)\n\t\tif (supportedLocale) {\n\t\t\treturn supportedLocale\n\t\t}\n\t}\n\treturn 'en'\n}\n\n/**\n * Default regional variants for languages that have multiple regional versions.\n *\n * When a user's locale contains only a language code (e.g., 'zh', 'pt') but tldraw\n * only supports region-specific variants, this mapping determines which regional\n * variant to use as the default. This ensures users get the most appropriate\n * localization even when their preference doesn't specify a region.\n *\n *\n * @example\n * ```ts\n * // User has locale preference \"zh\" but we only support \"zh-cn\" and \"zh-tw\"\n * const defaultRegion = DEFAULT_LOCALE_REGIONS['zh']\n * console.log(defaultRegion) // \"zh-cn\"\n *\n * // User has locale preference \"pt\" but we support \"pt-br\" and \"pt-pt\"\n * const defaultRegion = DEFAULT_LOCALE_REGIONS['pt']\n * console.log(defaultRegion) // \"pt-br\"\n * ```\n *\n * @public\n */\nconst DEFAULT_LOCALE_REGIONS: { [locale: string]: TLLanguage['locale'] } = {\n\tzh: 'zh-cn',\n\tpt: 'pt-br',\n\tko: 'ko-kr',\n\thi: 'hi-in',\n}\n\n/**\n * Finds a supported locale that matches the given locale identifier.\n *\n * This function implements a flexible locale matching algorithm that tries multiple\n * strategies to find the best available translation:\n *\n * 1. **Exact match**: Looks for an exact locale match (case-insensitive)\n * 2. **Language-only match**: If the input has a region, tries matching just the language\n * 3. **Default region**: If the input lacks a region, uses the default region for that language\n * 4. **No match**: Returns null if no suitable locale is found\n *\n * @param locale - The locale identifier to match (e.g., 'fr-CA', 'pt', 'zh-TW')\n * @returns The matching supported locale identifier, or null if no match is found\n *\n * @example\n * ```ts\n * // Exact matches\n * getSupportedLocale('fr') // \"fr\" (if supported)\n * getSupportedLocale('PT-BR') // \"pt-br\" (case insensitive)\n *\n * // Language-only fallback\n * getSupportedLocale('fr-CA') // \"fr\" (if we only support generic French)\n *\n * // Default region assignment\n * getSupportedLocale('zh') // \"zh-cn\" (default Chinese region)\n *\n * // No match\n * getSupportedLocale('xyz') // null\n * ```\n *\n * @example\n * ```ts\n * // Usage in locale resolution\n * const userLocales = ['es-MX', 'en-US']\n * for (const userLocale of userLocales) {\n *   const supported = getSupportedLocale(userLocale)\n *   if (supported) {\n *     console.log(`Using locale: ${supported}`)\n *     break\n *   }\n * }\n * ```\n *\n * @public\n */\nfunction getSupportedLocale(locale: string): TLLanguage['locale'] | null {\n\t// If we have an exact match, return it!\n\t// (e.g. if the user has 'fr' and we have 'fr')\n\t// (or if the user has 'pt-BR' and we have 'pt-br')\n\tconst exactMatch = LANGUAGES.find((t) => t.locale === locale.toLowerCase())\n\tif (exactMatch) {\n\t\treturn exactMatch.locale\n\t}\n\n\t// Otherwise, we need to be more flexible...\n\tconst [language, region] = locale.split(/[-_]/).map((s) => s.toLowerCase())\n\n\t// If the user's language has a region...\n\t// let's try to find non-region-specific locale for them\n\t// (e.g. if they have 'fr-CA' but we only have 'fr')\n\tif (region) {\n\t\tconst languageMatch = LANGUAGES.find((t) => t.locale === language)\n\t\tif (languageMatch) {\n\t\t\treturn languageMatch.locale\n\t\t}\n\t}\n\n\t// If the user's language doesn't have a region...\n\t// let's try to find a region-specific locale for them\n\t// (e.g. if they have 'pt' but we only have 'pt-pt' or 'pt-br')\n\t//\n\t// In this case, we choose the hard-coded default region for that language\n\tif (language in DEFAULT_LOCALE_REGIONS) {\n\t\treturn DEFAULT_LOCALE_REGIONS[language]\n\t}\n\n\t// Oh no! We don't have a translation for this language!\n\t// Let's give up...\n\treturn null\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,iBAAiB;;AAqEnB,SAAS,8BAAoD;IACnE,MAAM,UACL,OAAO,WAAW,eAAe,OAAO,SAAA,GACpC,OAAO,SAAA,CAAU,SAAA,IAAa;QAAC,IAAI;KAAA,GACpC;QAAC,IAAI;KAAA;IACT,OAAO,6BAA6B,OAAO;AAC5C;AA0BO,SAAS,6BAA6B,OAAA,EAAkD;IAC9F,KAAA,MAAW,UAAU,QAAS;QAC7B,MAAM,kBAAkB,mBAAmB,MAAM;QACjD,IAAI,iBAAiB;YACpB,OAAO;QACR;IACD;IACA,OAAO;AACR;AAwBA,MAAM,yBAAqE;IAC1E,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;AACL;AA+CA,SAAS,mBAAmB,MAAA,EAA6C;IAIxE,MAAM,aAAa,iMAAA,CAAU,IAAA,CAAK,CAAC,IAAM,EAAE,MAAA,KAAW,OAAO,WAAA,CAAY,CAAC;IAC1E,IAAI,YAAY;QACf,OAAO,WAAW,MAAA;IACnB;IAGA,MAAM,CAAC,UAAU,MAAM,CAAA,GAAI,OAAO,KAAA,CAAM,MAAM,EAAE,GAAA,CAAI,CAAC,IAAM,EAAE,WAAA,CAAY,CAAC;IAK1E,IAAI,QAAQ;QACX,MAAM,gBAAgB,iMAAA,CAAU,IAAA,CAAK,CAAC,IAAM,EAAE,MAAA,KAAW,QAAQ;QACjE,IAAI,eAAe;YAClB,OAAO,cAAc,MAAA;QACtB;IACD;IAOA,IAAI,YAAY,wBAAwB;QACvC,OAAO,sBAAA,CAAuB,QAAQ,CAAA;IACvC;IAIA,OAAO;AACR","debugId":null}},
    {"offset": {"line": 5245, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/tlschema/src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n * Main entry point for the tldraw schema package. Exports the complete type system,\n * data structures, validation, and migrations for tldraw's persisted data.\n *\n * This package provides:\n * - Schema creation utilities (createTLSchema, defaultShapeSchemas, defaultBindingSchemas)\n * - All built-in shape types (TLGeoShape, TLTextShape, TLArrowShape, etc.)\n * - Asset management types and validators (TLImageAsset, TLVideoAsset, TLBookmarkAsset)\n * - Binding system for shape relationships (TLArrowBinding)\n * - Store integration types (TLStore, TLStoreProps, TLStoreSnapshot)\n * - Style properties for consistent styling (DefaultColorStyle, DefaultSizeStyle, etc.)\n * - Validation utilities and type guards\n * - Migration systems for schema evolution\n * - Geometry and utility types\n *\n * @example\n * ```ts\n * import { createTLSchema, defaultShapeSchemas, TLStore } from '@tldraw/tlschema'\n *\n * // Create a schema with default shapes\n * const schema = createTLSchema({\n *   shapes: defaultShapeSchemas\n * })\n *\n * // Use with a store\n * const store = new Store({ schema })\n * ```\n *\n * @public\n */\n\nimport { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { assetIdValidator, createAssetValidator, type TLBaseAsset } from './assets/TLBaseAsset'\nexport { type TLBookmarkAsset } from './assets/TLBookmarkAsset'\nexport { type TLImageAsset } from './assets/TLImageAsset'\nexport { type TLVideoAsset } from './assets/TLVideoAsset'\nexport {\n\tarrowBindingMigrations,\n\tarrowBindingProps,\n\tarrowBindingVersions,\n\tElbowArrowSnap,\n\ttype TLArrowBinding,\n\ttype TLArrowBindingProps,\n} from './bindings/TLArrowBinding'\nexport {\n\tbindingIdValidator,\n\tcreateBindingValidator,\n\ttype TLBaseBinding,\n} from './bindings/TLBaseBinding'\nexport {\n\tcreatePresenceStateDerivation,\n\tgetDefaultUserPresence,\n\ttype TLPresenceStateInfo,\n\ttype TLPresenceUserInfo,\n} from './createPresenceStateDerivation'\nexport {\n\tcreateTLSchema,\n\tdefaultBindingSchemas,\n\tdefaultShapeSchemas,\n\ttype SchemaPropsInfo,\n\ttype TLSchema,\n} from './createTLSchema'\nexport {\n\tboxModelValidator,\n\tvecModelValidator,\n\ttype BoxModel,\n\ttype VecModel,\n} from './misc/geometry-types'\nexport { idValidator } from './misc/id-validator'\nexport {\n\tcanvasUiColorTypeValidator,\n\tTL_CANVAS_UI_COLOR_TYPES,\n\ttype TLCanvasUiColor,\n} from './misc/TLColor'\nexport { TL_CURSOR_TYPES, type TLCursor, type TLCursorType } from './misc/TLCursor'\nexport { TL_HANDLE_TYPES, type TLHandle, type TLHandleType } from './misc/TLHandle'\nexport { opacityValidator, type TLOpacityType } from './misc/TLOpacity'\nexport { richTextValidator, toRichText, type TLRichText } from './misc/TLRichText'\nexport { scribbleValidator, TL_SCRIBBLE_STATES, type TLScribble } from './misc/TLScribble'\nexport {\n\tassetMigrations,\n\tAssetRecordType,\n\tassetValidator,\n\ttype TLAsset,\n\ttype TLAssetId,\n\ttype TLAssetPartial,\n\ttype TLAssetShape,\n} from './records/TLAsset'\nexport {\n\tcreateBindingId,\n\tcreateBindingPropsMigrationIds,\n\tcreateBindingPropsMigrationSequence,\n\tisBinding,\n\tisBindingId,\n\trootBindingMigrations,\n\ttype TLBinding,\n\ttype TLBindingCreate,\n\ttype TLBindingId,\n\ttype TLBindingUpdate,\n\ttype TLDefaultBinding,\n\ttype TLUnknownBinding,\n} from './records/TLBinding'\nexport { CameraRecordType, type TLCamera, type TLCameraId } from './records/TLCamera'\nexport {\n\tDocumentRecordType,\n\tisDocument,\n\tTLDOCUMENT_ID,\n\ttype TLDocument,\n} from './records/TLDocument'\nexport {\n\tpluckPreservingValues,\n\tTLINSTANCE_ID,\n\ttype TLInstance,\n\ttype TLInstanceId,\n} from './records/TLInstance'\nexport {\n\tisPageId,\n\tpageIdValidator,\n\tPageRecordType,\n\ttype TLPage,\n\ttype TLPageId,\n} from './records/TLPage'\nexport {\n\tInstancePageStateRecordType,\n\ttype TLInstancePageState,\n\ttype TLInstancePageStateId,\n} from './records/TLPageState'\nexport {\n\tPointerRecordType,\n\tTLPOINTER_ID,\n\ttype TLPointer,\n\ttype TLPointerId,\n} from './records/TLPointer'\nexport {\n\tInstancePresenceRecordType,\n\ttype TLInstancePresence,\n\ttype TLInstancePresenceID,\n} from './records/TLPresence'\nexport { type TLRecord } from './records/TLRecord'\nexport {\n\tcreateShapeId,\n\tcreateShapePropsMigrationIds,\n\tcreateShapePropsMigrationSequence,\n\tgetShapePropKeysByStyle,\n\tisShape,\n\tisShapeId,\n\trootShapeMigrations,\n\ttype TLDefaultShape,\n\ttype TLParentId,\n\ttype TLShape,\n\ttype TLShapeId,\n\ttype TLShapePartial,\n\ttype TLUnknownShape,\n} from './records/TLShape'\nexport {\n\ttype RecordProps,\n\ttype RecordPropsType,\n\ttype TLPropsMigration,\n\ttype TLPropsMigrations,\n} from './recordsWithProps'\nexport { type ShapeWithCrop, type TLShapeCrop } from './shapes/ShapeWithCrop'\nexport {\n\tArrowShapeArrowheadEndStyle,\n\tArrowShapeArrowheadStartStyle,\n\tArrowShapeKindStyle,\n\tarrowShapeMigrations,\n\tarrowShapeProps,\n\tarrowShapeVersions,\n\ttype TLArrowShape,\n\ttype TLArrowShapeArrowheadStyle,\n\ttype TLArrowShapeKind,\n\ttype TLArrowShapeProps,\n} from './shapes/TLArrowShape'\nexport {\n\tcreateShapeValidator,\n\tparentIdValidator,\n\tshapeIdValidator,\n\ttype TLBaseShape,\n} from './shapes/TLBaseShape'\nexport {\n\tbookmarkShapeMigrations,\n\tbookmarkShapeProps,\n\ttype TLBookmarkShape,\n\ttype TLBookmarkShapeProps,\n} from './shapes/TLBookmarkShape'\nexport {\n\tdrawShapeMigrations,\n\tdrawShapeProps,\n\ttype TLDrawShape,\n\ttype TLDrawShapeProps,\n\ttype TLDrawShapeSegment,\n} from './shapes/TLDrawShape'\nexport {\n\tembedShapeMigrations,\n\tembedShapeProps,\n\ttype TLEmbedShape,\n\ttype TLEmbedShapeProps,\n} from './shapes/TLEmbedShape'\nexport {\n\tframeShapeMigrations,\n\tframeShapeProps,\n\ttype TLFrameShape,\n\ttype TLFrameShapeProps,\n} from './shapes/TLFrameShape'\nexport {\n\tGeoShapeGeoStyle,\n\tgeoShapeMigrations,\n\tgeoShapeProps,\n\ttype TLGeoShape,\n\ttype TLGeoShapeGeoStyle,\n\ttype TLGeoShapeProps,\n} from './shapes/TLGeoShape'\nexport {\n\tgroupShapeMigrations,\n\tgroupShapeProps,\n\ttype TLGroupShape,\n\ttype TLGroupShapeProps,\n} from './shapes/TLGroupShape'\nexport {\n\thighlightShapeMigrations,\n\thighlightShapeProps,\n\ttype TLHighlightShape,\n\ttype TLHighlightShapeProps,\n} from './shapes/TLHighlightShape'\nexport {\n\tImageShapeCrop,\n\timageShapeMigrations,\n\timageShapeProps,\n\ttype TLImageShape,\n\ttype TLImageShapeProps,\n} from './shapes/TLImageShape'\nexport {\n\tlineShapeMigrations,\n\tlineShapeProps,\n\tLineShapeSplineStyle,\n\ttype TLLineShape,\n\ttype TLLineShapePoint,\n\ttype TLLineShapeProps,\n\ttype TLLineShapeSplineStyle,\n} from './shapes/TLLineShape'\nexport {\n\tnoteShapeMigrations,\n\tnoteShapeProps,\n\ttype TLNoteShape,\n\ttype TLNoteShapeProps,\n} from './shapes/TLNoteShape'\nexport {\n\ttextShapeMigrations,\n\ttextShapeProps,\n\ttype TLTextShape,\n\ttype TLTextShapeProps,\n} from './shapes/TLTextShape'\nexport {\n\tvideoShapeMigrations,\n\tvideoShapeProps,\n\ttype TLVideoShape,\n\ttype TLVideoShapeProps,\n} from './shapes/TLVideoShape'\nexport { EnumStyleProp, StyleProp, type StylePropValue } from './styles/StyleProp'\nexport {\n\tdefaultColorNames,\n\tDefaultColorStyle,\n\tDefaultColorThemePalette,\n\tgetColorValue,\n\tgetDefaultColorTheme,\n\ttype TLDefaultColorStyle,\n\ttype TLDefaultColorTheme,\n\ttype TLDefaultColorThemeColor,\n} from './styles/TLColorStyle'\nexport { DefaultDashStyle, type TLDefaultDashStyle } from './styles/TLDashStyle'\nexport { DefaultFillStyle, type TLDefaultFillStyle } from './styles/TLFillStyle'\nexport {\n\tDefaultFontFamilies,\n\tDefaultFontStyle,\n\ttype TLDefaultFontStyle,\n} from './styles/TLFontStyle'\nexport {\n\tDefaultHorizontalAlignStyle,\n\ttype TLDefaultHorizontalAlignStyle,\n} from './styles/TLHorizontalAlignStyle'\nexport { DefaultSizeStyle, type TLDefaultSizeStyle } from './styles/TLSizeStyle'\nexport { DefaultTextAlignStyle, type TLDefaultTextAlignStyle } from './styles/TLTextAlignStyle'\nexport {\n\tDefaultVerticalAlignStyle,\n\ttype TLDefaultVerticalAlignStyle,\n} from './styles/TLVerticalAlignStyle'\nexport {\n\ttype TLAssetContext,\n\ttype TLAssetStore,\n\ttype TLSerializedStore,\n\ttype TLStore,\n\ttype TLStoreProps,\n\ttype TLStoreSchema,\n\ttype TLStoreSnapshot,\n} from './TLStore'\nexport {\n\tgetDefaultTranslationLocale,\n\tLANGUAGES,\n\ttype TLLanguage,\n} from './translations/translations'\nexport { type SetValue } from './util-types'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAgCA,SAAS,oCAAoC;AAC7C,SAAS,kBAAkB,4BAA8C;AAIzE;AAQA;AAKA;AAMA;AAOA;AAMA,SAAS,mBAAmB;AAC5B;AAKA,SAAS,uBAAyD;AAClE,SAAS,uBAAyD;AAClE,SAAS,wBAA4C;AACrD,SAAS,mBAAmB,kBAAmC;AAC/D,SAAS,mBAAmB,0BAA2C;AACvE;AASA;AAcA,SAAS,wBAAwD;AACjE;AAMA;AAMA;AAOA;AAKA;AAMA;AAMA;AAsBA;AAYA;AAMA;AAMA;AAOA;AAMA;AAMA;AAQA;AAMA;AAMA;AAOA;AASA;AAMA;AAMA;AAMA,SAAS,eAAe,iBAAsC;AAC9D;AAUA,SAAS,wBAAiD;AAC1D,SAAS,wBAAiD;AAC1D;AAKA;AAIA,SAAS,wBAAiD;AAC1D,SAAS,6BAA2D;AACpE;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAOA,sMAAA,EACE,oBACA,SACA","debugId":null}}]
}