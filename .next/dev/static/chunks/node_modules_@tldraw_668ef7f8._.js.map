{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/helpers.ts"],"sourcesContent":["import { Child, Signal } from './types'\n\n/**\n * Get whether the given value is a child.\n *\n * @param x The value to check.\n * @returns True if the value is a child, false otherwise.\n * @internal\n */\nfunction isChild(x: any): x is Child {\n\treturn x && typeof x === 'object' && 'parents' in x\n}\n\n/**\n * Checks if any of a child's parent signals have changed by comparing their current epochs\n * with the child's cached view of those epochs.\n *\n * This function is used internally to determine if a computed signal or effect needs to\n * be re-evaluated because one of its dependencies has changed.\n *\n * @param child - The child (computed signal or effect) to check for parent changes\n * @returns `true` if any parent signal has changed since the child last observed it, `false` otherwise\n * @example\n * ```ts\n * const childSignal = computed('child', () => parentAtom.get())\n * // Check if the child needs to recompute\n * if (haveParentsChanged(childSignal)) {\n *   // Recompute the child's value\n * }\n * ```\n * @internal\n */\nexport function haveParentsChanged(child: Child): boolean {\n\tfor (let i = 0, n = child.parents.length; i < n; i++) {\n\t\t// Get the parent's value without capturing it.\n\t\tchild.parents[i].__unsafe__getWithoutCapture(true)\n\n\t\t// If the parent's epoch does not match the child's view of the parent's epoch, then the parent has changed.\n\t\tif (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Detaches a child signal from its parent signal, removing the parent-child relationship\n * in the reactive dependency graph. If the parent has no remaining children and is itself\n * a child, it will recursively detach from its own parents.\n *\n * This function is used internally to clean up the dependency graph when signals are no\n * longer needed or when dependencies change.\n *\n * @param parent - The parent signal to detach from\n * @param child - The child signal to detach\n * @example\n * ```ts\n * // When a computed signal's dependencies change\n * const oldParent = atom('old', 1)\n * const child = computed('child', () => oldParent.get())\n * // Later, detach the child from the old parent\n * detach(oldParent, child)\n * ```\n * @internal\n */\nexport function detach(parent: Signal<any>, child: Child) {\n\t// If the child is not attached to the parent, do nothing.\n\tif (!parent.children.remove(child)) {\n\t\treturn\n\t}\n\n\t// If the parent has no more children, then detach the parent from its parents.\n\tif (parent.children.isEmpty && isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tdetach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Attaches a child signal to its parent signal, establishing a parent-child relationship\n * in the reactive dependency graph. If the parent is itself a child, it will recursively\n * attach to its own parents to maintain the dependency chain.\n *\n * This function is used internally when dependencies are captured during computed signal\n * evaluation or effect execution.\n *\n * @param parent - The parent signal to attach to\n * @param child - The child signal to attach\n * @example\n * ```ts\n * // When a computed signal captures a new dependency\n * const parentAtom = atom('parent', 1)\n * const child = computed('child', () => parentAtom.get())\n * // Internally, attach is called to establish the dependency\n * attach(parentAtom, child)\n * ```\n * @internal\n */\nexport function attach(parent: Signal<any>, child: Child) {\n\t// If the child is already attached to the parent, do nothing.\n\tif (!parent.children.add(child)) {\n\t\treturn\n\t}\n\n\t// If the parent itself is a child, add the parent to the parent's parents.\n\tif (isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tattach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Checks if two values are equal using the equality semantics of @tldraw/state.\n *\n * This function performs equality checks in the following order:\n * 1. Reference equality (`===`)\n * 2. `Object.is()` equality (handles NaN and -0/+0 cases)\n * 3. Custom `.equals()` method when the left-hand value provides one\n *\n * This is used internally to determine if a signal's value has actually changed\n * when setting new values, preventing unnecessary updates and re-computations.\n *\n * @param a - The first value to compare\n * @param b - The second value to compare\n * @returns `true` if the values are considered equal, `false` otherwise\n * @example\n * ```ts\n * equals(1, 1) // true\n * equals(NaN, NaN) // true (unlike === which returns false)\n * equals({ equals: (other: any) => other.id === 1 }, { id: 1 }) // Uses custom equals method\n * ```\n * @internal\n */\nexport function equals(a: any, b: any): boolean {\n\tconst shallowEquals =\n\t\ta === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === 'function' && a.equals(b))\n\treturn shallowEquals\n}\n\n/**\n * A TypeScript utility function for exhaustiveness checking in switch statements and\n * conditional branches. This function should never be called at runtime\u2014it exists\n * purely for compile-time type checking and is `undefined` in emitted JavaScript.\n *\n * @param x - A value that should be of type `never`\n * @throws Always at runtime because the identifier is undefined\n * @example\n * ```ts\n * type Color = 'red' | 'blue'\n *\n * function handleColor(color: Color) {\n *   switch (color) {\n *     case 'red':\n *       return 'Stop'\n *     case 'blue':\n *       return 'Go'\n *     default:\n *       return assertNever(color) // TypeScript error if not all cases handled\n *   }\n * }\n * ```\n * @public\n */\nexport declare function assertNever(x: never): never\n\n/**\n * Creates or retrieves a singleton instance using a global symbol registry.\n * This ensures that the same instance is shared across all code that uses\n * the same key, even across different module boundaries.\n *\n * The singleton is stored on `globalThis` using a symbol created with\n * `Symbol.for()`, which ensures global uniqueness across realms.\n *\n * @param key - A unique string identifier for the singleton\n * @param init - A function that creates the initial value if it doesn't exist\n * @returns The singleton instance\n * @example\n * ```ts\n * // Create a singleton logger\n * const logger = singleton('logger', () => new Logger())\n *\n * // Elsewhere in the codebase, get the same logger instance\n * const sameLogger = singleton('logger', () => new Logger())\n * // logger === sameLogger\n * ```\n * @internal\n */\nexport function singleton<T>(key: string, init: () => T): T {\n\tconst symbol = Symbol.for(`com.tldraw.state/${key}`)\n\tconst global = globalThis as any\n\tglobal[symbol] ??= init()\n\treturn global[symbol]\n}\n\n/**\n * @public\n */\nexport const EMPTY_ARRAY: [] = singleton('empty_array', () => Object.freeze([]) as any)\n\n/**\n * Checks if a signal has any active reactors (effects or computed signals) that are\n * currently listening to it. This determines whether changes to the signal will\n * cause any side effects or recomputations to occur.\n *\n * A signal is considered to have active reactors if any of its child dependencies\n * are actively listening for changes.\n *\n * @param signal - The signal to check for active reactors\n * @returns `true` if the signal has active reactors, `false` otherwise\n * @example\n * ```ts\n * const count = atom('count', 0)\n *\n * console.log(hasReactors(count)) // false - no effects listening\n *\n * const stop = react('logger', () => console.log(count.get()))\n * console.log(hasReactors(count)) // true - effect is listening\n *\n * stop()\n * console.log(hasReactors(count)) // false - effect stopped\n * ```\n * @public\n */\nexport function hasReactors(signal: Signal<any>) {\n\tfor (const child of signal.children) {\n\t\tif (child.isActivelyListening) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AASA,SAAS,QAAQ,CAAA,EAAoB;IACpC,OAAO,KAAK,OAAO,MAAM,YAAY,aAAa;AACnD;AAqBO,SAAS,mBAAmB,KAAA,EAAuB;IACzD,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;QAErD,MAAM,OAAA,CAAQ,CAAC,CAAA,CAAE,2BAAA,CAA4B,IAAI;QAGjD,IAAI,MAAM,OAAA,CAAQ,CAAC,CAAA,CAAE,gBAAA,KAAqB,MAAM,YAAA,CAAa,CAAC,CAAA,EAAG;YAChE,OAAO;QACR;IACD;IAEA,OAAO;AACR;AAsBO,SAAS,OAAO,MAAA,EAAqB,KAAA,EAAc;IAEzD,IAAI,CAAC,OAAO,QAAA,CAAS,MAAA,CAAO,KAAK,GAAG;QACnC;IACD;IAGA,IAAI,OAAO,QAAA,CAAS,OAAA,IAAW,QAAQ,MAAM,GAAG;QAC/C,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;YACtD,OAAO,OAAO,OAAA,CAAQ,CAAC,CAAA,EAAG,MAAM;QACjC;IACD;AACD;AAsBO,SAAS,OAAO,MAAA,EAAqB,KAAA,EAAc;IAEzD,IAAI,CAAC,OAAO,QAAA,CAAS,GAAA,CAAI,KAAK,GAAG;QAChC;IACD;IAGA,IAAI,QAAQ,MAAM,GAAG;QACpB,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;YACtD,OAAO,OAAO,OAAA,CAAQ,CAAC,CAAA,EAAG,MAAM;QACjC;IACD;AACD;AAwBO,SAAS,OAAO,CAAA,EAAQ,CAAA,EAAiB;IAC/C,MAAM,gBACL,MAAM,KAAK,OAAO,EAAA,CAAG,GAAG,CAAC,KAAK,QAAQ,KAAK,KAAK,OAAO,EAAE,MAAA,KAAW,cAAc,EAAE,MAAA,CAAO,CAAC,CAAC;IAC9F,OAAO;AACR;AAkDO,SAAS,UAAa,GAAA,EAAa,IAAA,EAAkB;IAC3D,MAAM,SAAS,OAAO,GAAA,CAAI,CAAA,iBAAA,EAAoB,GAAG,EAAE;IACnD,MAAM,SAAS;IACf,MAAA,CAAO,MAAM,CAAA,KAAM,KAAK;IACxB,OAAO,MAAA,CAAO,MAAM,CAAA;AACrB;AAKO,MAAM,cAAkB,UAAU,eAAe,IAAM,OAAO,MAAA,CAAO,CAAC,CAAC,CAAQ;AA0B/E,SAAS,YAAY,MAAA,EAAqB;IAChD,KAAA,MAAW,SAAS,OAAO,QAAA,CAAU;QACpC,IAAI,MAAM,mBAAA,EAAqB;YAC9B,OAAO;QACR;IACD;IAEA,OAAO;AACR","debugId":null}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/ArraySet.ts"],"sourcesContent":["/**\n * The maximum number of items that can be stored in an ArraySet in array mode before switching to Set mode.\n *\n * @public\n * @example\n * ```ts\n * import { ARRAY_SIZE_THRESHOLD } from '@tldraw/state'\n *\n * console.log(ARRAY_SIZE_THRESHOLD) // 8\n * ```\n */\nexport const ARRAY_SIZE_THRESHOLD = 8\n\n/**\n * An ArraySet operates as an array until it reaches a certain size, after which a Set is used\n * instead. In either case, the same methods are used to get, set, remove, and visit the items.\n * @internal\n */\nexport class ArraySet<T> {\n\tprivate arraySize = 0\n\n\tprivate array: (T | undefined)[] | null = Array(ARRAY_SIZE_THRESHOLD)\n\n\tprivate set: Set<T> | null = null\n\n\t/**\n\t * Get whether this ArraySet has any elements.\n\t *\n\t * @returns True if this ArraySet has any elements, false otherwise.\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isEmpty() {\n\t\tif (this.array) {\n\t\t\treturn this.arraySize === 0\n\t\t}\n\n\t\tif (this.set) {\n\t\t\treturn this.set.size === 0\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Add an element to the ArraySet if it is not already present.\n\t *\n\t * @param elem - The element to add to the set\n\t * @returns `true` if the element was added, `false` if it was already present\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t *\n\t * console.log(arraySet.add('hello')) // true\n\t * console.log(arraySet.add('hello')) // false (already exists)\n\t * ```\n\t */\n\tadd(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// Return false if the element is already in the array.\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif (this.arraySize < ARRAY_SIZE_THRESHOLD) {\n\t\t\t\t// If the array is below the size threshold, push items into the array.\n\n\t\t\t\t// Insert the element into the array's next available slot.\n\t\t\t\tthis.array[this.arraySize] = elem\n\t\t\t\tthis.arraySize++\n\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\t// If the array is full, convert it to a set and remove the array.\n\t\t\t\tthis.set = new Set(this.array as any)\n\t\t\t\tthis.array = null\n\t\t\t\tthis.set.add(elem)\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// Return false if the element is already in the set.\n\t\t\tif (this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.add(elem)\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Remove an element from the ArraySet if it is present.\n\t *\n\t * @param elem - The element to remove from the set\n\t * @returns `true` if the element was removed, `false` if it was not present\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t * arraySet.add('hello')\n\t *\n\t * console.log(arraySet.remove('hello')) // true\n\t * console.log(arraySet.remove('hello')) // false (not present)\n\t * ```\n\t */\n\tremove(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// If the item is not in the array, return false.\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.array[idx] = undefined\n\t\t\tthis.arraySize--\n\n\t\t\tif (idx !== this.arraySize) {\n\t\t\t\t// If the item is not the last item in the array, move the last item into the\n\t\t\t\t// removed item's slot.\n\t\t\t\tthis.array[idx] = this.array[this.arraySize]\n\t\t\t\tthis.array[this.arraySize] = undefined\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// If the item is not in the set, return false.\n\t\t\tif (!this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.delete(elem)\n\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Execute a callback function for each element in the ArraySet.\n\t *\n\t * @param visitor - A function to call for each element in the set\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t * arraySet.add('hello')\n\t * arraySet.add('world')\n\t *\n\t * arraySet.visit((item) => {\n\t *   console.log(item) // 'hello', 'world'\n\t * })\n\t * ```\n\t */\n\tvisit(visitor: (item: T) => void) {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tvisitor(elem)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (this.set) {\n\t\t\tthis.set.forEach(visitor)\n\n\t\t\treturn\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Make the ArraySet iterable, allowing it to be used in for...of loops and with spread syntax.\n\t *\n\t * @returns An iterator that yields each element in the set\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<number>()\n\t * arraySet.add(1)\n\t * arraySet.add(2)\n\t *\n\t * for (const item of arraySet) {\n\t *   console.log(item) // 1, 2\n\t * }\n\t *\n\t * const items = [...arraySet] // [1, 2]\n\t * ```\n\t */\n\t*[Symbol.iterator]() {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tyield elem\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.set) {\n\t\t\tyield* this.set\n\t\t} else {\n\t\t\tthrow new Error('no set or array')\n\t\t}\n\t}\n\n\t/**\n\t * Check whether an element is present in the ArraySet.\n\t *\n\t * @param elem - The element to check for\n\t * @returns `true` if the element is present, `false` otherwise\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t * arraySet.add('hello')\n\t *\n\t * console.log(arraySet.has('hello')) // true\n\t * console.log(arraySet.has('world')) // false\n\t * ```\n\t */\n\thas(elem: T) {\n\t\tif (this.array) {\n\t\t\treturn this.array.indexOf(elem) !== -1\n\t\t} else {\n\t\t\treturn this.set!.has(elem)\n\t\t}\n\t}\n\n\t/**\n\t * Remove all elements from the ArraySet.\n\t *\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t * arraySet.add('hello')\n\t * arraySet.add('world')\n\t *\n\t * arraySet.clear()\n\t * console.log(arraySet.size()) // 0\n\t * ```\n\t */\n\tclear() {\n\t\tif (this.set) {\n\t\t\tthis.set.clear()\n\t\t} else {\n\t\t\tthis.arraySize = 0\n\t\t\tthis.array = []\n\t\t}\n\t}\n\n\t/**\n\t * Get the number of elements in the ArraySet.\n\t *\n\t * @returns The number of elements in the set\n\t * @example\n\t * ```ts\n\t * const arraySet = new ArraySet<string>()\n\t * console.log(arraySet.size()) // 0\n\t *\n\t * arraySet.add('hello')\n\t * console.log(arraySet.size()) // 1\n\t * ```\n\t */\n\tsize() {\n\t\tif (this.set) {\n\t\t\treturn this.set.size\n\t\t} else {\n\t\t\treturn this.arraySize\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 302, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/types.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\n\n/**\n * A unique symbol used to indicate that a signal's value should be reset or that\n * there is insufficient history to compute diffs between epochs.\n *\n * This value is returned by {@link Signal.getDiffSince} when the requested epoch\n * is too far in the past and the diff sequence cannot be reconstructed.\n *\n * @example\n * ```ts\n * import { atom, getGlobalEpoch, RESET_VALUE } from '@tldraw/state'\n *\n * const count = atom('count', 0, { historyLength: 3 })\n * const oldEpoch = getGlobalEpoch()\n *\n * // Make many changes that exceed history length\n * count.set(1)\n * count.set(2)\n * count.set(3)\n * count.set(4)\n *\n * const diffs = count.getDiffSince(oldEpoch)\n * if (diffs === RESET_VALUE) {\n *   console.log('Too many changes, need to reset state')\n * }\n * ```\n *\n * @public\n */\nexport const RESET_VALUE: unique symbol = Symbol.for('com.tldraw.state/RESET_VALUE')\n\n/**\n * Type representing the the unique symbol RESET_VALUE symbol, used in type annotations\n * to indicate when a signal value should be reset or when diff computation\n * cannot proceed due to insufficient history.\n *\n * @public\n */\nexport type RESET_VALUE = typeof RESET_VALUE\n\n/**\n * A reactive value container that can change over time and track diffs between sequential values.\n *\n * Signals are the foundation of the \\@tldraw/state reactive system. They automatically manage\n * dependencies and trigger updates when their values change. Any computed signal or effect\n * that reads from this signal will be automatically recomputed when the signal's value changes.\n *\n * There are two types of signal:\n * - **Atomic signals** - Created using `atom()`. These are mutable containers that can be\n *   directly updated using `set()` or `update()` methods.\n * - **Computed signals** - Created using `computed()`. These derive their values from other\n *   signals and are automatically recomputed when dependencies change.\n *\n * @example\n * ```ts\n * import { atom, computed } from '@tldraw/state'\n *\n * // Create an atomic signal\n * const count = atom('count', 0)\n *\n * // Create a computed signal that derives from the atom\n * const doubled = computed('doubled', () => count.get() * 2)\n *\n * console.log(doubled.get()) // 0\n * count.set(5)\n * console.log(doubled.get()) // 10\n * ```\n *\n * @public\n */\nexport interface Signal<Value, Diff = unknown> {\n\t/**\n\t * A human-readable identifier for this signal, used primarily for debugging and performance profiling.\n\t *\n\t * The name is displayed in debug output from {@link whyAmIRunning} and other diagnostic tools.\n\t * It does not need to be globally unique within your application.\n\t */\n\tname: string\n\t/**\n\t * Gets the current value of the signal and establishes a dependency relationship.\n\t *\n\t * When called from within a computed signal or effect, this signal will be automatically\n\t * tracked as a dependency. If this signal's value changes, any dependent computations\n\t * or effects will be marked for re-execution.\n\t *\n\t * @returns The current value stored in the signal\n\t */\n\tget(): Value\n\n\t/**\n\t * The global epoch number when this signal's value last changed.\n\t *\n\t * Note that this represents when the value actually changed, not when it was last computed.\n\t * A computed signal may recalculate and produce the same value without changing its epoch.\n\t * This is used internally for dependency tracking and history management.\n\t */\n\tlastChangedEpoch: number\n\t/**\n\t * Gets the sequence of diffs that occurred between a specific epoch and the current state.\n\t *\n\t * This method enables incremental synchronization by providing a list of changes that\n\t * have occurred since a specific point in time. If the requested epoch is too far in\n\t * the past or the signal doesn't have enough history, it returns the unique symbol RESET_VALUE\n\t * to indicate that a full state reset is required.\n\t *\n\t * @param epoch - The epoch timestamp to get diffs since\n\t * @returns An array of diff objects representing changes since the epoch, or the unique symbol RESET_VALUE if insufficient history is available\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[]\n\t/**\n\t * Gets the current value of the signal without establishing a dependency relationship.\n\t *\n\t * This method bypasses the automatic dependency tracking system, making it useful for\n\t * performance-critical code paths where the overhead of dependency capture would be\n\t * problematic. Use with caution as it breaks the reactive guarantees of the system.\n\t *\n\t * **Warning**: This method should only be used when you're certain that you don't need\n\t * the calling context to react to changes in this signal.\n\t *\n\t * @param ignoreErrors - Whether to suppress errors during value retrieval (optional)\n\t * @returns The current value without establishing dependencies\n\t */\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value\n\t/** @internal */\n\tchildren: ArraySet<Child>\n}\n\n/**\n * Internal interface representing a child node in the signal dependency graph.\n *\n * This interface is used internally by the reactive system to manage dependencies\n * between signals, computed values, and effects. Each child tracks its parent\n * signals and maintains state needed for efficient dependency graph traversal\n * and change propagation.\n *\n * @internal\n */\nexport interface Child {\n\t/**\n\t * The epoch when this child was last traversed during dependency graph updates.\n\t * Used to prevent redundant traversals during change propagation.\n\t */\n\tlastTraversedEpoch: number\n\n\t/**\n\t * Set of parent signals that this child depends on.\n\t * Used for efficient lookup and cleanup operations.\n\t */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\n\t/**\n\t * Array of parent signals that this child depends on.\n\t * Maintained in parallel with parentSet for ordered access.\n\t */\n\treadonly parents: Signal<any, any>[]\n\n\t/**\n\t * Array of epochs corresponding to each parent signal.\n\t * Used to detect which parents have changed since last computation.\n\t */\n\treadonly parentEpochs: number[]\n\n\t/**\n\t * Human-readable name for this child, used in debugging output.\n\t */\n\treadonly name: string\n\n\t/**\n\t * Whether this child is currently subscribed to change notifications.\n\t * Used to optimize resource usage by unsubscribing inactive dependencies.\n\t */\n\tisActivelyListening: boolean\n\n\t/**\n\t * Debug information tracking ancestor epochs in the dependency graph.\n\t * Only populated in debug builds for diagnostic purposes.\n\t */\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null\n}\n\n/**\n * A function type that computes the difference between two values of a signal.\n *\n * This function is used to generate incremental diffs that can be applied to\n * reconstruct state changes over time. It's particularly useful for features\n * like undo/redo, synchronization, and change tracking.\n *\n * The function should analyze the previous and current values and return a\n * diff object that represents the change. If the diff cannot be computed\n * (e.g., the values are too different or incompatible), it should return\n * the unique symbol RESET_VALUE to indicate that a full state reset is required.\n *\n * @param previousValue - The previous value of the signal\n * @param currentValue - The current value of the signal\n * @param lastComputedEpoch - The epoch when the previous value was set\n * @param currentEpoch - The epoch when the current value was set\n * @returns A diff object representing the change, or the unique symbol RESET_VALUE if no diff can be computed\n *\n * @example\n * ```ts\n * import { atom, RESET_VALUE } from '@tldraw/state'\n *\n * // Simple numeric diff\n * const numberDiff: ComputeDiff<number, number> = (prev, curr) => curr - prev\n *\n * // Array diff with reset fallback\n * const arrayDiff: ComputeDiff<string[], { added: string[], removed: string[] }> = (prev, curr) => {\n *   if (prev.length > 1000 || curr.length > 1000) {\n *     return RESET_VALUE // Too complex, force reset\n *   }\n *   return {\n *     added: curr.filter(item => !prev.includes(item)),\n *     removed: prev.filter(item => !curr.includes(item))\n *   }\n * }\n *\n * const count = atom('count', 0, { computeDiff: numberDiff })\n * ```\n *\n * @public\n */\nexport type ComputeDiff<Value, Diff> = (\n\tpreviousValue: Value,\n\tcurrentValue: Value,\n\tlastComputedEpoch: number,\n\tcurrentEpoch: number\n) => Diff | RESET_VALUE\n"],"names":[],"mappings":";;;;AA8BO,MAAM,cAA6B,OAAO,GAAA,CAAI,8BAA8B","debugId":null}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/HistoryBuffer.ts"],"sourcesContent":["import { RESET_VALUE } from './types'\n\n/**\n * A tuple representing a range of epochs and the associated diff.\n * Used internally by HistoryBuffer to store change information.\n *\n * @internal\n */\ntype RangeTuple<Diff> = [fromEpoch: number, toEpoch: number, diff: Diff]\n\n/**\n * A circular buffer that stores diffs between sequential values of an atom or computed signal.\n * This enables efficient change tracking and history retrieval for features like undo/redo.\n *\n * The buffer uses a wrap-around strategy to maintain a fixed-size history of the most recent\n * changes, automatically overwriting older entries when the capacity is exceeded.\n *\n * @example\n * ```ts\n * const buffer = new HistoryBuffer<string>(5)\n * buffer.pushEntry(0, 1, 'first change')\n * buffer.pushEntry(1, 2, 'second change')\n * const changes = buffer.getChangesSince(0) // ['first change', 'second change']\n * ```\n *\n * @internal\n */\nexport class HistoryBuffer<Diff> {\n\t/**\n\t * Current write position in the circular buffer.\n\t * @internal\n\t */\n\tprivate index = 0\n\n\t/**\n\t * Circular buffer storing range tuples. Uses undefined to represent empty slots.\n\t * @internal\n\t */\n\tbuffer: Array<RangeTuple<Diff> | undefined>\n\n\t/**\n\t * Creates a new HistoryBuffer with the specified capacity.\n\t *\n\t * capacity - Maximum number of diffs to store in the buffer\n\t * @example\n\t * ```ts\n\t * const buffer = new HistoryBuffer<number>(10) // Store up to 10 diffs\n\t * ```\n\t */\n\tconstructor(private readonly capacity: number) {\n\t\tthis.buffer = new Array(capacity)\n\t}\n\n\t/**\n\t * Adds a diff entry to the history buffer, representing a change between two epochs.\n\t *\n\t * If the diff is undefined, the operation is ignored. If the diff is RESET_VALUE,\n\t * the entire buffer is cleared to indicate that historical tracking should restart.\n\t *\n\t * @param lastComputedEpoch - The epoch when the previous value was computed\n\t * @param currentEpoch - The epoch when the current value was computed\n\t * @param diff - The diff representing the change, or RESET_VALUE to clear history\n\t * @example\n\t * ```ts\n\t * const buffer = new HistoryBuffer<string>(5)\n\t * buffer.pushEntry(0, 1, 'added text')\n\t * buffer.pushEntry(1, 2, RESET_VALUE) // Clears the buffer\n\t * ```\n\t */\n\tpushEntry(lastComputedEpoch: number, currentEpoch: number, diff: Diff | RESET_VALUE) {\n\t\tif (diff === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\tthis.clear()\n\t\t\treturn\n\t\t}\n\n\t\t// Add the diff to the buffer as a range tuple.\n\t\tthis.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff]\n\n\t\t// Bump the index, wrapping around if necessary.\n\t\tthis.index = (this.index + 1) % this.capacity\n\t}\n\n\t/**\n\t * Clears all entries from the history buffer and resets the write position.\n\t * This is called when a RESET_VALUE diff is encountered.\n\t *\n\t * @example\n\t * ```ts\n\t * const buffer = new HistoryBuffer<string>(5)\n\t * buffer.pushEntry(0, 1, 'change')\n\t * buffer.clear()\n\t * console.log(buffer.getChangesSince(0)) // RESET_VALUE\n\t * ```\n\t */\n\tclear() {\n\t\tthis.index = 0\n\t\tthis.buffer.fill(undefined)\n\t}\n\n\t/**\n\t * Retrieves all diffs that occurred since the specified epoch.\n\t *\n\t * The method searches backwards through the circular buffer to find changes\n\t * that occurred after the given epoch. If insufficient history is available\n\t * or the requested epoch is too old, returns RESET_VALUE indicating that\n\t * a complete state rebuild is required.\n\t *\n\t * @param sinceEpoch - The epoch from which to retrieve changes\n\t * @returns Array of diffs since the epoch, or RESET_VALUE if history is insufficient\n\t * @example\n\t * ```ts\n\t * const buffer = new HistoryBuffer<string>(5)\n\t * buffer.pushEntry(0, 1, 'first')\n\t * buffer.pushEntry(1, 2, 'second')\n\t * const changes = buffer.getChangesSince(0) // ['first', 'second']\n\t * const recentChanges = buffer.getChangesSince(1) // ['second']\n\t * const tooOld = buffer.getChangesSince(-100) // RESET_VALUE\n\t * ```\n\t */\n\tgetChangesSince(sinceEpoch: number): RESET_VALUE | Diff[] {\n\t\tconst { index, capacity, buffer } = this\n\n\t\t// For each item in the buffer...\n\t\tfor (let i = 0; i < capacity; i++) {\n\t\t\tconst offset = (index - 1 + capacity - i) % capacity\n\n\t\t\tconst elem = buffer[offset]\n\n\t\t\t// If there's no element in the offset position, return the reset value\n\t\t\tif (!elem) {\n\t\t\t\treturn RESET_VALUE\n\t\t\t}\n\n\t\t\tconst [fromEpoch, toEpoch] = elem\n\n\t\t\t// If the first element is already too early, bail\n\t\t\tif (i === 0 && sinceEpoch >= toEpoch) {\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\t// If the element is since the given epoch, return an array with all diffs from this element and all following elements\n\t\t\tif (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {\n\t\t\t\tconst len = i + 1\n\t\t\t\tconst result = new Array(len)\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tresult[j] = buffer[(offset + j) % capacity]![2]\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't returned yet, return the reset value\n\t\treturn RESET_VALUE\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,mBAAmB;;AA2BrB,MAAM,cAAoB;IAAA;;;;;;;;GAAA,GAsBhC,YAA6B,QAAA,CAAkB;QAAlB,IAAA,CAAA,QAAA,GAAA;QAC5B,IAAA,CAAK,MAAA,GAAS,IAAI,MAAM,QAAQ;IACjC;IAAA;;;GAAA,GAnBQ,QAAQ,EAAA;IAAA;;;GAAA,GAMhB,OAAA;IAAA;;;;;;;;;;;;;;;GAAA,GA+BA,UAAU,iBAAA,EAA2B,YAAA,EAAsB,IAAA,EAA0B;QACpF,IAAI,SAAS,KAAA,GAAW;YACvB;QACD;QAEA,IAAI,SAAS,mLAAA,EAAa;YACzB,IAAA,CAAK,KAAA,CAAM;YACX;QACD;QAGA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,GAAI;YAAC;YAAmB;YAAc,IAAI;SAAA;QAGhE,IAAA,CAAK,KAAA,GAAA,CAAS,IAAA,CAAK,KAAA,GAAQ,CAAA,IAAK,IAAA,CAAK,QAAA;IACtC;IAAA;;;;;;;;;;;GAAA,GAcA,QAAQ;QACP,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,CAAS;IAC3B;IAAA;;;;;;;;;;;;;;;;;;;GAAA,GAsBA,gBAAgB,UAAA,EAA0C;QACzD,MAAM,EAAE,KAAA,EAAO,QAAA,EAAU,MAAA,CAAO,CAAA,GAAI,IAAA;QAGpC,IAAA,IAAS,IAAI,GAAG,IAAI,UAAU,IAAK;YAClC,MAAM,SAAA,CAAU,QAAQ,IAAI,WAAW,CAAA,IAAK;YAE5C,MAAM,OAAO,MAAA,CAAO,MAAM,CAAA;YAG1B,IAAI,CAAC,MAAM;gBACV,OAAO,mLAAA;YACR;YAEA,MAAM,CAAC,WAAW,OAAO,CAAA,GAAI;YAG7B,IAAI,MAAM,KAAK,cAAc,SAAS;gBACrC,OAAO,CAAC,CAAA;YACT;YAGA,IAAI,aAAa,cAAc,aAAa,SAAS;gBACpD,MAAM,MAAM,IAAI;gBAChB,MAAM,SAAS,IAAI,MAAM,GAAG;gBAE5B,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;oBAC7B,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAA,CAAQ,SAAS,CAAA,IAAK,QAAQ,CAAA,CAAG,CAAC,CAAA;gBAC/C;gBAEA,OAAO;YACR;QACD;QAGA,OAAO,mLAAA;IACR;AACD","debugId":null}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/constants.ts"],"sourcesContent":["/**\n * The initial epoch value used to mark derivations (computed signals and effects) as dirty before their first computation.\n *\n * This constant ensures that all computed signals and effects start in a \"dirty\" state, guaranteeing they will\n * be computed/executed at least once when first accessed or started. The value -1 is used because:\n * - Global epoch starts at 0 (GLOBAL_START_EPOCH + 1)\n * - Any derived signal initialized with GLOBAL_START_EPOCH (-1) will be considered dirty when compared to any positive epoch\n * - This forces initial computation/execution without requiring special initialization logic\n *\n * Used by:\n * - Computed signals to track when they were last changed\n * - Effect schedulers to track when they were last executed\n * - Transaction system for initial global and reaction epoch values\n *\n * @example\n * ```ts\n * // In Computed class constructor\n * lastChangedEpoch = GLOBAL_START_EPOCH // -1, marking as dirty\n *\n * // When global epoch is 5, this computed will be dirty since -1 < 5\n * const needsComputation = this.lastChangedEpoch < globalEpoch\n * ```\n *\n * @public\n */\nexport const GLOBAL_START_EPOCH = -1\n"],"names":[],"mappings":";;;;AAyBO,MAAM,qBAAqB,CAAA","debugId":null}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/EffectScheduler.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\nimport { startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { attach, detach, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch } from './transactions'\nimport { Signal } from './types'\n\n/** @public */\nexport interface EffectSchedulerOptions {\n\t/**\n\t * scheduleEffect is a function that will be called when the effect is scheduled.\n\t *\n\t * It can be used to defer running effects until a later time, for example to batch them together with requestAnimationFrame.\n\t *\n\t *\n\t * @example\n\t * ```ts\n\t * let isRafScheduled = false\n\t * const scheduledEffects: Array<() => void> = []\n\t * const scheduleEffect = (runEffect: () => void) => {\n\t * \tscheduledEffects.push(runEffect)\n\t * \tif (!isRafScheduled) {\n\t * \t\tisRafScheduled = true\n\t * \t\trequestAnimationFrame(() => {\n\t * \t\t\tisRafScheduled = false\n\t * \t\t\tscheduledEffects.forEach((runEffect) => runEffect())\n\t * \t\t\tscheduledEffects.length = 0\n\t * \t\t})\n\t * \t}\n\t * }\n\t * const stop = react('set page title', () => {\n\t * \tdocument.title = doc.title,\n\t * }, scheduleEffect)\n\t * ```\n\t *\n\t * @param execute - A function that will execute the effect.\n\t * @returns void\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tscheduleEffect?: (execute: () => void) => void\n}\n\nclass __EffectScheduler__<Result> implements EffectScheduler<Result> {\n\t/** @internal */\n\tprivate _isActivelyListening = false\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening() {\n\t\treturn this._isActivelyListening\n\t}\n\t/** @internal */\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t/** @internal */\n\tprivate lastReactedEpoch = GLOBAL_START_EPOCH\n\n\t/** @internal */\n\tprivate _scheduleCount = 0\n\t/** @internal */\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null = null\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget scheduleCount() {\n\t\treturn this._scheduleCount\n\t}\n\n\t/** @internal */\n\treadonly parentSet = new ArraySet<Signal<any, any>>()\n\t/** @internal */\n\treadonly parentEpochs: number[] = []\n\t/** @internal */\n\treadonly parents: Signal<any, any>[] = []\n\t/** @internal */\n\tprivate readonly _scheduleEffect?: (execute: () => void) => void\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate readonly runEffect: (lastReactedEpoch: number) => Result,\n\t\toptions?: EffectSchedulerOptions\n\t) {\n\t\tthis._scheduleEffect = options?.scheduleEffect\n\t}\n\n\t/** @internal */\n\tmaybeScheduleEffect() {\n\t\t// bail out if we have been cancelled by another effect\n\t\tif (!this._isActivelyListening) return\n\t\t// bail out if no atoms have changed since the last time we ran this effect\n\t\tif (this.lastReactedEpoch === getGlobalEpoch()) return\n\n\t\t// bail out if we have parents and they have not changed since last time\n\t\tif (this.parents.length && !haveParentsChanged(this)) {\n\t\t\tthis.lastReactedEpoch = getGlobalEpoch()\n\t\t\treturn\n\t\t}\n\t\t// if we don't have parents it's probably the first time this is running.\n\t\tthis.scheduleEffect()\n\t}\n\n\t/** @internal */\n\tscheduleEffect() {\n\t\tthis._scheduleCount++\n\t\tif (this._scheduleEffect) {\n\t\t\t// if the effect should be deferred (e.g. until a react render), do so\n\t\t\tthis._scheduleEffect(this.maybeExecute)\n\t\t} else {\n\t\t\t// otherwise execute right now!\n\t\t\tthis.execute()\n\t\t}\n\t}\n\n\t/** @internal */\n\t// eslint-disable-next-line local/prefer-class-methods\n\treadonly maybeExecute = () => {\n\t\t// bail out if we have been detached before this runs\n\t\tif (!this._isActivelyListening) return\n\t\tthis.execute()\n\t}\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.\n\t * @public\n\t */\n\tattach() {\n\t\tthis._isActivelyListening = true\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tattach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.\n\t * @public\n\t */\n\tdetach() {\n\t\tthis._isActivelyListening = false\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tdetach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t * @public\n\t */\n\texecute(): Result {\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\t// Important! We have to make a note of the current epoch before running the effect.\n\t\t\t// We allow atoms to be updated during effects, which increments the global epoch,\n\t\t\t// so if we were to wait until after the effect runs, the this.lastReactedEpoch value might get ahead of itself.\n\t\t\tconst currentEpoch = getGlobalEpoch()\n\t\t\tconst result = this.runEffect(this.lastReactedEpoch)\n\t\t\tthis.lastReactedEpoch = currentEpoch\n\t\t\treturn result\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n}\n\n/**\n * An EffectScheduler is responsible for executing side effects in response to changes in state.\n *\n * You probably don't need to use this directly unless you're integrating this library with a framework of some kind.\n *\n * Instead, use the {@link react} and {@link reactor} functions.\n *\n * @example\n * ```ts\n * const render = new EffectScheduler('render', drawToCanvas)\n *\n * render.attach()\n * render.execute()\n * ```\n *\n * @public\n */\nexport const EffectScheduler = singleton(\n\t'EffectScheduler',\n\t(): {\n\t\tnew <Result>(\n\t\t\tname: string,\n\t\t\trunEffect: (lastReactedEpoch: number) => Result,\n\t\t\toptions?: EffectSchedulerOptions\n\t\t): EffectScheduler<Result>\n\t} => __EffectScheduler__\n)\n/** @public */\nexport interface EffectScheduler<Result> {\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly lastTraversedEpoch: number\n\n\t/** @public */\n\treadonly name: string\n\n\t/** @internal */\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\treadonly scheduleCount: number\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\n\t/** @internal */\n\treadonly parentEpochs: number[]\n\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\n\t/** @internal */\n\tmaybeScheduleEffect(): void\n\n\t/** @internal */\n\tscheduleEffect(): void\n\n\t/** @internal */\n\tmaybeExecute(): void\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.\n\t * @public\n\t */\n\tattach(): void\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.\n\t * @public\n\t */\n\tdetach(): void\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t * @public\n\t */\n\texecute(): Result\n}\n\n/**\n * Starts a new effect scheduler, scheduling the effect immediately.\n *\n * Returns a function that can be called to stop the scheduler.\n *\n * @example\n * ```ts\n * const color = atom('color', 'red')\n * const stop = react('set style', () => {\n *   divElem.style.color = color.get()\n * })\n * color.set('blue')\n * // divElem.style.color === 'blue'\n * stop()\n * color.set('green')\n * // divElem.style.color === 'blue'\n * ```\n *\n *\n * Also useful in React applications for running effects outside of the render cycle.\n *\n * @example\n * ```ts\n * useEffect(() => react('set style', () => {\n *   divRef.current.style.color = color.get()\n * }), [])\n * ```\n *\n * @public\n */\nexport function react(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => any,\n\toptions?: EffectSchedulerOptions\n) {\n\tconst scheduler = new EffectScheduler(name, fn, options)\n\tscheduler.attach()\n\tscheduler.scheduleEffect()\n\treturn () => {\n\t\tscheduler.detach()\n\t}\n}\n\n/**\n * The reactor is a user-friendly interface for starting and stopping an `EffectScheduler`.\n *\n * Calling `.start()` will attach the scheduler and execute the effect immediately the first time it is called.\n *\n * If the reactor is stopped, calling `.start()` will re-attach the scheduler but will only execute the effect if any of its parents have changed since it was stopped.\n *\n * You can create a reactor with {@link reactor}.\n * @public\n */\nexport interface Reactor<T = unknown> {\n\t/**\n\t * The underlying effect scheduler.\n\t * @public\n\t */\n\tscheduler: EffectScheduler<T>\n\t/**\n\t * Start the scheduler. The first time this is called the effect will be scheduled immediately.\n\t *\n\t * If the reactor is stopped, calling this will start the scheduler again but will only execute the effect if any of its parents have changed since it was stopped.\n\t *\n\t * If you need to force re-execution of the effect, pass `{ force: true }`.\n\t * @public\n\t */\n\tstart(options?: { force?: boolean }): void\n\t/**\n\t * Stop the scheduler.\n\t * @public\n\t */\n\tstop(): void\n}\n\n/**\n * Creates a {@link Reactor}, which is a thin wrapper around an `EffectScheduler`.\n *\n * @public\n */\nexport function reactor<Result>(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => Result,\n\toptions?: EffectSchedulerOptions\n): Reactor<Result> {\n\tconst scheduler = new EffectScheduler<Result>(name, fn, options)\n\treturn {\n\t\tscheduler,\n\t\tstart: (options?: { force?: boolean }) => {\n\t\t\tconst force = options?.force ?? false\n\t\t\tscheduler.attach()\n\t\t\tif (force) {\n\t\t\t\tscheduler.scheduleEffect()\n\t\t\t} else {\n\t\t\t\tscheduler.maybeScheduleEffect()\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tscheduler.detach()\n\t\t},\n\t}\n}\n"],"names":["options"],"mappings":"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","debugId":null}},
    {"offset": {"line": 584, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/transactions.ts"],"sourcesContent":["import { _Atom } from './Atom'\nimport { EffectScheduler } from './EffectScheduler'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { singleton } from './helpers'\nimport { Child, Signal } from './types'\n\nclass Transaction {\n\tasyncProcessCount = 0\n\tconstructor(\n\t\tpublic readonly parent: Transaction | null,\n\t\tpublic readonly isSync: boolean\n\t) {}\n\n\tinitialAtomValues = new Map<_Atom, any>()\n\n\t/**\n\t * Get whether this transaction is a root (no parents).\n\t *\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isRoot() {\n\t\treturn this.parent === null\n\t}\n\n\t/**\n\t * Commit the transaction's changes.\n\t *\n\t * @public\n\t */\n\tcommit() {\n\t\tif (inst.globalIsReacting) {\n\t\t\t// if we're committing during a reaction we actually need to\n\t\t\t// use the 'cleanup' reactors set to ensure we re-run effects if necessary\n\t\t\tfor (const atom of this.initialAtomValues.keys()) {\n\t\t\t\ttraverseAtomForCleanup(atom)\n\t\t\t}\n\t\t} else if (this.isRoot) {\n\t\t\t// For root transactions, flush changed atoms\n\t\t\tflushChanges(this.initialAtomValues.keys())\n\t\t} else {\n\t\t\t// For transactions with parents, add the transaction's initial values to the parent's.\n\t\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\t\tif (!this.parent!.initialAtomValues.has(atom)) {\n\t\t\t\t\tthis.parent!.initialAtomValues.set(atom, value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction.\n\t *\n\t * @public\n\t */\n\tabort() {\n\t\tinst.globalEpoch++\n\n\t\t// Reset each of the transaction's atoms to its initial value.\n\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\tatom.set(value)\n\t\t\tatom.historyBuffer?.clear()\n\t\t})\n\n\t\t// Commit the changes.\n\t\tthis.commit()\n\t}\n}\n\nconst inst = singleton('transactions', () => ({\n\t// The current epoch (global to all atoms).\n\tglobalEpoch: GLOBAL_START_EPOCH + 1,\n\t// Whether any transaction is reacting.\n\tglobalIsReacting: false,\n\tcurrentTransaction: null as Transaction | null,\n\n\tcleanupReactors: null as null | Set<EffectScheduler<unknown>>,\n\treactionEpoch: GLOBAL_START_EPOCH + 1,\n}))\n\n/**\n * Gets the current reaction epoch, which is used to track when reactions are running.\n * The reaction epoch is updated at the start of each reaction cycle.\n *\n * @returns The current reaction epoch number\n * @public\n */\nexport function getReactionEpoch() {\n\treturn inst.reactionEpoch\n}\n\n/**\n * Gets the current global epoch, which is incremented every time any atom changes.\n * This is used to track changes across the entire reactive system.\n *\n * @returns The current global epoch number\n * @public\n */\nexport function getGlobalEpoch() {\n\treturn inst.globalEpoch\n}\n\n/**\n * Checks whether any reactions are currently executing.\n * When true, the system is in the middle of processing effects and side effects.\n *\n * @returns True if reactions are currently running, false otherwise\n * @public\n */\nexport function getIsReacting() {\n\treturn inst.globalIsReacting\n}\n\nfunction traverse(reactors: Set<EffectScheduler<unknown>>, child: Child) {\n\tif (child.lastTraversedEpoch === inst.globalEpoch) {\n\t\treturn\n\t}\n\n\tchild.lastTraversedEpoch = inst.globalEpoch\n\n\tif (child instanceof EffectScheduler) {\n\t\treactors.add(child)\n\t} else {\n\t\t;(child as any as Signal<any>).children.visit((c) => traverse(reactors, c))\n\t}\n}\n\n/**\n * Collect all of the reactors that need to run for an atom and run them.\n *\n * @param atoms - The atoms to flush changes for.\n */\nfunction flushChanges(atoms: Iterable<_Atom>) {\n\tif (inst.globalIsReacting) {\n\t\tthrow new Error('flushChanges cannot be called during a reaction')\n\t}\n\n\tconst outerTxn = inst.currentTransaction\n\ttry {\n\t\t// clear the transaction stack\n\t\tinst.currentTransaction = null\n\t\tinst.globalIsReacting = true\n\t\tinst.reactionEpoch = inst.globalEpoch\n\n\t\t// Collect all of the visited reactors.\n\t\tconst reactors = new Set<EffectScheduler<unknown>>()\n\n\t\tfor (const atom of atoms) {\n\t\t\tatom.children.visit((child) => traverse(reactors, child))\n\t\t}\n\n\t\t// Run each reactor.\n\t\tfor (const r of reactors) {\n\t\t\tr.maybeScheduleEffect()\n\t\t}\n\n\t\tlet updateDepth = 0\n\t\twhile (inst.cleanupReactors?.size) {\n\t\t\tif (updateDepth++ > 1000) {\n\t\t\t\tthrow new Error('Reaction update depth limit exceeded')\n\t\t\t}\n\t\t\tconst reactors = inst.cleanupReactors\n\t\t\tinst.cleanupReactors = null\n\t\t\tfor (const r of reactors) {\n\t\t\t\tr.maybeScheduleEffect()\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tinst.cleanupReactors = null\n\t\tinst.globalIsReacting = false\n\t\tinst.currentTransaction = outerTxn\n\t}\n}\n\n/**\n * Handle a change to an atom.\n *\n * @param atom The atom that changed.\n * @param previousValue The atom's previous value.\n *\n * @internal\n */\nexport function atomDidChange(atom: _Atom, previousValue: any) {\n\tif (inst.currentTransaction) {\n\t\t// If we are in a transaction, then all we have to do is preserve\n\t\t// the value of the atom at the start of the transaction in case\n\t\t// we need to roll back.\n\t\tif (!inst.currentTransaction.initialAtomValues.has(atom)) {\n\t\t\tinst.currentTransaction.initialAtomValues.set(atom, previousValue)\n\t\t}\n\t} else if (inst.globalIsReacting) {\n\t\t// If the atom changed during the reaction phase of flushChanges\n\t\t// (and there are no transactions started inside the reaction phase)\n\t\t// then we are past the point where a transaction can be aborted\n\t\t// so we don't need to note down the previousValue.\n\t\ttraverseAtomForCleanup(atom)\n\t} else {\n\t\t// If there is no transaction, flush the changes immediately.\n\t\tflushChanges([atom])\n\t}\n}\n\nfunction traverseAtomForCleanup(atom: _Atom) {\n\tconst rs = (inst.cleanupReactors ??= new Set())\n\tatom.children.visit((child) => traverse(rs, child))\n}\n\n/**\n * Advances the global epoch counter by one.\n * This is used internally to track when changes occur across the reactive system.\n *\n * @internal\n */\nexport function advanceGlobalEpoch() {\n\tinst.globalEpoch++\n}\n\n/**\n * Batches state updates, deferring side effects until after the transaction completes.\n * Unlike {@link transact}, this function always creates a new transaction, allowing for nested transactions.\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n * })\n *\n * // Logs \"Hello, Jane Smith!\"\n * ```\n *\n * If the function throws, the transaction is aborted and any signals that were updated during the transaction revert to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  throw new Error('oops')\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * ```\n *\n * A `rollback` callback is passed into the function.\n * Calling this will prevent the transaction from committing and will revert any signals that were updated during the transaction to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction((rollback) => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n *  rollback()\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * // lastName.get() === 'Doe'\n * ```\n *\n * @param fn - The function to run in a transaction, called with a function to roll back the change.\n * @returns The return value of the function\n * @public\n */\nexport function transaction<T>(fn: (rollback: () => void) => T) {\n\tconst txn = new Transaction(inst.currentTransaction, true)\n\n\t// Set the current transaction to the transaction\n\tinst.currentTransaction = txn\n\n\ttry {\n\t\tlet result = undefined as T | undefined\n\t\tlet rollback = false\n\n\t\ttry {\n\t\t\t// Run the function.\n\t\t\tresult = fn(() => (rollback = true))\n\t\t} catch (e) {\n\t\t\t// Abort the transaction if the function throws.\n\t\t\ttxn.abort()\n\t\t\tthrow e\n\t\t}\n\n\t\tif (inst.currentTransaction !== txn) {\n\t\t\tthrow new Error('Transaction boundaries overlap')\n\t\t}\n\n\t\tif (rollback) {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\ttxn.abort()\n\t\t} else {\n\t\t\ttxn.commit()\n\t\t}\n\n\t\treturn result\n\t} finally {\n\t\t// Set the current transaction to the transaction's parent.\n\t\tinst.currentTransaction = txn.parent\n\t}\n}\n\n/**\n * Like {@link transaction}, but does not create a new transaction if there is already one in progress.\n * This is the preferred way to batch state updates when you don't need the rollback functionality.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const doubled = atom('doubled', 0)\n *\n * react('update doubled', () => {\n *   console.log(`Count: ${count.get()}, Doubled: ${doubled.get()}`)\n * })\n *\n * // This batches both updates into a single reaction\n * transact(() => {\n *   count.set(5)\n *   doubled.set(count.get() * 2)\n * })\n * // Logs: \"Count: 5, Doubled: 10\"\n * ```\n *\n * @param fn - The function to run in a transaction\n * @returns The return value of the function\n * @public\n */\nexport function transact<T>(fn: () => T): T {\n\tif (inst.currentTransaction) {\n\t\treturn fn()\n\t}\n\treturn transaction(fn)\n}\n\n/**\n * Defers the execution of asynchronous effects until they can be properly handled.\n * This function creates an asynchronous transaction context that batches state updates\n * across async operations while preventing conflicts with synchronous transactions.\n *\n * @example\n * ```ts\n * const data = atom('data', null)\n * const loading = atom('loading', false)\n *\n * await deferAsyncEffects(async () => {\n *   loading.set(true)\n *   const result = await fetch('/api/data')\n *   const json = await result.json()\n *   data.set(json)\n *   loading.set(false)\n * })\n * ```\n *\n * @param fn - The async function to execute within the deferred context\n * @returns A promise that resolves to the return value of the function\n * @throws Will throw if called during a synchronous transaction\n * @internal\n */\nexport async function deferAsyncEffects<T>(fn: () => Promise<T>) {\n\t// Can't kick off async transactions during a sync transaction because\n\t// the async transaction won't finish until after the sync transaction\n\t// is done.\n\tif (inst.currentTransaction?.isSync) {\n\t\tthrow new Error('deferAsyncEffects cannot be called during a sync transaction')\n\t}\n\n\t// Can't kick off async transactions during a reaction phase at the moment,\n\t// because the transaction stack is cleared after the reaction phase.\n\t// So wait until the path ahead is clear\n\twhile (inst.globalIsReacting) {\n\t\tawait new Promise((r) => queueMicrotask(() => r(null)))\n\t}\n\n\tconst txn = inst.currentTransaction ?? new Transaction(null, false)\n\n\t// don't think this can happen, but just in case\n\tif (txn.isSync) throw new Error('deferAsyncEffects cannot be called during a sync transaction')\n\n\tinst.currentTransaction = txn\n\ttxn.asyncProcessCount++\n\n\tlet result = undefined as T | undefined\n\n\tlet error = undefined as any\n\ttry {\n\t\t// Run the function.\n\t\tresult = await fn()\n\t} catch (e) {\n\t\t// Abort the transaction if the function throws.\n\t\terror = e ?? null\n\t}\n\n\tif (--txn.asyncProcessCount > 0) {\n\t\tif (typeof error !== 'undefined') {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\tthrow error\n\t\t} else {\n\t\t\treturn result\n\t\t}\n\t}\n\n\tinst.currentTransaction = null\n\n\tif (typeof error !== 'undefined') {\n\t\t// If the rollback was triggered, abort the transaction.\n\t\ttxn.abort()\n\t\tthrow error\n\t} else {\n\t\ttxn.commit()\n\t\treturn result\n\t}\n}\n"],"names":["reactors"],"mappings":"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","debugId":null}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/warnings.ts"],"sourcesContent":["/**\n * Flag to track whether the computed getter deprecation warning has already been shown.\n * Prevents the same warning from being logged multiple times during application runtime.\n *\n * @internal\n */\nlet didWarnComputedGetter = false\n\n/**\n * Logs a deprecation warning for the deprecated `@computed` getter decorator syntax.\n * This function is called internally when the library detects usage of `@computed`\n * on a getter method instead of the recommended method syntax.\n *\n * The warning is only shown once per application session to avoid spam in the console.\n * It provides clear guidance on how to migrate from the deprecated getter syntax\n * to the current method-based approach.\n *\n * @example\n * ```ts\n * // Deprecated pattern that triggers this warning:\n * class MyClass {\n *   @computed\n *   get value() {\n *     return this.someAtom.get()\n *   }\n * }\n *\n * // Recommended pattern:\n * class MyClass {\n *   @computed\n *   getValue() {\n *     return this.someAtom.get()\n *   }\n * }\n * ```\n *\n * @internal\n */\nexport function logComputedGetterWarning() {\n\tif (didWarnComputedGetter) return\n\tdidWarnComputedGetter = true\n\tconsole.warn(\n\t\t`Using \\`@computed\\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \\`@computed\\` as a decorator for methods.\n\n// Before\n@computed\nget foo() {\n\treturn 'foo'\n}\n\n// After\n@computed\ngetFoo() {\n\treturn 'foo'\n}\n`\n\t)\n}\n"],"names":[],"mappings":";;;;AAMA,IAAI,wBAAwB;AAgCrB,SAAS,2BAA2B;IAC1C,IAAI,sBAAuB,CAAA;IAC3B,wBAAwB;IACxB,QAAQ,IAAA,CACP,CAAA;;;;;;;;;;;;;AAAA,CAAA;AAeF","debugId":null}},
    {"offset": {"line": 838, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/Computed.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { assert } from '@tldraw/utils'\nimport { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { EMPTY_ARRAY, equals, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch, getIsReacting, getReactionEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\nimport { logComputedGetterWarning } from './warnings'\n\n/**\n * A special symbol used to indicate that a computed signal has not been initialized yet.\n * This is passed as the `previousValue` parameter to a computed signal function on its first run.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     console.log('First computation!')\n *   }\n *   return count.get() * 2\n * })\n * ```\n *\n * @public\n */\nexport const UNINITIALIZED = Symbol.for('com.tldraw.state/UNINITIALIZED')\n/**\n * The type of the first value passed to a computed signal function as the 'prevValue' parameter.\n * This type represents the uninitialized state of a computed signal before its first calculation.\n *\n * @see {@link isUninitialized}\n * @public\n */\nexport type UNINITIALIZED = typeof UNINITIALIZED\n\n/**\n * Call this inside a computed signal function to determine whether it is the first time the function is being called.\n *\n * Mainly useful for incremental signal computation.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     print('First time!')\n *   }\n *   return count.get() * 2\n * })\n * ```\n *\n * @param value - The value to check.\n * @public\n */\nexport function isUninitialized(value: any): value is UNINITIALIZED {\n\treturn value === UNINITIALIZED\n}\n\n/**\n * A singleton class used to wrap computed signal values along with their diffs.\n * This class is used internally by the {@link withDiff} function to provide both\n * the computed value and its diff to the signal system.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.get() * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * })\n * ```\n *\n * @public\n */\nexport const WithDiff = singleton(\n\t'WithDiff',\n\t() =>\n\t\tclass WithDiff<Value, Diff> {\n\t\t\tconstructor(\n\t\t\t\tpublic value: Value,\n\t\t\t\tpublic diff: Diff\n\t\t\t) {}\n\t\t}\n)\n\n/**\n * Interface representing a value wrapped with its corresponding diff.\n * Used in incremental computation to provide both the new value and the diff from the previous value.\n *\n * @public\n */\nexport interface WithDiff<Value, Diff> {\n\t/**\n\t * The computed value.\n\t */\n\tvalue: Value\n\t/**\n\t * The diff between the previous and current value.\n\t */\n\tdiff: Diff\n}\n\n/**\n * When writing incrementally-computed signals it is convenient (and usually more performant) to incrementally compute the diff too.\n *\n * You can use this function to wrap the return value of a computed signal function to indicate that the diff should be used instead of calculating a new one with {@link AtomOptions.computeDiff}.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.get() * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * }, { historyLength: 10 })\n * ```\n *\n *\n * @param value - The value.\n * @param diff - The diff.\n * @public\n */\nexport function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff> {\n\treturn new WithDiff(value, diff)\n}\n\n/**\n * Options for configuring computed signals. Used when calling `computed` or using the `@computed` decorator.\n *\n * @example\n * ```ts\n * const greeting = computed('greeting', () => `Hello ${name.get()}!`, {\n *   historyLength: 10,\n *   isEqual: (a, b) => a === b,\n *   computeDiff: (oldVal, newVal) => ({ type: 'change', from: oldVal, to: newVal })\n * })\n * ```\n *\n * @public\n */\nexport interface ComputedOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via {@link Atom.set}, you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the computed's old and new values. If provided, it will not be used unless you also specify {@link ComputedOptions.historyLength}.\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the computed to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns True if the values are equal, false otherwise.\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * A computed signal created via the `computed` function or `@computed` decorator.\n * Computed signals derive their values from other signals and automatically update when their dependencies change.\n * They use lazy evaluation, only recalculating when accessed and dependencies have changed.\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n * const fullName = computed('fullName', () => `${firstName.get()} ${lastName.get()}`)\n *\n * console.log(fullName.get()) // \"John Doe\"\n * firstName.set('Jane')\n * console.log(fullName.get()) // \"Jane Doe\"\n * ```\n *\n * @public\n */\nexport interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Whether this computed signal is involved in an actively-running effect graph.\n\t * Returns true if there are any reactions or other computed signals depending on this one.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\t/** @internal */\n\treadonly parentEpochs: number[]\n}\n\n/**\n * @internal\n */\nclass __UNSAFE__Computed<Value, Diff = unknown> implements Computed<Value, Diff> {\n\tlastChangedEpoch = GLOBAL_START_EPOCH\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null = null\n\n\t/**\n\t * The epoch when the reactor was last checked.\n\t */\n\tprivate lastCheckedEpoch = GLOBAL_START_EPOCH\n\n\tparentSet = new ArraySet<Signal<any, any>>()\n\tparents: Signal<any, any>[] = []\n\tparentEpochs: number[] = []\n\n\tchildren = new ArraySet<Child>()\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening(): boolean {\n\t\treturn !this.children.isEmpty\n\t}\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t// The last-computed value of this signal.\n\tprivate state: Value = UNINITIALIZED as unknown as Value\n\t// If the signal throws an error we stash it so we can rethrow it on the next get()\n\tprivate error: null | { thrownValue: any } = null\n\n\tprivate computeDiff?: ComputeDiff<Value, Diff>\n\n\tprivate readonly isEqual: (a: any, b: any) => boolean\n\n\tconstructor(\n\t\t/**\n\t\t * The name of the signal. This is used for debugging and performance profiling purposes. It does not need to be globally unique.\n\t\t */\n\t\tpublic readonly name: string,\n\t\t/**\n\t\t * The function that computes the value of the signal.\n\t\t */\n\t\tprivate readonly derive: (\n\t\t\tpreviousValue: Value | UNINITIALIZED,\n\t\t\tlastComputedEpoch: number\n\t\t) => Value | WithDiff<Value, Diff>,\n\t\toptions?: ComputedOptions<Value, Diff>\n\t) {\n\t\tif (options?.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\t\tthis.computeDiff = options?.computeDiff\n\t\tthis.isEqual = options?.isEqual ?? equals\n\t}\n\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value {\n\t\tconst isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH\n\n\t\tconst globalEpoch = getGlobalEpoch()\n\n\t\tif (\n\t\t\t!isNew &&\n\t\t\t(this.lastCheckedEpoch === globalEpoch ||\n\t\t\t\t(this.isActivelyListening &&\n\t\t\t\t\tgetIsReacting() &&\n\t\t\t\t\tthis.lastTraversedEpoch < getReactionEpoch()) ||\n\t\t\t\t!haveParentsChanged(this))\n\t\t) {\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\t\t\tif (this.error) {\n\t\t\t\tif (!ignoreErrors) {\n\t\t\t\t\tthrow this.error.thrownValue\n\t\t\t\t} else {\n\t\t\t\t\treturn this.state // will be UNINITIALIZED\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.state\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.derive(this.state, this.lastCheckedEpoch)\n\t\t\tconst newState = result instanceof WithDiff ? result.value : result\n\t\t\tconst isUninitialized = this.state === UNINITIALIZED\n\t\t\tif (isUninitialized || !this.isEqual(newState, this.state)) {\n\t\t\t\tif (this.historyBuffer && !isUninitialized) {\n\t\t\t\t\tconst diff = result instanceof WithDiff ? result.diff : undefined\n\t\t\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\t\t\tgetGlobalEpoch(),\n\t\t\t\t\t\tdiff ??\n\t\t\t\t\t\t\tthis.computeDiff?.(this.state, newState, this.lastCheckedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\t\t\tRESET_VALUE\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t\tthis.state = newState\n\t\t\t}\n\t\t\tthis.error = null\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\n\t\t\treturn this.state\n\t\t} catch (e) {\n\t\t\t// if a derived value throws an error, we reset the state to UNINITIALIZED\n\t\t\tif (this.state !== UNINITIALIZED) {\n\t\t\t\tthis.state = UNINITIALIZED as unknown as Value\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t}\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\t\t\t// we also clear the history buffer if an error was thrown\n\t\t\tif (this.historyBuffer) {\n\t\t\t\tthis.historyBuffer.clear()\n\t\t\t}\n\t\t\tthis.error = { thrownValue: e }\n\t\t\t// we don't wish to propagate errors when derefed via haveParentsChanged()\n\t\t\tif (!ignoreErrors) throw e\n\t\t\treturn this.state\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n\n\tget(): Value {\n\t\ttry {\n\t\t\treturn this.__unsafe__getWithoutCapture()\n\t\t} finally {\n\t\t\t// if the deriver throws an error we still need to capture\n\t\t\tmaybeCaptureParent(this)\n\t\t}\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\t// we can ignore any errors thrown during derive\n\t\tthis.__unsafe__getWithoutCapture(true)\n\t\t// and we still need to capture this signal as a parent\n\t\tmaybeCaptureParent(this)\n\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\n/**\n * Singleton reference to the computed signal implementation class.\n * Used internally by the library to create computed signal instances.\n *\n * @internal\n */\nexport const _Computed = singleton('Computed', () => __UNSAFE__Computed)\n\n/**\n * Type alias for the computed signal implementation class.\n *\n * @internal\n */\nexport type _Computed = InstanceType<typeof __UNSAFE__Computed>\n\nfunction computedMethodLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.value\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.value = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tdescriptor.value[isComputedMethodKey] = true\n\n\treturn descriptor\n}\n\nfunction computedGetterLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.get\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.get = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\n\treturn descriptor\n}\n\nfunction computedMethodTc39Decorator<This extends object, Value>(\n\toptions: ComputedOptions<Value, any>,\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n) {\n\tassert(context.kind === 'method', '@computed can only be used on methods')\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + String(context.name))\n\n\tconst fn = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(String(context.name), compute.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tfn[isComputedMethodKey] = true\n\treturn fn\n}\n\nfunction computedDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\targs:\n\t\t| [target: any, key: string, descriptor: PropertyDescriptor]\n\t\t| [originalMethod: () => any, context: ClassMethodDecoratorContext]\n) {\n\tif (args.length === 2) {\n\t\tconst [originalMethod, context] = args\n\t\treturn computedMethodTc39Decorator(options, originalMethod, context)\n\t} else {\n\t\tconst [_target, key, descriptor] = args\n\t\tif (descriptor.get) {\n\t\t\tlogComputedGetterWarning()\n\t\t\treturn computedGetterLegacyDecorator(options, _target, key, descriptor)\n\t\t} else {\n\t\t\treturn computedMethodLegacyDecorator(options, _target, key, descriptor)\n\t\t}\n\t}\n}\n\nconst isComputedMethodKey = '@@__isComputedMethod__@@'\n\n/**\n * Retrieves the underlying computed instance for a given property created with the `computed`\n * decorator.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n *\n * const c = new Counter()\n * const remaining = getComputedInstance(c, 'getRemaining')\n * remaining.get() === 100 // true\n * c.count.set(13)\n * remaining.get() === 87 // true\n * ```\n *\n * @param obj - The object\n * @param propertyName - The property name\n * @public\n */\nexport function getComputedInstance<Obj extends object, Prop extends keyof Obj>(\n\tobj: Obj,\n\tpropertyName: Prop\n): Computed<Obj[Prop]> {\n\tconst key = Symbol.for('__@tldraw/state__computed__' + propertyName.toString())\n\tlet inst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\tif (!inst) {\n\t\t// deref to make sure it exists first\n\t\tconst val = obj[propertyName]\n\t\tif (typeof val === 'function' && (val as any)[isComputedMethodKey]) {\n\t\t\tval.call(obj)\n\t\t}\n\n\t\tinst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\t}\n\treturn inst as any\n}\n\n/**\n * Creates a computed signal that derives its value from other signals.\n * Computed signals automatically update when their dependencies change and use lazy evaluation\n * for optimal performance.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n * const greeting = computed('greeting', () => `Hello ${name.get()}!`)\n * console.log(greeting.get()) // 'Hello John!'\n * ```\n *\n * `computed` may also be used as a decorator for creating computed getter methods.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * You may optionally pass in a {@link ComputedOptions} when used as a decorator:\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed({isEqual: (a, b) => a === b})\n *   getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * @param name - The name of the signal for debugging purposes\n * @param compute - The function that computes the value of the signal. Receives the previous value and last computed epoch\n * @param options - Optional configuration for the computed signal\n * @returns A new computed signal\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: (\n\t\tpreviousValue: Value | typeof UNINITIALIZED,\n\t\tlastComputedEpoch: number\n\t) => Value | WithDiff<Value, Diff>,\n\toptions?: ComputedOptions<Value, Diff>\n): Computed<Value, Diff>\n/**\n * TC39 decorator for creating computed methods in classes.\n *\n * @example\n * ```ts\n * class MyClass {\n *   value = atom('value', 10)\n *\n *   @computed\n *   doubled() {\n *     return this.value.get() * 2\n *   }\n * }\n * ```\n *\n * @param compute - The method to be decorated\n * @param context - The decorator context provided by TypeScript\n * @returns The decorated method\n * @public\n */\nexport function computed<This extends object, Value>(\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n): () => Value\n/**\n * Legacy TypeScript decorator for creating computed methods in classes.\n *\n * @example\n * ```ts\n * class MyClass {\n *   value = atom('value', 10)\n *\n *   @computed\n *   doubled() {\n *     return this.value.get() * 2\n *   }\n * }\n * ```\n *\n * @param target - The class prototype\n * @param key - The property key\n * @param descriptor - The property descriptor\n * @returns The modified property descriptor\n * @public\n */\nexport function computed(\n\ttarget: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n): PropertyDescriptor\n/**\n * Decorator factory for creating computed methods with options.\n *\n * @example\n * ```ts\n * class MyClass {\n *   items = atom('items', [1, 2, 3])\n *\n *   @computed({ historyLength: 10 })\n *   sum() {\n *     return this.items.get().reduce((a, b) => a + b, 0)\n *   }\n * }\n * ```\n *\n * @param options - Configuration options for the computed signal\n * @returns A decorator function that can be applied to methods\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\toptions?: ComputedOptions<Value, Diff>\n): ((target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor) &\n\t(<This>(\n\t\tcompute: () => Value,\n\t\tcontext: ClassMethodDecoratorContext<This, () => Value>\n\t) => () => Value)\n\n/**\n * Implementation function that handles all computed signal creation and decoration scenarios.\n * This function is overloaded to support multiple usage patterns:\n * - Creating computed signals directly\n * - Using as a TC39 decorator\n * - Using as a legacy decorator\n * - Using as a decorator factory with options\n *\n * @returns Either a computed signal instance or a decorator function depending on usage\n * @public\n */\nexport function computed() {\n\tif (arguments.length === 1) {\n\t\tconst options = arguments[0]\n\t\treturn (...args: any) => computedDecorator(options, args)\n\t} else if (typeof arguments[0] === 'string') {\n\t\treturn new _Computed(arguments[0], arguments[1], arguments[2])\n\t} else {\n\t\treturn computedDecorator(undefined, arguments as any)\n\t}\n}\n\n/**\n * Returns true if the given value is a computed signal.\n * This is a type guard function that can be used to check if a value is a computed signal instance.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', () => count.get() * 2)\n *\n * console.log(isComputed(count))  // false\n * console.log(isComputed(double)) // true\n * ```\n *\n * @param value - The value to check\n * @returns True if the value is a computed signal, false otherwise\n * @public\n */\nexport function isComputed(value: any): value is Computed<any> {\n\treturn !!(value && value instanceof _Computed)\n}\n"],"names":["isUninitialized"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1087, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/capture.ts"],"sourcesContent":["import { isComputed } from './Computed'\nimport { attach, detach, singleton } from './helpers'\nimport type { Child, Signal } from './types'\n\nclass CaptureStackFrame {\n\toffset = 0\n\n\tmaybeRemoved?: Signal<any>[]\n\n\tconstructor(\n\t\tpublic readonly below: CaptureStackFrame | null,\n\t\tpublic readonly child: Child\n\t) {}\n}\n\nconst inst = singleton('capture', () => ({ stack: null as null | CaptureStackFrame }))\n\n/**\n * Executes the given function without capturing any parents in the current capture context.\n *\n * This is mainly useful if you want to run an effect only when certain signals change while also\n * dereferencing other signals which should not cause the effect to rerun on their own.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Sam')\n * const time = atom('time', () => new Date().getTime())\n *\n * setInterval(() => {\n *   time.set(new Date().getTime())\n * })\n *\n * react('log name changes', () => {\n * \t print(name.get(), 'was changed at', unsafe__withoutCapture(() => time.get()))\n * })\n *\n * ```\n *\n * @public\n */\nexport function unsafe__withoutCapture<T>(fn: () => T): T {\n\tconst oldStack = inst.stack\n\tinst.stack = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tinst.stack = oldStack\n\t}\n}\n\n/**\n * Begins capturing parent signal dependencies for the given child signal.\n *\n * This function initiates a capture session where any signal accessed via `.get()`\n * will be automatically registered as a dependency of the child signal. It sets up\n * the capture stack frame and clears the existing parent set to prepare for fresh\n * dependency tracking.\n *\n * @param child - The child signal (computed or effect) that will capture dependencies\n *\n * @example\n * ```ts\n * const effect = createEffect('myEffect', () => { /* ... *\\/ })\n * startCapturingParents(effect)\n * // Now any signal.get() calls will be captured as dependencies\n * ```\n *\n * @internal\n */\nexport function startCapturingParents(child: Child) {\n\tinst.stack = new CaptureStackFrame(inst.stack, child)\n\tif (child.__debug_ancestor_epochs__) {\n\t\tconst previousAncestorEpochs = child.__debug_ancestor_epochs__\n\t\tchild.__debug_ancestor_epochs__ = null\n\t\tfor (const p of child.parents) {\n\t\t\tp.__unsafe__getWithoutCapture(true)\n\t\t}\n\t\tlogChangedAncestors(child, previousAncestorEpochs)\n\t}\n\tchild.parentSet.clear()\n}\n\n/**\n * Completes the parent dependency capture session and finalizes the dependency graph.\n *\n * This function cleans up the capture session by removing dependencies that are no\n * longer needed, detaching signals that should no longer be parents, and updating\n * the dependency arrays to reflect the current set of captured parents. It must be\n * called after `startCapturingParents` to complete the capture cycle.\n *\n * @example\n * ```ts\n * startCapturingParents(effect)\n * // ... signal.get() calls happen here ...\n * stopCapturingParents() // Finalizes the dependency graph\n * ```\n *\n * @internal\n */\nexport function stopCapturingParents() {\n\tconst frame = inst.stack!\n\tinst.stack = frame.below\n\n\tif (frame.offset < frame.child.parents.length) {\n\t\tfor (let i = frame.offset; i < frame.child.parents.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.child.parents[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\n\t\tframe.child.parents.length = frame.offset\n\t\tframe.child.parentEpochs.length = frame.offset\n\t}\n\n\tif (frame.maybeRemoved) {\n\t\tfor (let i = 0; i < frame.maybeRemoved.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.maybeRemoved[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (frame.child.__debug_ancestor_epochs__) {\n\t\tcaptureAncestorEpochs(frame.child, frame.child.__debug_ancestor_epochs__)\n\t}\n}\n\n/**\n * Conditionally captures a signal as a parent dependency during an active capture session.\n *\n * This function is called whenever a signal's `.get()` method is invoked during a\n * capture session. It checks if the signal should be added as a dependency and manages\n * the parent-child relationship in the reactive graph. The function handles deduplication,\n * attachment/detachment, and tracks changes in dependency order.\n *\n * Note: This must be called after the parent signal is up to date.\n *\n * @param p - The signal that might be captured as a parent dependency\n *\n * @example\n * ```ts\n * // This is called internally when you do:\n * const value = someAtom.get() // maybeCaptureParent(someAtom) is called\n * ```\n *\n * @internal\n */\nexport function maybeCaptureParent(p: Signal<any, any>) {\n\tif (inst.stack) {\n\t\tconst wasCapturedAlready = inst.stack.child.parentSet.has(p)\n\t\t// if the child didn't deref this parent last time it executed, then idx will be -1\n\t\t// if the child did deref this parent last time but in a different order relative to other parents, then idx will be greater than stack.offset\n\t\t// if the child did deref this parent last time in the same order, then idx will be the same as stack.offset\n\t\t// if the child did deref this parent already during this capture session then 0 <= idx < stack.offset\n\n\t\tif (wasCapturedAlready) {\n\t\t\treturn\n\t\t}\n\n\t\tinst.stack.child.parentSet.add(p)\n\t\tif (inst.stack.child.isActivelyListening) {\n\t\t\tattach(p, inst.stack.child)\n\t\t}\n\n\t\tif (inst.stack.offset < inst.stack.child.parents.length) {\n\t\t\tconst maybeRemovedParent = inst.stack.child.parents[inst.stack.offset]\n\t\t\tif (maybeRemovedParent !== p) {\n\t\t\t\tif (!inst.stack.maybeRemoved) {\n\t\t\t\t\tinst.stack.maybeRemoved = [maybeRemovedParent]\n\t\t\t\t} else {\n\t\t\t\t\tinst.stack.maybeRemoved.push(maybeRemovedParent)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinst.stack.child.parents[inst.stack.offset] = p\n\t\tinst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch\n\t\tinst.stack.offset++\n\t}\n}\n\n/**\n * A debugging tool that tells you why a computed signal or effect is running.\n * Call in the body of a computed signal or effect function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Bob')\n * react('greeting', () => {\n * \twhyAmIRunning()\n *\tprint('Hello', name.get())\n * })\n *\n * name.set('Alice')\n *\n * // 'greeting' is running because:\n * //     'name' changed => 'Alice'\n * ```\n *\n * @public\n */\nexport function whyAmIRunning() {\n\tconst child = inst.stack?.child\n\tif (!child) {\n\t\tthrow new Error('whyAmIRunning() called outside of a reactive context')\n\t}\n\tchild.__debug_ancestor_epochs__ = new Map()\n}\n\nfunction captureAncestorEpochs(child: Child, ancestorEpochs: Map<Signal<any>, number>) {\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\t\tconst epoch = child.parentEpochs[i]\n\t\tancestorEpochs.set(parent, epoch)\n\t\tif (isComputed(parent)) {\n\t\t\tcaptureAncestorEpochs(parent as any, ancestorEpochs)\n\t\t}\n\t}\n\treturn ancestorEpochs\n}\n\ntype ChangeTree = { [signalName: string]: ChangeTree } | null\nfunction collectChangedAncestors(\n\tchild: Child,\n\tancestorEpochs: Map<Signal<any>, number>\n): NonNullable<ChangeTree> {\n\tconst changeTree: ChangeTree = {}\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\t\tif (!ancestorEpochs.has(parent)) {\n\t\t\tcontinue\n\t\t}\n\t\tconst prevEpoch = ancestorEpochs.get(parent)\n\t\tconst currentEpoch = parent.lastChangedEpoch\n\t\tif (currentEpoch !== prevEpoch) {\n\t\t\tif (isComputed(parent)) {\n\t\t\t\tchangeTree[parent.name] = collectChangedAncestors(parent as any, ancestorEpochs)\n\t\t\t} else {\n\t\t\t\tchangeTree[parent.name] = null\n\t\t\t}\n\t\t}\n\t}\n\treturn changeTree\n}\n\nfunction logChangedAncestors(child: Child, ancestorEpochs: Map<Signal<any>, number>) {\n\tconst changeTree = collectChangedAncestors(child, ancestorEpochs)\n\tif (Object.keys(changeTree).length === 0) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(`Effect(${child.name}) was executed manually.`)\n\t\treturn\n\t}\n\n\tlet str = isComputed(child)\n\t\t? `Computed(${child.name}) is recomputing because:`\n\t\t: `Effect(${child.name}) is executing because:`\n\n\tfunction logParent(tree: NonNullable<ChangeTree>, indent: number) {\n\t\tconst indentStr = '\\n' + ' '.repeat(indent) + '\u21B3 '\n\t\tfor (const [name, val] of Object.entries(tree)) {\n\t\t\tif (val) {\n\t\t\t\tstr += `${indentStr}Computed(${name}) changed`\n\t\t\t\tlogParent(val, indent + 2)\n\t\t\t} else {\n\t\t\t\tstr += `${indentStr}Atom(${name}) changed`\n\t\t\t}\n\t\t}\n\t}\n\n\tlogParent(changeTree, 1)\n\n\t// eslint-disable-next-line no-console\n\tconsole.log(str)\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1251, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/Atom.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent } from './capture'\nimport { EMPTY_ARRAY, equals, singleton } from './helpers'\nimport { advanceGlobalEpoch, atomDidChange, getGlobalEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\n\n/**\n * The options to configure an atom, passed into the {@link atom} function.\n * @public\n */\nexport interface AtomOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via {@link Atom.set}, you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify {@link AtomOptions.historyLength}.\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns True if the values are equal, false otherwise.\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * An Atom is a signal that can be updated directly by calling {@link Atom.set} or {@link Atom.update}.\n *\n * Atoms are created using the {@link atom} function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * print(name.get()) // 'John'\n * ```\n *\n * @public\n */\nexport interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set.\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using {@link AtomOptions.computeDiff}.\n\t */\n\tset(value: Value, diff?: Diff): Value\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value.\n\t */\n\tupdate(updater: (value: Value) => Value): Value\n}\n\n/**\n * Internal implementation of the Atom interface. This class should not be used directly - use the {@link atom} function instead.\n *\n * @internal\n */\nclass __Atom__<Value, Diff = unknown> implements Atom<Value, Diff> {\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate current: Value,\n\t\toptions?: AtomOptions<Value, Diff>\n\t) {\n\t\tthis.isEqual = options?.isEqual ?? null\n\n\t\tif (!options) return\n\n\t\tif (options.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\n\t\tthis.computeDiff = options.computeDiff\n\t}\n\n\t/**\n\t * Custom equality function for comparing values, or null to use default equality.\n\t * @internal\n\t */\n\treadonly isEqual: null | ((a: any, b: any) => boolean)\n\n\t/**\n\t * Optional function to compute diffs between old and new values.\n\t * @internal\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\n\t/**\n\t * The global epoch when this atom was last changed.\n\t * @internal\n\t */\n\tlastChangedEpoch = getGlobalEpoch()\n\n\t/**\n\t * Set of child signals that depend on this atom.\n\t * @internal\n\t */\n\tchildren = new ArraySet<Child>()\n\n\t/**\n\t * Optional history buffer for tracking changes over time.\n\t * @internal\n\t */\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t/**\n\t * Gets the current value without capturing it as a dependency in the current reactive context.\n\t * This is unsafe because it breaks the reactivity chain - use with caution.\n\t *\n\t * @param _ignoreErrors - Unused parameter for API compatibility\n\t * @returns The current value\n\t * @internal\n\t */\n\t__unsafe__getWithoutCapture(_ignoreErrors?: boolean): Value {\n\t\treturn this.current\n\t}\n\n\t/**\n\t * Gets the current value of this atom. When called within a computed signal or reaction,\n\t * this atom will be automatically captured as a dependency.\n\t *\n\t * @returns The current value\n\t * @example\n\t * ```ts\n\t * const count = atom('count', 5)\n\t * console.log(count.get()) // 5\n\t * ```\n\t */\n\tget() {\n\t\tmaybeCaptureParent(this)\n\t\treturn this.current\n\t}\n\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using {@link AtomOptions.computeDiff}\n\t * @returns The new value\n\t * @example\n\t * ```ts\n\t * const count = atom('count', 0)\n\t * count.set(5) // count.get() is now 5\n\t * ```\n\t */\n\tset(value: Value, diff?: Diff): Value {\n\t\t// If the value has not changed, do nothing.\n\t\tif (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {\n\t\t\treturn this.current\n\t\t}\n\n\t\t// Tick forward the global epoch\n\t\tadvanceGlobalEpoch()\n\n\t\t// Add the diff to the history buffer.\n\t\tif (this.historyBuffer) {\n\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\tgetGlobalEpoch(),\n\t\t\t\tdiff ??\n\t\t\t\t\tthis.computeDiff?.(this.current, value, this.lastChangedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\tRESET_VALUE\n\t\t\t)\n\t\t}\n\n\t\t// Update the atom's record of the epoch when last changed.\n\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\n\t\tconst oldValue = this.current\n\t\tthis.current = value\n\n\t\t// Notify all children that this atom has changed.\n\t\tatomDidChange(this as any, oldValue)\n\n\t\treturn value\n\t}\n\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value\n\t * @returns The new value\n\t * @example\n\t * ```ts\n\t * const count = atom('count', 5)\n\t * count.update(n => n + 1) // count.get() is now 6\n\t * ```\n\t */\n\tupdate(updater: (value: Value) => Value): Value {\n\t\treturn this.set(updater(this.current))\n\t}\n\n\t/**\n\t * Gets all the diffs that have occurred since the given epoch. When called within a computed\n\t * signal or reaction, this atom will be automatically captured as a dependency.\n\t *\n\t * @param epoch - The epoch to get changes since\n\t * @returns An array of diffs, or RESET_VALUE if history is insufficient\n\t * @internal\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\tmaybeCaptureParent(this)\n\n\t\t// If no changes have occurred since the given epoch, return an empty array.\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\n/**\n * Singleton reference to the Atom constructor. Used internally to create atom instances.\n * @internal\n */\nexport const _Atom = singleton('Atom', () => __Atom__)\n\n/**\n * Type alias for instances of the internal Atom class.\n * @internal\n */\nexport type _Atom = InstanceType<typeof _Atom>\n\n/**\n * Creates a new {@link Atom}.\n *\n * An Atom is a signal that can be updated directly by calling {@link Atom.set} or {@link Atom.update}.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * name.get() // 'John'\n *\n * name.set('Jane')\n *\n * name.get() // 'Jane'\n * ```\n *\n * @public\n */\nexport function atom<Value, Diff = unknown>(\n\t/**\n\t * A name for the signal. This is used for debugging and profiling purposes, it does not need to be unique.\n\t */\n\tname: string,\n\t/**\n\t * The initial value of the signal.\n\t */\n\tinitialValue: Value,\n\t/**\n\t * The options to configure the atom. See {@link AtomOptions}.\n\t */\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn new _Atom(name, initialValue, options)\n}\n\n/**\n * Returns true if the given value is an {@link Atom}.\n *\n * @param value - The value to check\n * @returns True if the value is an Atom, false otherwise\n * @example\n * ```ts\n * const myAtom = atom('test', 42)\n * const notAtom = 'hello'\n *\n * console.log(isAtom(myAtom)) // true\n * console.log(isAtom(notAtom)) // false\n * ```\n * @public\n */\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn value instanceof _Atom\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,gBAAgB;AACzB,SAAS,qBAAqB;AAC9B,SAAS,0BAA0B;AACnC,SAAS,aAAa,QAAQ,iBAAiB;AAC/C,SAAS,oBAAoB,eAAe,sBAAsB;AAClE,SAA6B,mBAA2B;;;;;;;AAmExD,MAAM,SAA6D;IAClE,YACiB,IAAA,EACR,OAAA,EACR,OAAA,CACC;QAHe,IAAA,CAAA,IAAA,GAAA;QACR,IAAA,CAAA,OAAA,GAAA;QAGR,IAAA,CAAK,OAAA,GAAU,SAAS,WAAW;QAEnC,IAAI,CAAC,QAAS,CAAA;QAEd,IAAI,QAAQ,aAAA,EAAe;YAC1B,IAAA,CAAK,aAAA,GAAgB,IAAI,6LAAA,CAAc,QAAQ,aAAa;QAC7D;QAEA,IAAA,CAAK,WAAA,GAAc,QAAQ,WAAA;IAC5B;IAAA;;;GAAA,GAMS,QAAA;IAAA;;;GAAA,GAMT,YAAA;IAAA;;;GAAA,GAMA,uBAAmB,6LAAA,CAAe,GAAA;IAAA;;;GAAA,GAMlC,WAAW,IAAI,mLAAA,CAAgB,EAAA;IAAA;;;GAAA,GAM/B,cAAA;IAAA;;;;;;;GAAA,GAUA,4BAA4B,aAAA,EAAgC;QAC3D,OAAO,IAAA,CAAK,OAAA;IACb;IAAA;;;;;;;;;;GAAA,GAaA,MAAM;QACL,IAAA,4LAAA,EAAmB,IAAI;QACvB,OAAO,IAAA,CAAK,OAAA;IACb;IAAA;;;;;;;;;;;GAAA,GAcA,IAAI,KAAA,EAAc,IAAA,EAAoB;QAErC,IAAI,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,EAAS,KAAK,SAAK,gLAAA,EAAO,IAAA,CAAK,OAAA,EAAS,KAAK,GAAG;YACvE,OAAO,IAAA,CAAK,OAAA;QACb;QAGA,IAAA,iMAAA,CAAmB;QAGnB,IAAI,IAAA,CAAK,aAAA,EAAe;YACvB,IAAA,CAAK,aAAA,CAAc,SAAA,CAClB,IAAA,CAAK,gBAAA,MACL,6LAAA,CAAe,IACf,QACC,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,OAAA,EAAS,OAAO,IAAA,CAAK,gBAAA,MAAkB,6LAAA,CAAe,CAAC,MAC/E,mLAAA;QAEH;QAGA,IAAA,CAAK,gBAAA,OAAmB,6LAAA,CAAe;QAEvC,MAAM,WAAW,IAAA,CAAK,OAAA;QACtB,IAAA,CAAK,OAAA,GAAU;QAGf,IAAA,4LAAA,EAAc,IAAA,EAAa,QAAQ;QAEnC,OAAO;IACR;IAAA;;;;;;;;;;GAAA,GAaA,OAAO,OAAA,EAAyC;QAC/C,OAAO,IAAA,CAAK,GAAA,CAAI,QAAQ,IAAA,CAAK,OAAO,CAAC;IACtC;IAAA;;;;;;;GAAA,GAUA,aAAa,KAAA,EAAqC;QACjD,IAAA,4LAAA,EAAmB,IAAI;QAGvB,IAAI,SAAS,IAAA,CAAK,gBAAA,EAAkB;YACnC,OAAO,qLAAA;QACR;QAEA,OAAO,IAAA,CAAK,aAAA,EAAe,gBAAgB,KAAK,KAAK,mLAAA;IACtD;AACD;AAMO,MAAM,YAAQ,mLAAA,EAAU,QAAQ,IAAM,QAAQ;AA0B9C,SAAS,KAIf,IAAA,EAIA,YAAA,EAIA,OAAA,EACoB;IACpB,OAAO,IAAI,MAAM,MAAM,cAAc,OAAO;AAC7C;AAiBO,SAAS,OAAO,KAAA,EAAwC;IAC9D,OAAO,iBAAiB;AACzB","debugId":null}},
    {"offset": {"line": 1392, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/isSignal.ts"],"sourcesContent":["import { _Atom } from './Atom'\nimport { _Computed } from './Computed'\nimport { Signal } from './types'\n\n/**\n * Type guard function that determines whether a value is a signal (either an Atom or Computed).\n *\n * This utility function is helpful when working with mixed data types and you need to\n * differentiate between regular values and reactive signal containers. It returns `true`\n * if the provided value is either an atomic signal created with `atom()` or a computed\n * signal created with `computed()`.\n *\n * @param value - The value to check, can be of any type\n * @returns `true` if the value is a Signal (Atom or Computed), `false` otherwise\n *\n * @example\n * ```ts\n * import { atom, computed, isSignal } from '@tldraw/state'\n *\n * const count = atom('count', 5)\n * const doubled = computed('doubled', () => count.get() * 2)\n * const regularValue = 'hello'\n *\n * console.log(isSignal(count))        // true\n * console.log(isSignal(doubled))      // true\n * console.log(isSignal(regularValue)) // false\n * console.log(isSignal(null))         // false\n * ```\n *\n * @public\n */\nexport function isSignal(value: any): value is Signal<any> {\n\treturn value instanceof _Atom || value instanceof _Computed\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa;AACtB,SAAS,iBAAiB;;;AA8BnB,SAAS,SAAS,KAAA,EAAkC;IAC1D,OAAO,iBAAiB,4KAAA,IAAS,iBAAiB,oLAAA;AACnD","debugId":null}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/lib/localStorageAtom.ts"],"sourcesContent":["import { deleteFromLocalStorage, getFromLocalStorage, setInLocalStorage } from '@tldraw/utils'\nimport { Atom, atom, AtomOptions } from './Atom'\nimport { react } from './EffectScheduler'\n\n/**\n * Creates a new {@link Atom} that persists its value to localStorage.\n *\n * The atom is automatically synced with localStorage - changes to the atom are saved to localStorage,\n * and the initial value is read from localStorage if it exists. Returns both the atom and a cleanup\n * function that should be called to stop syncing when the atom is no longer needed. If you need to delete\n * the atom, you should do it manually after all cleanup functions have been called.\n *\n * @example\n * ```ts\n * const [theme, cleanup] = localStorageAtom('theme', 'light')\n *\n * theme.get() // 'light' or value from localStorage if it exists\n *\n * theme.set('dark') // updates atom and saves to localStorage\n *\n * // When done:\n * cleanup() // stops syncing to localStorage\n * ```\n *\n * @param name - The localStorage key and atom name. This is used for both localStorage persistence\n *   and debugging/profiling purposes.\n * @param initialValue - The initial value of the atom, used if no value exists in localStorage.\n * @param options - Optional atom configuration. See {@link AtomOptions}.\n * @returns A tuple containing the atom and a cleanup function to stop localStorage syncing.\n * @public\n */\nexport function localStorageAtom<Value, Diff = unknown>(\n\tname: string,\n\tinitialValue: Value,\n\toptions?: AtomOptions<Value, Diff>\n): [Atom<Value, Diff>, () => void] {\n\t// Try to restore the initial value from localStorage\n\tlet _initialValue = initialValue\n\n\ttry {\n\t\tconst value = getFromLocalStorage(name)\n\t\tif (value) {\n\t\t\t_initialValue = JSON.parse(value) as Value\n\t\t}\n\t} catch {\n\t\t// If parsing fails, the stored value is corrupted - delete it and use the provided initial value\n\t\tdeleteFromLocalStorage(name)\n\t}\n\n\t// Create the atom with the restored or initial value\n\tconst outAtom = atom(name, _initialValue, options)\n\n\t// Set up automatic syncing: whenever the atom changes, save it to localStorage\n\tconst reactCleanup = react(`save ${name} to localStorage`, () => {\n\t\tsetInLocalStorage(name, JSON.stringify(outAtom.get()))\n\t})\n\n\t// Set up cross-tab sync: listen for storage events from other tabs\n\tconst handleStorageEvent = (event: StorageEvent) => {\n\t\t// Only handle events for this specific key\n\t\tif (event.key !== name) return\n\n\t\t// If the value was deleted in another tab\n\t\tif (event.newValue === null) {\n\t\t\toutAtom.set(initialValue)\n\t\t\treturn\n\t\t}\n\n\t\t// If the value was changed in another tab, update the atom\n\t\ttry {\n\t\t\tconst newValue = JSON.parse(event.newValue) as Value\n\t\t\toutAtom.set(newValue)\n\t\t} catch {\n\t\t\t// If parsing fails, the stored value is corrupted; preserve the existing value\n\t\t}\n\t}\n\n\twindow.addEventListener('storage', handleStorageEvent)\n\n\t// Combined cleanup function\n\tconst cleanup = () => {\n\t\treactCleanup()\n\t\twindow.removeEventListener('storage', handleStorageEvent)\n\t}\n\n\treturn [outAtom, cleanup]\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,wBAAwB,qBAAqB,yBAAyB;AAC/E,SAAe,YAAyB;AACxC,SAAS,aAAa;;;;AA6Bf,SAAS,iBACf,IAAA,EACA,YAAA,EACA,OAAA,EACkC;IAElC,IAAI,gBAAgB;IAEpB,IAAI;QACH,MAAM,YAAQ,6LAAA,EAAoB,IAAI;QACtC,IAAI,OAAO;YACV,gBAAgB,KAAK,KAAA,CAAM,KAAK;QACjC;IACD,EAAA,OAAQ;QAEP,IAAA,gMAAA,EAAuB,IAAI;IAC5B;IAGA,MAAM,cAAU,2KAAA,EAAK,MAAM,eAAe,OAAO;IAGjD,MAAM,mBAAe,uLAAA,EAAM,CAAA,KAAA,EAAQ,IAAI,CAAA,gBAAA,CAAA,EAAoB,MAAM;QAChE,IAAA,2LAAA,EAAkB,MAAM,KAAK,SAAA,CAAU,QAAQ,GAAA,CAAI,CAAC,CAAC;IACtD,CAAC;IAGD,MAAM,qBAAqB,CAAC,UAAwB;QAEnD,IAAI,MAAM,GAAA,KAAQ,KAAM,CAAA;QAGxB,IAAI,MAAM,QAAA,KAAa,MAAM;YAC5B,QAAQ,GAAA,CAAI,YAAY;YACxB;QACD;QAGA,IAAI;YACH,MAAM,WAAW,KAAK,KAAA,CAAM,MAAM,QAAQ;YAC1C,QAAQ,GAAA,CAAI,QAAQ;QACrB,EAAA,OAAQ,CAER;IACD;IAEA,OAAO,gBAAA,CAAiB,WAAW,kBAAkB;IAGrD,MAAM,UAAU,MAAM;QACrB,aAAa;QACb,OAAO,mBAAA,CAAoB,WAAW,kBAAkB;IACzD;IAEA,OAAO;QAAC;QAAS,OAAO;KAAA;AACzB","debugId":null}},
    {"offset": {"line": 1461, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport { singleton } from './lib/helpers'\n\nexport { ArraySet } from './lib/ArraySet'\nexport { atom, isAtom } from './lib/Atom'\nexport type { Atom, AtomOptions } from './lib/Atom'\nexport { unsafe__withoutCapture, whyAmIRunning } from './lib/capture'\nexport {\n\tcomputed,\n\tgetComputedInstance,\n\tisUninitialized,\n\tUNINITIALIZED,\n\twithDiff,\n} from './lib/Computed'\nexport type { Computed, ComputedOptions, WithDiff } from './lib/Computed'\nexport { EffectScheduler, react, reactor } from './lib/EffectScheduler'\nexport type { EffectSchedulerOptions, Reactor } from './lib/EffectScheduler'\nexport { EMPTY_ARRAY } from './lib/helpers'\nexport { isSignal } from './lib/isSignal'\nexport { localStorageAtom } from './lib/localStorageAtom'\nexport { deferAsyncEffects, transact, transaction } from './lib/transactions'\nexport { RESET_VALUE } from './lib/types'\nexport type { Child, ComputeDiff, Signal } from './lib/types'\n\n// This should be incremented any time an API change is made. i.e. for additions or removals.\n// Bugfixes need not increment this.\nconst currentApiVersion = 1\n\nconst actualApiVersion = singleton('apiVersion', () => currentApiVersion)\n\nif (actualApiVersion !== currentApiVersion) {\n\tthrow new Error(\n\t\t`You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`\n\t)\n}\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,SAAS,iBAAiB;AAE1B,SAAS,gBAAgB;AACzB,SAAS,MAAM,cAAc;AAE7B,SAAS,wBAAwB,qBAAqB;AACtD;AAQA,SAAS,iBAAiB,OAAO,eAAe;AAGhD,SAAS,gBAAgB;AACzB,SAAS,wBAAwB;AACjC,SAAS,mBAAmB,UAAU,mBAAmB;AACzD,SAAS,mBAAmB;;;;;;;;;;;;;AAK5B,MAAM,oBAAoB;AAE1B,MAAM,uBAAmB,mLAAA,EAAU,cAAc,IAAM,iBAAiB;AAExE,IAAI,qBAAqB,mBAAmB;IAC3C,MAAM,IAAI,MACT,CAAA,qGAAA,CAAA;AAEF;IAEA,sMAAA,EACE,iBACA,SACA","debugId":null}},
    {"offset": {"line": 1555, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/validate/src/lib/validation.ts"],"sourcesContent":["import {\n\tIndexKey,\n\tJsonValue,\n\tMakeUndefinedOptional,\n\tSTRUCTURED_CLONE_OBJECT_PROTOTYPE,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tvalidateIndexKey,\n} from '@tldraw/utils'\n\n/**\n * A function that validates and returns a value of type T from unknown input.\n * The function should throw a ValidationError if the value is invalid.\n *\n * @param value - The unknown value to validate\n * @returns The validated value of type T\n * @throws \\{ValidationError\\} When the value doesn't match the expected type\n * @example\n * ```ts\n * const stringValidator: ValidatorFn<string> = (value) => {\n *   if (typeof value !== 'string') {\n *     throw new ValidationError('Expected string')\n *   }\n *   return value\n * }\n * ```\n * @public\n */\nexport type ValidatorFn<T> = (value: unknown) => T\n/**\n * A performance-optimized validation function that can use a previously validated value\n * to avoid revalidating unchanged parts of the data structure.\n *\n * @param knownGoodValue - A previously validated value of type In\n * @param value - The unknown value to validate\n * @returns The validated value of type Out\n * @throws ValidationError When the value doesn't match the expected type\n * @example\n * ```ts\n * const optimizedValidator: ValidatorUsingKnownGoodVersionFn<User> = (\n *   knownGood,\n *   newValue\n * ) => {\n *   if (Object.is(knownGood, newValue)) return knownGood\n *   return fullValidation(newValue)\n * }\n * ```\n * @public\n */\nexport type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (\n\tknownGoodValue: In,\n\tvalue: unknown\n) => Out\n\n/**\n * Interface for objects that can validate unknown values and return typed results.\n * This is the core interface implemented by all validators in the validation system.\n *\n * @example\n * ```ts\n * const customValidator: Validatable<number> = {\n *   validate(value) {\n *     if (typeof value !== 'number') {\n *       throw new ValidationError('Expected number')\n *     }\n *     return value\n *   }\n * }\n * ```\n * @public\n */\nexport interface Validatable<T> {\n\t/**\n\t * Validates an unknown value and returns it with the correct type.\n\t *\n\t * @param value - The unknown value to validate\n\t * @returns The validated value with type T\n\t * @throws ValidationError When validation fails\n\t */\n\tvalidate(value: unknown): T\n\t/**\n\t * Performance-optimized validation that can use a previously validated value\n\t * to avoid revalidating unchanged parts of the data structure.\n\t *\n\t * If the value has not changed but is not referentially equal, the function\n\t * should return the previous value.\n\t *\n\t * @param knownGoodValue - A previously validated value\n\t * @param newValue - The new value to validate\n\t * @returns The validated value, potentially reusing the known good value for performance\n\t * @throws ValidationError When validation fails\n\t */\n\tvalidateUsingKnownGoodVersion?(knownGoodValue: T, newValue: unknown): T\n}\n\nfunction formatPath(path: ReadonlyArray<number | string>): string | null {\n\tif (!path.length) {\n\t\treturn null\n\t}\n\n\tlet formattedPath = ''\n\tfor (const item of path) {\n\t\tif (typeof item === 'number') {\n\t\t\tformattedPath += `.${item}`\n\t\t} else if (item.startsWith('(')) {\n\t\t\tif (formattedPath.endsWith(')')) {\n\t\t\t\tformattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`\n\t\t\t} else {\n\t\t\t\tformattedPath += item\n\t\t\t}\n\t\t} else {\n\t\t\tformattedPath += `.${item}`\n\t\t}\n\t}\n\n\t// N.B. We don't want id's in the path because they make grouping in Sentry tough.\n\tformattedPath = formattedPath.replace(/id = [^,]+, /, '').replace(/id = [^)]+/, '')\n\n\tif (formattedPath.startsWith('.')) {\n\t\treturn formattedPath.slice(1)\n\t}\n\treturn formattedPath\n}\n\n/**\n * Error thrown when validation fails. Provides detailed information about what went wrong\n * and where in the data structure the error occurred.\n *\n * @example\n * ```ts\n * try {\n *   validator.validate(invalidData)\n * } catch (error) {\n *   if (error instanceof ValidationError) {\n *     console.log(error.message) // \"At users.0.email: Expected valid URL\"\n *     console.log(error.path) // ['users', 0, 'email']\n *     console.log(error.rawMessage) // \"Expected valid URL\"\n *   }\n * }\n * ```\n * @public\n */\nexport class ValidationError extends Error {\n\toverride name = 'ValidationError'\n\n\t/**\n\t * Creates a new ValidationError with contextual information about where the error occurred.\n\t *\n\t * rawMessage - The raw error message without path information\n\t * path - Array indicating the location in the data structure where validation failed\n\t */\n\tconstructor(\n\t\tpublic readonly rawMessage: string,\n\t\tpublic readonly path: ReadonlyArray<number | string> = []\n\t) {\n\t\tconst formattedPath = formatPath(path)\n\t\tconst indentedMessage = rawMessage\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => (i === 0 ? line : `  ${line}`))\n\t\t\t.join('\\n')\n\t\tsuper(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage)\n\t}\n}\n\nfunction prefixError<T>(path: string | number, fn: () => T): T {\n\ttry {\n\t\treturn fn()\n\t} catch (err) {\n\t\tif (err instanceof ValidationError) {\n\t\t\tthrow new ValidationError(err.rawMessage, [path, ...err.path])\n\t\t}\n\t\tthrow new ValidationError((err as Error).toString(), [path])\n\t}\n}\n\nfunction typeToString(value: unknown): string {\n\tif (value === null) return 'null'\n\tif (Array.isArray(value)) return 'an array'\n\tconst type = typeof value\n\tswitch (type) {\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\tcase 'function':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\tcase 'symbol':\n\t\t\treturn `a ${type}`\n\t\tcase 'object':\n\t\t\treturn `an ${type}`\n\t\tcase 'undefined':\n\t\t\treturn 'undefined'\n\t\tdefault:\n\t\t\texhaustiveSwitchError(type)\n\t}\n}\n\n/**\n * Utility type that extracts the validated type from a Validatable object.\n * Useful for deriving TypeScript types from validator definitions.\n *\n * @example\n * ```ts\n * const userValidator = T.object({ name: T.string, age: T.number })\n * type User = TypeOf<typeof userValidator> // { name: string; age: number }\n * ```\n * @public\n */\nexport type TypeOf<V extends Validatable<any>> = V extends Validatable<infer T> ? T : never\n\n/**\n * The main validator class that implements the Validatable interface. This is the base class\n * for all validators and provides methods for validation, type checking, and composing validators.\n *\n * @example\n * ```ts\n * const numberValidator = new Validator((value) => {\n *   if (typeof value !== 'number') {\n *     throw new ValidationError('Expected number')\n *   }\n *   return value\n * })\n *\n * const result = numberValidator.validate(42) // Returns 42 as number\n * ```\n * @public\n */\nexport class Validator<T> implements Validatable<T> {\n\t/**\n\t * Creates a new Validator instance.\n\t *\n\t * validationFn - Function that validates and returns a value of type T\n\t * validateUsingKnownGoodVersionFn - Optional performance-optimized validation function\n\t */\n\tconstructor(\n\t\treadonly validationFn: ValidatorFn<T>,\n\t\treadonly validateUsingKnownGoodVersionFn?: ValidatorUsingKnownGoodVersionFn<T>\n\t) {}\n\n\t/**\n\t * Validates an unknown value and returns it with the correct type. The returned value is\n\t * guaranteed to be referentially equal to the passed value.\n\t *\n\t * @param value - The unknown value to validate\n\t * @returns The validated value with type T\n\t * @throws ValidationError When validation fails\n\t * @example\n\t * ```ts\n\t * import { T } from '@tldraw/validate'\n\t *\n\t * const name = T.string.validate(\"Alice\") // Returns \"Alice\" as string\n\t * const title = T.string.validate(\"\") // Returns \"\" (empty strings are valid)\n\t *\n\t * // These will throw ValidationError:\n\t * T.string.validate(123) // Expected string, got a number\n\t * T.string.validate(null) // Expected string, got null\n\t * T.string.validate(undefined) // Expected string, got undefined\n\t * ```\n\t */\n\tvalidate(value: unknown): T {\n\t\tconst validated = this.validationFn(value)\n\t\tif (process.env.NODE_ENV !== 'production' && !Object.is(value, validated)) {\n\t\t\tthrow new ValidationError('Validator functions must return the same value they were passed')\n\t\t}\n\t\treturn validated\n\t}\n\n\t/**\n\t * Performance-optimized validation using a previously validated value. If the new value\n\t * is referentially equal to the known good value, returns the known good value immediately.\n\t *\n\t * @param knownGoodValue - A previously validated value\n\t * @param newValue - The new value to validate\n\t * @returns The validated value, potentially reusing the known good value\n\t * @throws ValidationError When validation fails\n\t * @example\n\t * ```ts\n\t * import { T } from '@tldraw/validate'\n\t *\n\t * const userValidator = T.object({\n\t *   name: T.string,\n\t *   settings: T.object({ theme: T.literalEnum('light', 'dark') })\n\t * })\n\t *\n\t * const user = userValidator.validate({ name: \"Alice\", settings: { theme: \"light\" } })\n\t *\n\t * // Later, with partially changed data:\n\t * const newData = { name: \"Alice\", settings: { theme: \"dark\" } }\n\t * const updated = userValidator.validateUsingKnownGoodVersion(user, newData)\n\t * // Only validates the changed 'theme' field for better performance\n\t * ```\n\t */\n\tvalidateUsingKnownGoodVersion(knownGoodValue: T, newValue: unknown): T {\n\t\tif (Object.is(knownGoodValue, newValue)) {\n\t\t\treturn knownGoodValue as T\n\t\t}\n\n\t\tif (this.validateUsingKnownGoodVersionFn) {\n\t\t\treturn this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue)\n\t\t}\n\n\t\treturn this.validate(newValue)\n\t}\n\n\t/**\n\t * Type guard that checks if a value is valid without throwing an error.\n\t *\n\t * @param value - The value to check\n\t * @returns True if the value is valid, false otherwise\n\t * @example\n\t * ```ts\n\t * import { T } from '@tldraw/validate'\n\t *\n\t * function processUserInput(input: unknown) {\n\t *   if (T.string.isValid(input)) {\n\t *     // input is now typed as string within this block\n\t *     return input.toUpperCase()\n\t *   }\n\t *   if (T.number.isValid(input)) {\n\t *     // input is now typed as number within this block\n\t *     return input.toFixed(2)\n\t *   }\n\t *   throw new Error('Expected string or number')\n\t * }\n\t * ```\n\t */\n\tisValid(value: unknown): value is T {\n\t\ttry {\n\t\t\tthis.validate(value)\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts null values.\n\t *\n\t * @returns A new validator that accepts T or null\n\t * @example\n\t * ```ts\n\t * import { T } from '@tldraw/validate'\n\t *\n\t * const assetValidator = T.object({\n\t *   id: T.string,\n\t *   name: T.string,\n\t *   src: T.srcUrl.nullable(), // Can be null if not loaded yet\n\t *   mimeType: T.string.nullable()\n\t * })\n\t *\n\t * const asset = assetValidator.validate({\n\t *   id: \"image-123\",\n\t *   name: \"photo.jpg\",\n\t *   src: null, // Valid - asset not loaded yet\n\t *   mimeType: \"image/jpeg\"\n\t * })\n\t * ```\n\t */\n\tnullable(): Validator<T | null> {\n\t\treturn nullable(this)\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts undefined values.\n\t *\n\t * @returns A new validator that accepts T or undefined\n\t * @example\n\t * ```ts\n\t * import { T } from '@tldraw/validate'\n\t *\n\t * const shapeConfigValidator = T.object({\n\t *   type: T.literal('rectangle'),\n\t *   x: T.number,\n\t *   y: T.number,\n\t *   label: T.string.optional(), // Optional property\n\t *   metadata: T.object({ created: T.string }).optional()\n\t * })\n\t *\n\t * // Both of these are valid:\n\t * const shape1 = shapeConfigValidator.validate({ type: 'rectangle', x: 0, y: 0 })\n\t * const shape2 = shapeConfigValidator.validate({\n\t *   type: 'rectangle', x: 0, y: 0, label: \"My Shape\"\n\t * })\n\t * ```\n\t */\n\toptional(): Validator<T | undefined> {\n\t\treturn optional(this)\n\t}\n\n\t/**\n\t * Creates a new validator by refining this validator with additional logic that can transform\n\t * the validated value to a new type.\n\t *\n\t * @param otherValidationFn - Function that transforms/validates the value to type U\n\t * @returns A new validator that validates to type U\n\t * @throws ValidationError When validation or refinement fails\n\t * @example\n\t * ```ts\n\t * import { T, ValidationError } from '@tldraw/validate'\n\t *\n\t * // Transform string to ensure it starts with a prefix\n\t * const prefixedIdValidator = T.string.refine((id) => {\n\t *   return id.startsWith('shape:') ? id : `shape:${id}`\n\t * })\n\t *\n\t * const id1 = prefixedIdValidator.validate(\"rectangle-123\") // Returns \"shape:rectangle-123\"\n\t * const id2 = prefixedIdValidator.validate(\"shape:circle-456\") // Returns \"shape:circle-456\"\n\t *\n\t * // Parse and validate JSON strings\n\t * const jsonValidator = T.string.refine((str) => {\n\t *   try {\n\t *     return JSON.parse(str)\n\t *   } catch {\n\t *     throw new ValidationError('Invalid JSON string')\n\t *   }\n\t * })\n\t * ```\n\t */\n\trefine<U>(otherValidationFn: (value: T) => U): Validator<U> {\n\t\treturn new Validator(\n\t\t\t(value) => {\n\t\t\t\treturn otherValidationFn(this.validate(value))\n\t\t\t},\n\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tconst validated = this.validateUsingKnownGoodVersion(knownGoodValue as any, newValue)\n\t\t\t\tif (Object.is(knownGoodValue, validated)) {\n\t\t\t\t\treturn knownGoodValue\n\t\t\t\t}\n\t\t\t\treturn otherValidationFn(validated)\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Adds an additional validation check without changing the resulting value type.\n\t * Can be called with just a check function, or with a name for better error messages.\n\t *\n\t * @param name - Name for the check (used in error messages)\n\t * @param checkFn - Function that validates the value (should throw on invalid input)\n\t * @returns A new validator with the additional check\n\t * @throws ValidationError When the check fails\n\t * @example\n\t * ```ts\n\t * import { T, ValidationError } from '@tldraw/validate'\n\t *\n\t * // Basic check without name\n\t * const evenNumber = T.number.check((value) => {\n\t *   if (value % 2 !== 0) {\n\t *     throw new ValidationError('Expected even number')\n\t *   }\n\t * })\n\t *\n\t * // Named checks for better error messages in complex validators\n\t * const shapePositionValidator = T.object({\n\t *   x: T.number.check('finite', (value) => {\n\t *     if (!Number.isFinite(value)) {\n\t *       throw new ValidationError('Position must be finite')\n\t *     }\n\t *   }),\n\t *   y: T.number.check('within-bounds', (value) => {\n\t *     if (value < -10000 || value > 10000) {\n\t *       throw new ValidationError('Position must be within bounds (-10000 to 10000)')\n\t *     }\n\t *   })\n\t * })\n\t *\n\t * // Error will be: \"At x (check finite): Position must be finite\"\n\t * ```\n\t */\n\tcheck(name: string, checkFn: (value: T) => void): Validator<T>\n\t/**\n\t * Adds an additional validation check without changing the resulting value type.\n\t *\n\t * @param checkFn - Function that validates the value (should throw on invalid input)\n\t * @returns A new validator with the additional check\n\t * @throws ValidationError When the check fails\n\t */\n\tcheck(checkFn: (value: T) => void): Validator<T>\n\tcheck(nameOrCheckFn: string | ((value: T) => void), checkFn?: (value: T) => void): Validator<T> {\n\t\tif (typeof nameOrCheckFn === 'string') {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tprefixError(`(check ${nameOrCheckFn})`, () => checkFn!(value))\n\t\t\t\treturn value\n\t\t\t})\n\t\t} else {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tnameOrCheckFn(value)\n\t\t\t\treturn value\n\t\t\t})\n\t\t}\n\t}\n}\n\n/**\n * Validator for arrays where each element is validated using the provided item validator.\n * Extends the base Validator class with array-specific validation methods.\n *\n * @example\n * ```ts\n * const stringArray = new ArrayOfValidator(T.string)\n * const numbers = stringArray.validate([\"a\", \"b\", \"c\"]) // Returns string[]\n *\n * const userArray = T.arrayOf(T.object({ name: T.string, age: T.number }))\n * ```\n * @public\n */\nexport class ArrayOfValidator<T> extends Validator<T[]> {\n\t/**\n\t * Creates a new ArrayOfValidator.\n\t *\n\t * itemValidator - Validator used to validate each array element\n\t */\n\tconstructor(readonly itemValidator: Validatable<T>) {\n\t\tsuper(\n\t\t\t(value) => {\n\t\t\t\tconst arr = array.validate(value)\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tprefixError(i, () => itemValidator.validate(arr[i]))\n\t\t\t\t}\n\t\t\t\treturn arr as T[]\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue)\n\t\t\t\tconst arr = array.validate(newValue)\n\t\t\t\tlet isDifferent = knownGoodValue.length !== arr.length\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tconst item = arr[i]\n\t\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(i, () => itemValidator.validate(item))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(knownGoodValue[i], item)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checkedItem = prefixError(i, () =>\n\t\t\t\t\t\titemValidator.validateUsingKnownGoodVersion!(knownGoodValue[i], item)\n\t\t\t\t\t)\n\t\t\t\t\tif (!Object.is(checkedItem, knownGoodValue[i])) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as T[]) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Returns a new validator that ensures the array is not empty.\n\t *\n\t * @returns A new validator that rejects empty arrays\n\t * @throws ValidationError When the array is empty\n\t * @example\n\t * ```ts\n\t * const nonEmptyStrings = T.arrayOf(T.string).nonEmpty()\n\t * nonEmptyStrings.validate([\"hello\"]) // Valid\n\t * nonEmptyStrings.validate([]) // Throws ValidationError\n\t * ```\n\t */\n\tnonEmpty() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length === 0) {\n\t\t\t\tthrow new ValidationError('Expected a non-empty array')\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Returns a new validator that ensures the array has more than one element.\n\t *\n\t * @returns A new validator that requires at least 2 elements\n\t * @throws ValidationError When the array has 1 or fewer elements\n\t * @example\n\t * ```ts\n\t * const multipleItems = T.arrayOf(T.string).lengthGreaterThan1()\n\t * multipleItems.validate([\"a\", \"b\"]) // Valid\n\t * multipleItems.validate([\"a\"]) // Throws ValidationError\n\t * ```\n\t */\n\tlengthGreaterThan1() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length <= 1) {\n\t\t\t\tthrow new ValidationError('Expected an array with length greater than 1')\n\t\t\t}\n\t\t})\n\t}\n}\n\n/**\n * Validator for objects with a defined shape. Each property is validated using its corresponding\n * validator from the config object. Can be configured to allow or reject unknown properties.\n *\n * @example\n * ```ts\n * const userValidator = new ObjectValidator({\n *   name: T.string,\n *   age: T.number,\n *   email: T.string.optional()\n * })\n *\n * const user = userValidator.validate({\n *   name: \"Alice\",\n *   age: 25,\n *   email: \"alice@example.com\"\n * })\n * ```\n * @public\n */\nexport class ObjectValidator<Shape extends object> extends Validator<Shape> {\n\t/**\n\t * Creates a new ObjectValidator.\n\t *\n\t * config - Object mapping property names to their validators\n\t * shouldAllowUnknownProperties - Whether to allow properties not defined in config\n\t */\n\tconstructor(\n\t\tpublic readonly config: {\n\t\t\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n\t\t},\n\t\tprivate readonly shouldAllowUnknownProperties = false\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t;(validator as Validatable<unknown>).validate(getOwnProperty(object, key))\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(object)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn object as Shape\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = getOwnProperty(newValue, key)\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tconst validatable = validator as Validatable<unknown>\n\t\t\t\t\t\tif (validatable.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn validatable.validateUsingKnownGoodVersion(prev, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn validatable.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Shape) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Returns a new validator that allows unknown properties in the validated object.\n\t *\n\t * @returns A new ObjectValidator that accepts extra properties\n\t * @example\n\t * ```ts\n\t * const flexibleUser = T.object({ name: T.string }).allowUnknownProperties()\n\t * flexibleUser.validate({ name: \"Alice\", extra: \"allowed\" }) // Valid\n\t * ```\n\t */\n\tallowUnknownProperties() {\n\t\treturn new ObjectValidator(this.config, true)\n\t}\n\n\t/**\n\t * Creates a new ObjectValidator by extending this validator with additional properties.\n\t *\n\t * @param extension - Object mapping new property names to their validators\n\t * @returns A new ObjectValidator that validates both original and extended properties\n\t * @example\n\t * ```ts\n\t * const baseUser = T.object({ name: T.string, age: T.number })\n\t * const adminUser = baseUser.extend({\n\t *   permissions: T.arrayOf(T.string),\n\t *   isAdmin: T.boolean\n\t * })\n\t * // adminUser validates: { name: string; age: number; permissions: string[]; isAdmin: boolean }\n\t * ```\n\t */\n\textend<Extension extends Record<string, unknown>>(extension: {\n\t\treadonly [K in keyof Extension]: Validatable<Extension[K]>\n\t}): ObjectValidator<Shape & Extension> {\n\t\treturn new ObjectValidator({ ...this.config, ...extension }) as any as ObjectValidator<\n\t\t\tShape & Extension\n\t\t>\n\t}\n}\n\n/**\n * Configuration type for union validators. Each variant must be a validator that produces\n * an object with the discriminator key set to the variant name.\n *\n * @example\n * ```ts\n * type ShapeConfig = UnionValidatorConfig<'type', {\n *   circle: Validatable<{ type: 'circle'; radius: number }>\n *   square: Validatable<{ type: 'square'; size: number }>\n * }>\n * ```\n * @public\n */\nexport type UnionValidatorConfig<Key extends string, Config> = {\n\treadonly [Variant in keyof Config]: Validatable<any> & {\n\t\tvalidate(input: any): { readonly [K in Key]: Variant }\n\t}\n}\n/**\n * Validator for discriminated union types. Validates objects that can be one of several variants,\n * distinguished by a discriminator property (key) that indicates which variant the object represents.\n *\n * @example\n * ```ts\n * const shapeValidator = new UnionValidator('type', {\n *   circle: T.object({ type: T.literal('circle'), radius: T.number }),\n *   square: T.object({ type: T.literal('square'), size: T.number })\n * }, () => { throw new Error('Unknown shape') }, false)\n *\n * const circle = shapeValidator.validate({ type: 'circle', radius: 5 })\n * // circle is typed as { type: 'circle'; radius: number }\n * ```\n * @public\n */\nexport class UnionValidator<\n\tKey extends string,\n\tConfig extends UnionValidatorConfig<Key, Config>,\n\tUnknownValue = never,\n> extends Validator<TypeOf<Config[keyof Config]> | UnknownValue> {\n\t/**\n\t * Creates a new UnionValidator.\n\t *\n\t * key - The discriminator property name used to determine the variant\n\t * config - Object mapping variant names to their validators\n\t * unknownValueValidation - Function to handle unknown variants\n\t * useNumberKeys - Whether the discriminator uses number keys instead of strings\n\t */\n\tconstructor(\n\t\tprivate readonly key: Key,\n\t\tprivate readonly config: Config,\n\t\tprivate readonly unknownValueValidation: (value: object, variant: string) => UnknownValue,\n\t\tprivate readonly useNumberKeys: boolean\n\t) {\n\t\tsuper(\n\t\t\t(input) => {\n\t\t\t\tthis.expectObject(input)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(input, variant)\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))\n\t\t\t},\n\t\t\t(prevValue, newValue) => {\n\t\t\t\tthis.expectObject(newValue)\n\t\t\t\tthis.expectObject(prevValue)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(newValue, variant)\n\t\t\t\t}\n\n\t\t\t\tif (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {\n\t\t\t\t\t// the type has changed so bail out and do a regular validation\n\t\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue))\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => {\n\t\t\t\t\tif (matchingSchema.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\treturn matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn matchingSchema.validate(newValue)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t)\n\t}\n\n\tprivate expectObject(value: unknown): asserts value is object {\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\tthrow new ValidationError(`Expected an object, got ${typeToString(value)}`, [])\n\t\t}\n\t}\n\n\tprivate getMatchingSchemaAndVariant(object: object): {\n\t\tmatchingSchema: Validatable<any> | undefined\n\t\tvariant: string\n\t} {\n\t\tconst variant = getOwnProperty(object, this.key)! as string & keyof Config\n\t\tif (!this.useNumberKeys && typeof variant !== 'string') {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected a string for key \"${this.key}\", got ${typeToString(variant)}`\n\t\t\t)\n\t\t} else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {\n\t\t\tthrow new ValidationError(`Expected a number for key \"${this.key}\", got \"${variant as any}\"`)\n\t\t}\n\n\t\tconst matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : undefined\n\t\treturn { matchingSchema, variant }\n\t}\n\n\t/**\n\t * Returns a new UnionValidator that can handle unknown variants using the provided function.\n\t *\n\t * @param unknownValueValidation - Function to validate/transform unknown variants\n\t * @returns A new UnionValidator that accepts unknown variants\n\t * @example\n\t * ```ts\n\t * const shapeValidator = T.union('type', { circle: circleValidator })\n\t *   .validateUnknownVariants((obj, variant) => {\n\t *     console.warn(`Unknown shape type: ${variant}`)\n\t *     return obj as UnknownShape\n\t *   })\n\t * ```\n\t */\n\tvalidateUnknownVariants<Unknown>(\n\t\tunknownValueValidation: (value: object, variant: string) => Unknown\n\t): UnionValidator<Key, Config, Unknown> {\n\t\treturn new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys)\n\t}\n}\n\n/**\n * Validator for dictionary/map objects where both keys and values are validated.\n * Useful for validating objects used as key-value stores.\n *\n * @example\n * ```ts\n * const scoreDict = new DictValidator(T.string, T.number)\n * const scores = scoreDict.validate({\n *   \"alice\": 100,\n *   \"bob\": 85,\n *   \"charlie\": 92\n * })\n * // scores is typed as Record<string, number>\n * ```\n * @public\n */\nexport class DictValidator<Key extends string, Value> extends Validator<Record<Key, Value>> {\n\t/**\n\t * Creates a new DictValidator.\n\t *\n\t * keyValidator - Validator for object keys\n\t * valueValidator - Validator for object values\n\t */\n\tconstructor(\n\t\tpublic readonly keyValidator: Validatable<Key>,\n\t\tpublic readonly valueValidator: Validatable<Value>\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, value] of Object.entries(object)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\treturn object as Record<Key, Value>\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, value] of Object.entries(newValue)) {\n\t\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = value\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tif (valueValidator.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn valueValidator.validateUsingKnownGoodVersion(prev as any, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn valueValidator.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Record<Key, Value>) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n}\n\nfunction typeofValidator<T>(type: string): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (typeof value !== type) {\n\t\t\tthrow new ValidationError(`Expected ${type}, got ${typeToString(value)}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/**\n * Validator that accepts any value without type checking. Useful as a starting point for\n * building custom validations or when you need to accept truly unknown data.\n *\n * @example\n * ```ts\n * const result = T.unknown.validate(anything) // Returns the value as-is\n * // result is typed as unknown\n * ```\n * @public\n */\nexport const unknown = new Validator((value) => value)\n/**\n * Validator that accepts any value and types it as 'any'. This should generally be avoided\n * as it bypasses type safety, but can be used as an escape hatch for prototyping.\n *\n * @example\n * ```ts\n * const result = T.any.validate(anything) // Returns the value as any\n * // result is typed as any - use with caution!\n * ```\n * @public\n */\nexport const any = new Validator((value): any => value)\n\n/**\n * Validator that ensures a value is a string.\n *\n * @example\n * ```ts\n * const name = T.string.validate(\"hello\") // Returns \"hello\" as string\n * T.string.validate(123) // Throws ValidationError: \"Expected string, got a number\"\n * ```\n * @public\n */\nexport const string = typeofValidator<string>('string')\n\n/**\n * Validator that ensures a value is a finite, non-NaN number. Rejects Infinity, -Infinity, and NaN.\n *\n * @example\n * ```ts\n * const count = T.number.validate(42) // Returns 42 as number\n * T.number.validate(NaN) // Throws ValidationError: \"Expected a number, got NaN\"\n * T.number.validate(Infinity) // Throws ValidationError: \"Expected a finite number, got Infinity\"\n * ```\n * @public\n */\nexport const number = typeofValidator<number>('number').check((number) => {\n\tif (Number.isNaN(number)) {\n\t\tthrow new ValidationError('Expected a number, got NaN')\n\t}\n\tif (!Number.isFinite(number)) {\n\t\tthrow new ValidationError(`Expected a finite number, got ${number}`)\n\t}\n})\n/**\n * Validator that ensures a value is a non-negative number (\\>= 0).\n * Despite the name \"positive\", this validator accepts zero.\n *\n * @example\n * ```ts\n * const price = T.positiveNumber.validate(29.99) // Returns 29.99\n * const free = T.positiveNumber.validate(0) // Returns 0 (valid)\n * T.positiveNumber.validate(-1) // Throws ValidationError: \"Expected a positive number, got -1\"\n * ```\n * @public\n */\nexport const positiveNumber = number.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`)\n})\n/**\n * Validator that ensures a value is a positive number (\\> 0). Rejects zero and negative numbers.\n *\n * @example\n * ```ts\n * const quantity = T.nonZeroNumber.validate(0.01) // Returns 0.01\n * T.nonZeroNumber.validate(0) // Throws ValidationError: \"Expected a non-zero positive number, got 0\"\n * T.nonZeroNumber.validate(-5) // Throws ValidationError: \"Expected a non-zero positive number, got -5\"\n * ```\n * @public\n */\nexport const nonZeroNumber = number.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`)\n})\n/**\n * Validator that ensures a value is an integer (whole number).\n *\n * @example\n * ```ts\n * const count = T.integer.validate(42) // Returns 42\n * T.integer.validate(3.14) // Throws ValidationError: \"Expected an integer, got 3.14\"\n * T.integer.validate(-5) // Returns -5 (negative integers are valid)\n * ```\n * @public\n */\nexport const integer = number.check((value) => {\n\tif (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`)\n})\n/**\n * Validator that ensures a value is a non-negative integer (\\>= 0).\n * Despite the name \"positive\", this validator accepts zero.\n *\n * @example\n * ```ts\n * const index = T.positiveInteger.validate(5) // Returns 5\n * const start = T.positiveInteger.validate(0) // Returns 0 (valid)\n * T.positiveInteger.validate(-1) // Throws ValidationError: \"Expected a positive integer, got -1\"\n * T.positiveInteger.validate(3.14) // Throws ValidationError: \"Expected an integer, got 3.14\"\n * ```\n * @public\n */\nexport const positiveInteger = integer.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`)\n})\n/**\n * Validator that ensures a value is a positive integer (\\> 0). Rejects zero and negative integers.\n *\n * @example\n * ```ts\n * const itemCount = T.nonZeroInteger.validate(1) // Returns 1\n * T.nonZeroInteger.validate(0) // Throws ValidationError: \"Expected a non-zero positive integer, got 0\"\n * T.nonZeroInteger.validate(-5) // Throws ValidationError: \"Expected a non-zero positive integer, got -5\"\n * ```\n * @public\n */\nexport const nonZeroInteger = integer.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`)\n})\n\n/**\n * Validator that ensures a value is a boolean.\n *\n * @example\n * ```ts\n * const isActive = T.boolean.validate(true) // Returns true\n * const isEnabled = T.boolean.validate(false) // Returns false\n * T.boolean.validate(\"true\") // Throws ValidationError: \"Expected boolean, got a string\"\n * ```\n * @public\n */\nexport const boolean = typeofValidator<boolean>('boolean')\n/**\n * Validator that ensures a value is a bigint.\n *\n * @example\n * ```ts\n * const largeNumber = T.bigint.validate(123n) // Returns 123n\n * T.bigint.validate(123) // Throws ValidationError: \"Expected bigint, got a number\"\n * ```\n * @public\n */\nexport const bigint = typeofValidator<bigint>('bigint')\n/**\n * Creates a validator that only accepts a specific literal value.\n *\n * @param expectedValue - The exact value that must be matched\n * @returns A validator that only accepts the specified literal value\n * @throws ValidationError When the value doesn't match the expected literal\n * @example\n * ```ts\n * const trueValidator = T.literal(true)\n * trueValidator.validate(true) // Returns true\n * trueValidator.validate(false) // Throws ValidationError\n *\n * const statusValidator = T.literal(\"active\")\n * statusValidator.validate(\"active\") // Returns \"active\"\n * statusValidator.validate(\"inactive\") // Throws ValidationError\n * ```\n * @public\n */\nexport function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {\n\treturn new Validator((actualValue) => {\n\t\tif (actualValue !== expectedValue) {\n\t\t\tthrow new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)\n\t\t}\n\t\treturn expectedValue\n\t})\n}\n\n/**\n * Validator that ensures a value is an array. Does not validate the contents of the array.\n * Use T.arrayOf() to validate both the array structure and its contents.\n *\n * @example\n * ```ts\n * const items = T.array.validate([1, \"hello\", true]) // Returns unknown[]\n * T.array.validate(\"not array\") // Throws ValidationError: \"Expected an array, got a string\"\n *\n * // For typed arrays, use T.arrayOf:\n * const numbers = T.arrayOf(T.number).validate([1, 2, 3]) // Returns number[]\n * ```\n * @public\n */\nexport const array = new Validator<unknown[]>((value) => {\n\tif (!Array.isArray(value)) {\n\t\tthrow new ValidationError(`Expected an array, got ${typeToString(value)}`)\n\t}\n\treturn value\n})\n\n/**\n * Creates a validator for arrays where each element is validated using the provided validator.\n *\n * @param itemValidator - Validator to use for each array element\n * @returns An ArrayOfValidator that validates both array structure and element types\n * @throws ValidationError When the value is not an array or when any element is invalid\n * @example\n * ```ts\n * const numberArray = T.arrayOf(T.number)\n * numberArray.validate([1, 2, 3]) // Returns number[]\n * numberArray.validate([1, \"2\", 3]) // Throws ValidationError at index 1\n *\n * const userArray = T.arrayOf(T.object({ name: T.string, age: T.number }))\n * ```\n * @public\n */\nexport function arrayOf<T>(itemValidator: Validatable<T>): ArrayOfValidator<T> {\n\treturn new ArrayOfValidator(itemValidator)\n}\n\n/**\n * Validator that ensures a value is an object (non-null, non-array). Does not validate\n * the properties of the object.\n *\n * @example\n * ```ts\n * const obj = T.unknownObject.validate({ any: \"properties\" }) // Returns Record<string, unknown>\n * T.unknownObject.validate(null) // Throws ValidationError: \"Expected object, got null\"\n * T.unknownObject.validate([1, 2, 3]) // Throws ValidationError: \"Expected object, got an array\"\n * ```\n * @public\n */\nexport const unknownObject = new Validator<Record<string, unknown>>((value) => {\n\tif (typeof value !== 'object' || value === null) {\n\t\tthrow new ValidationError(`Expected object, got ${typeToString(value)}`)\n\t}\n\treturn value as Record<string, unknown>\n})\n\n/**\n * Creates a validator for objects with a defined shape. Each property is validated using\n * its corresponding validator from the config object.\n *\n * @param config - Object mapping property names to their validators\n * @returns An ObjectValidator that validates the object structure and all properties\n * @throws ValidationError When the value is not an object or when any property is invalid\n * @example\n * ```ts\n * const userValidator = T.object({\n *   name: T.string,\n *   age: T.number,\n *   email: T.string.optional(),\n *   isActive: T.boolean\n * })\n *\n * const user = userValidator.validate({\n *   name: \"Alice\",\n *   age: 25,\n *   email: \"alice@example.com\",\n *   isActive: true\n * })\n * // user is typed with full type safety\n * ```\n * @public\n */\nexport function object<Shape extends object>(config: {\n\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n}): ObjectValidator<MakeUndefinedOptional<Shape>> {\n\treturn new ObjectValidator(config) as any\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t(Object.getPrototypeOf(value) === Object.prototype ||\n\t\t\tObject.getPrototypeOf(value) === null ||\n\t\t\tObject.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE)\n\t)\n}\n\nfunction isValidJson(value: any): value is JsonValue {\n\tif (\n\t\tvalue === null ||\n\t\ttypeof value === 'number' ||\n\t\ttypeof value === 'string' ||\n\t\ttypeof value === 'boolean'\n\t) {\n\t\treturn true\n\t}\n\n\tif (Array.isArray(value)) {\n\t\treturn value.every(isValidJson)\n\t}\n\n\tif (isPlainObject(value)) {\n\t\treturn Object.values(value).every(isValidJson)\n\t}\n\n\treturn false\n}\n\n/**\n * Validator that ensures a value is valid JSON (string, number, boolean, null, array, or plain object).\n * Rejects functions, undefined, symbols, and other non-JSON values.\n *\n * @example\n * ```ts\n * const data = T.jsonValue.validate({ name: \"Alice\", scores: [1, 2, 3], active: true })\n * T.jsonValue.validate(undefined) // Throws ValidationError\n * T.jsonValue.validate(() => {}) // Throws ValidationError\n * ```\n * @public\n */\nexport const jsonValue: Validator<JsonValue> = new Validator<JsonValue>(\n\t(value): JsonValue => {\n\t\tif (isValidJson(value)) {\n\t\t\treturn value as JsonValue\n\t\t}\n\n\t\tthrow new ValidationError(`Expected json serializable value, got ${typeof value}`)\n\t},\n\t(knownGoodValue, newValue) => {\n\t\tif (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {\n\t\t\tlet isDifferent = knownGoodValue.length !== newValue.length\n\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[i])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[i]\n\t\t\t\tconst next = newValue[i]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {\n\t\t\tlet isDifferent = false\n\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[key])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[key]\n\t\t\t\tconst next = newValue[key]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev!, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else {\n\t\t\treturn jsonValue.validate(newValue)\n\t\t}\n\t}\n)\n\n/**\n * Creates a validator for JSON dictionaries (objects with string keys and JSON-serializable values).\n *\n * @returns A DictValidator that validates string keys and JSON values\n * @throws ValidationError When keys are not strings or values are not JSON-serializable\n * @example\n * ```ts\n * const config = T.jsonDict().validate({\n *   \"setting1\": \"value\",\n *   \"setting2\": 42,\n *   \"setting3\": [\"a\", \"b\", \"c\"],\n *   \"setting4\": { nested: true }\n * })\n * ```\n * @public\n */\nexport function jsonDict(): DictValidator<string, JsonValue> {\n\treturn dict(string, jsonValue)\n}\n\n/**\n * Creates a validator for dictionary objects where both keys and values are validated.\n * Useful for validating objects used as key-value maps.\n *\n * @param keyValidator - Validator for object keys\n * @param valueValidator - Validator for object values\n * @returns A DictValidator that validates all keys and values\n * @throws ValidationError When any key or value is invalid\n * @example\n * ```ts\n * const scores = T.dict(T.string, T.number)\n * scores.validate({ \"alice\": 100, \"bob\": 85 }) // Valid\n *\n * const userPrefs = T.dict(T.string, T.object({\n *   theme: T.literalEnum('light', 'dark'),\n *   notifications: T.boolean\n * }))\n * ```\n * @public\n */\nexport function dict<Key extends string, Value>(\n\tkeyValidator: Validatable<Key>,\n\tvalueValidator: Validatable<Value>\n): DictValidator<Key, Value> {\n\treturn new DictValidator(keyValidator, valueValidator)\n}\n\n/**\n * Creates a validator for discriminated union types. Validates objects that can be one of\n * several variants, distinguished by a discriminator property.\n *\n * @param key - The discriminator property name used to determine the variant\n * @param config - Object mapping variant names to their validators\n * @returns A UnionValidator that validates based on the discriminator value\n * @throws ValidationError When the discriminator is invalid or the variant validation fails\n * @example\n * ```ts\n * const shapeValidator = T.union('type', {\n *   circle: T.object({ type: T.literal('circle'), radius: T.number }),\n *   square: T.object({ type: T.literal('square'), size: T.number }),\n *   triangle: T.object({ type: T.literal('triangle'), base: T.number, height: T.number })\n * })\n *\n * const circle = shapeValidator.validate({ type: 'circle', radius: 5 })\n * // circle is typed as { type: 'circle'; radius: number }\n * ```\n * @public\n */\nexport function union<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(_unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\tfalse\n\t)\n}\n\n/**\n * Creates a validator for discriminated union types using number discriminators instead of strings.\n * This is an internal function used for specific cases where numeric discriminators are needed.\n *\n * @param key - The discriminator property name used to determine the variant\n * @param config - Object mapping variant names to their validators\n * @returns A UnionValidator that validates based on numeric discriminator values\n * @throws ValidationError When the discriminator is invalid or the variant validation fails\n * @internal\n */\nexport function numberUnion<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\ttrue\n\t)\n}\n\n/**\n * Creates a validator for named model objects with enhanced error reporting. The model name\n * will be included in error messages to provide better debugging context.\n *\n * @param name - The name of the model (used in error messages)\n * @param validator - The validator for the model structure\n * @returns A Validator with enhanced error reporting that includes the model name\n * @throws ValidationError With model name context when validation fails\n * @example\n * ```ts\n * const userModel = T.model('User', T.object({\n *   id: T.string,\n *   name: T.string,\n *   email: T.linkUrl\n * }))\n *\n * // Error message will be: \"At User.email: Expected a valid url, got 'invalid-email'\"\n * ```\n * @public\n */\nexport function model<T extends { readonly id: string }>(\n\tname: string,\n\tvalidator: Validatable<T>\n): Validator<T> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\treturn prefixError(name, () => validator.validate(value))\n\t\t},\n\t\t(prevValue, newValue) => {\n\t\t\treturn prefixError(name, () => {\n\t\t\t\tif (validator.validateUsingKnownGoodVersion) {\n\t\t\t\t\treturn validator.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t} else {\n\t\t\t\t\treturn validator.validate(newValue)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t)\n}\n\n/**\n * Creates a validator that only accepts values from a given Set of allowed values.\n *\n * @param values - Set containing the allowed values\n * @returns A validator that only accepts values from the provided set\n * @throws ValidationError When the value is not in the allowed set\n * @example\n * ```ts\n * const allowedColors = new Set(['red', 'green', 'blue'] as const)\n * const colorValidator = T.setEnum(allowedColors)\n * colorValidator.validate('red') // Returns 'red'\n * colorValidator.validate('yellow') // Throws ValidationError\n * ```\n * @public\n */\nexport function setEnum<T>(values: ReadonlySet<T>): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (!values.has(value as T)) {\n\t\t\tconst valuesString = Array.from(values, (value) => JSON.stringify(value)).join(' or ')\n\t\t\tthrow new ValidationError(`Expected ${valuesString}, got ${value}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/**\n * Creates a validator that accepts either the validated type or undefined.\n *\n * @param validator - The base validator to make optional\n * @returns A validator that accepts T or undefined\n * @example\n * ```ts\n * const optionalString = T.optional(T.string)\n * optionalString.validate(\"hello\") // Returns \"hello\"\n * optionalString.validate(undefined) // Returns undefined\n * optionalString.validate(null) // Throws ValidationError\n * ```\n * @public\n */\nexport function optional<T>(validator: Validatable<T>): Validator<T | undefined> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === undefined) return undefined\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (knownGoodValue === undefined && newValue === undefined) return undefined\n\t\t\tif (newValue === undefined) return undefined\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== undefined) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/**\n * Creates a validator that accepts either the validated type or null.\n *\n * @param validator - The base validator to make nullable\n * @returns A validator that accepts T or null\n * @example\n * ```ts\n * const nullableString = T.nullable(T.string)\n * nullableString.validate(\"hello\") // Returns \"hello\"\n * nullableString.validate(null) // Returns null\n * nullableString.validate(undefined) // Throws ValidationError\n * ```\n * @public\n */\nexport function nullable<T>(validator: Validatable<T>): Validator<T | null> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === null) return null\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (newValue === null) return null\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/**\n * Creates a validator that only accepts one of the provided literal values.\n * This is a convenience function that creates a setEnum from the provided values.\n *\n * @param values - The allowed literal values\n * @returns A validator that only accepts the provided literal values\n * @throws ValidationError When the value is not one of the allowed literals\n * @example\n * ```ts\n * const themeValidator = T.literalEnum('light', 'dark', 'auto')\n * themeValidator.validate('light') // Returns 'light'\n * themeValidator.validate('blue') // Throws ValidationError: Expected \"light\" or \"dark\" or \"auto\", got blue\n * ```\n * @public\n */\nexport function literalEnum<const Values extends readonly unknown[]>(\n\t...values: Values\n): Validator<Values[number]> {\n\treturn setEnum(new Set(values))\n}\n\nfunction parseUrl(str: string) {\n\ttry {\n\t\treturn new URL(str)\n\t} catch {\n\t\tif (str.startsWith('/') || str.startsWith('./')) {\n\t\t\ttry {\n\t\t\t\treturn new URL(str, 'http://example.com')\n\t\t\t} catch {\n\t\t\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t\t\t}\n\t\t}\n\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t}\n}\n\nconst validLinkProtocols = new Set(['http:', 'https:', 'mailto:'])\n\n/**\n * Validator for URLs that are safe to use as user-facing links. Accepts http, https, and mailto protocols.\n * This validator provides security by rejecting potentially dangerous protocols like javascript:.\n *\n * @example\n * ```ts\n * const link = T.linkUrl.validate(\"https://example.com\") // Valid\n * const email = T.linkUrl.validate(\"mailto:user@example.com\") // Valid\n * T.linkUrl.validate(\"\") // Valid (empty string allowed)\n * T.linkUrl.validate(\"javascript:alert(1)\") // Throws ValidationError (unsafe protocol)\n * ```\n * @public\n */\nexport const linkUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validLinkProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n// N.B. asset: is a reference to the local indexedDB object store.\nconst validSrcProtocols = new Set(['http:', 'https:', 'data:', 'asset:'])\n\n/**\n * Validator for URLs that are safe to use as asset sources. Accepts http, https, data, and asset protocols.\n * The asset: protocol refers to tldraw's local IndexedDB object store.\n *\n * @example\n * ```ts\n * const imageUrl = T.srcUrl.validate(\"https://example.com/image.png\") // Valid\n * const dataUrl = T.srcUrl.validate(\"data:image/png;base64,iVBORw0...\") // Valid\n * const assetUrl = T.srcUrl.validate(\"asset:abc123\") // Valid (local asset reference)\n * T.srcUrl.validate(\"\") // Valid (empty string allowed)\n * ```\n * @public\n */\nexport const srcUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validSrcProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validator for HTTP and HTTPS URLs only. Rejects all other protocols.\n *\n * @example\n * ```ts\n * const apiUrl = T.httpUrl.validate(\"https://api.example.com\") // Valid\n * const httpUrl = T.httpUrl.validate(\"http://localhost:3000\") // Valid\n * T.httpUrl.validate(\"\") // Valid (empty string allowed)\n * T.httpUrl.validate(\"ftp://files.example.com\") // Throws ValidationError (not http/https)\n * ```\n * @public\n */\nexport const httpUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!url.protocol.toLowerCase().match(/^https?:$/)) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validator for IndexKey values used in tldraw's indexing system. An IndexKey is a string\n * that meets specific format requirements for use as a database index.\n *\n * @throws ValidationError When the string is not a valid IndexKey format\n * @example\n * ```ts\n * const key = T.indexKey.validate(\"valid_index_key\") // Returns IndexKey\n * T.indexKey.validate(\"invalid key!\") // Throws ValidationError (invalid format)\n * ```\n * @public\n */\nexport const indexKey = string.refine<IndexKey>((key) => {\n\ttry {\n\t\tvalidateIndexKey(key)\n\t\treturn key\n\t} catch {\n\t\tthrow new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)\n\t}\n})\n\n/**\n * Creates a validator that accepts values matching either of two validators.\n * Tries the first validator, and if it fails, tries the second validator.\n *\n * @param v1 - The first validator to try\n * @param v2 - The second validator to try if the first fails\n * @returns A validator that accepts values matching either validator\n * @throws ValidationError When the value matches neither validator (throws error from v2)\n * @example\n * ```ts\n * const stringOrNumber = T.or(T.string, T.number)\n * stringOrNumber.validate(\"hello\") // Returns \"hello\" as string\n * stringOrNumber.validate(42) // Returns 42 as number\n * stringOrNumber.validate(true) // Throws ValidationError from number validator\n * ```\n * @public\n */\nexport function or<T1, T2>(v1: Validatable<T1>, v2: Validatable<T2>): Validator<T1 | T2> {\n\treturn new Validator((value) => {\n\t\ttry {\n\t\t\treturn v1.validate(value)\n\t\t} catch {\n\t\t\treturn v2.validate(value)\n\t\t}\n\t})\n}\n"],"names":["object", "number", "key", "value"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2492, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/validate/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport * as T from './lib/validation'\n\nexport {\n\tArrayOfValidator,\n\tDictValidator,\n\tObjectValidator,\n\tUnionValidator,\n\tValidator,\n\ttype UnionValidatorConfig,\n} from './lib/validation'\nexport { T }\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,YAAY,OAAO;;;;IAYnB,sMAAA,EACE,oBACA,SACA","debugId":null}},
    {"offset": {"line": 2535, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useStateTracking.ts"],"sourcesContent":["import { EffectScheduler } from '@tldraw/state'\nimport React from 'react'\n\n/**\n * Wraps some synchronous react render logic in a reactive tracking context.\n *\n * This allows you to use reactive values transparently.\n *\n * See the `track` component wrapper, which uses this under the hood.\n *\n * @param name - A debug name for the reactive tracking context\n * @param render - The render function that accesses reactive values\n * @param deps - Optional dependency array to control when the tracking context is recreated\n * @returns The result of calling the render function\n *\n * @example\n * ```ts\n * function MyComponent() {\n *   return useStateTracking('MyComponent', () => {\n *     const editor = useEditor()\n *     return <div>Num shapes: {editor.getCurrentPageShapes().length}</div>\n *   })\n * }\n * ```\n *\n *\n * @public\n */\nexport function useStateTracking<T>(name: string, render: () => T, deps: unknown[] = []): T {\n\t// This hook creates an effect scheduler that will trigger re-renders when its reactive dependencies change, but it\n\t// defers the actual execution of the effect to the consumer of this hook.\n\n\t// We need the exec fn to always be up-to-date when calling scheduler.execute() but it'd be wasteful to\n\t// instantiate a new EffectScheduler on every render, so we use an immediately-updated ref\n\t// to wrap it\n\tconst renderRef = React.useRef(render)\n\trenderRef.current = render\n\n\tconst [scheduler, subscribe, getSnapshot] = React.useMemo(() => {\n\t\tlet scheduleUpdate = null as null | (() => void)\n\t\t// useSyncExternalStore requires a subscribe function that returns an unsubscribe function\n\t\tconst subscribe = (cb: () => void) => {\n\t\t\tscheduleUpdate = cb\n\t\t\treturn () => {\n\t\t\t\tscheduleUpdate = null\n\t\t\t}\n\t\t}\n\n\t\tconst scheduler = new EffectScheduler(\n\t\t\t`useStateTracking(${name})`,\n\t\t\t// this is what `scheduler.execute()` will call\n\t\t\t() => renderRef.current?.(),\n\t\t\t// this is what will be invoked when @tldraw/state detects a change in an upstream reactive value\n\t\t\t{\n\t\t\t\tscheduleEffect() {\n\t\t\t\t\tscheduleUpdate?.()\n\t\t\t\t},\n\t\t\t}\n\t\t)\n\n\t\t// we use an incrementing number based on when this\n\t\tconst getSnapshot = () => scheduler.scheduleCount\n\n\t\treturn [scheduler, subscribe, getSnapshot]\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [name, ...deps])\n\n\tReact.useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\n\t// reactive dependencies are captured when `scheduler.execute()` is called\n\t// and then to make it reactive we wait for a `useEffect` to 'attach'\n\t// this allows us to avoid rendering outside of React's render phase\n\t// and avoid 'zombie' components that try to render with bad/deleted data before\n\t// react has a chance to umount them.\n\tReact.useEffect(() => {\n\t\tscheduler.attach()\n\t\t// do not execute, we only do that in render\n\t\tscheduler.maybeScheduleEffect()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t}\n\t}, [scheduler])\n\n\treturn scheduler.execute()\n}\n"],"names":["subscribe", "scheduler", "getSnapshot"],"mappings":";;;;AAAA,SAAS,uBAAuB;;AAChC,OAAO,WAAW;;;AA2BX,SAAS,iBAAoB,IAAA,EAAc,MAAA,EAAiB,OAAkB,CAAC,CAAA,EAAM;IAO3F,MAAM,YAAY,wKAAA,CAAM,MAAA,CAAO,MAAM;IACrC,UAAU,OAAA,GAAU;IAEpB,MAAM,CAAC,WAAW,WAAW,WAAW,CAAA,GAAI,wKAAA,CAAM,OAAA;oCAAQ,MAAM;YAC/D,IAAI,iBAAiB;YAErB,MAAMA;uDAAY,CAAC,OAAmB;oBACrC,iBAAiB;oBACjB;+DAAO,MAAM;4BACZ,iBAAiB;wBAClB;;gBACD;;YAEA,MAAMC,aAAY,IAAI,iMAAA,CACrB,CAAA,iBAAA,EAAoB,IAAI,CAAA,CAAA,CAAA;4CAAA,AAExB,+CAFwB;oBAElB,UAAU,OAAA,GAAU;2CAAA,iGAAA;YAE1B;gBACC,iBAAiB;oBAChB,iBAAiB;gBAClB;YACD;YAID,MAAMC;yDAAc,IAAMD,WAAU,aAAA;;YAEpC,OAAO;gBAACA;gBAAWD;gBAAWE,YAAW;aAAA;QAE1C;mCAAG;QAAC,MAAM;WAAG,IAAI;KAAC;IAElB,wKAAA,CAAM,oBAAA,CAAqB,WAAW,aAAa,WAAW;IAO9D,wKAAA,CAAM,SAAA;sCAAU,MAAM;YACrB,UAAU,MAAA,CAAO;YAEjB,UAAU,mBAAA,CAAoB;YAC9B;8CAAO,MAAM;oBACZ,UAAU,MAAA,CAAO;gBAClB;;QACD;qCAAG;QAAC,SAAS;KAAC;IAEd,OAAO,UAAU,OAAA,CAAQ;AAC1B","debugId":null}},
    {"offset": {"line": 2604, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/track.ts"],"sourcesContent":["import React, { forwardRef, FunctionComponent, memo } from 'react'\nimport { useStateTracking } from './useStateTracking'\n\n/**\n * Proxy handlers object used to intercept function calls to React components.\n * This enables automatic signal tracking by wrapping component execution\n * in reactive tracking context.\n *\n * The proxy intercepts the function call (apply trap) and wraps it with\n * useStateTracking to enable automatic dependency tracking for signals\n * accessed during render.\n *\n * @example\n * ```ts\n * // Used internally by track() function\n * const ProxiedComponent = new Proxy(MyComponent, ProxyHandlers)\n * ```\n *\n * @internal\n */\nexport const ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components. When this is called, we know it means\n\t * React did run 'Component()', that means we can use any hooks here to setup our effect and\n\t * store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will be\n\t * forwarded to the target Component, so we don't need to copy the Component's own or inherited\n\t * properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\treturn useStateTracking(Component.displayName ?? Component.name ?? 'tracked(???)', () =>\n\t\t\tComponent.apply(thisArg, argumentsList)\n\t\t)\n\t},\n}\n\n/**\n * React internal symbol for identifying memoized components.\n * Used to detect if a component is already wrapped with React.memo().\n *\n * @example\n * ```ts\n * const isMemoComponent = component['$$typeof'] === ReactMemoSymbol\n * ```\n *\n * @internal\n */\nexport const ReactMemoSymbol = Symbol.for('react.memo')\n\n/**\n * React internal symbol for identifying forward ref components.\n * Used to detect if a component is wrapped with React.forwardRef().\n *\n * @example\n * ```ts\n * const isForwardRefComponent = component['$$typeof'] === ReactForwardRefSymbol\n * ```\n *\n * @internal\n */\nexport const ReactForwardRefSymbol = Symbol.for('react.forward_ref')\n\n/**\n * Returns a tracked version of the given component.\n * Any signals whose values are read while the component renders will be tracked.\n * If any of the tracked signals change later it will cause the component to re-render.\n *\n * This also wraps the component in a React.memo() call, so it will only re-render\n * when props change OR when any tracked signals change. This provides optimal\n * performance by preventing unnecessary re-renders while maintaining reactivity.\n *\n * The function handles special React component types like forwardRef and memo\n * components automatically, preserving their behavior while adding reactivity.\n *\n * @param baseComponent - The React functional component to make reactive to signal changes\n * @returns A memoized component that re-renders when props or tracked signals change\n *\n * @example\n * ```ts\n * import { atom } from '@tldraw/state'\n * import { track, useAtom } from '@tldraw/state-react'\n *\n * const Counter = track(function Counter(props: CounterProps) {\n *   const count = useAtom('count', 0)\n *   const increment = useCallback(() => count.set(count.get() + 1), [count])\n *   return <button onClick={increment}>{count.get()}</button>\n * })\n *\n * // Component automatically re-renders when count signal changes\n * ```\n *\n * @example\n * ```ts\n * // Works with forwardRef components\n * const TrackedInput = track(React.forwardRef<HTMLInputElement, InputProps>(\n *   function TrackedInput(props, ref) {\n *     const theme = useValue(themeSignal)\n *     return <input ref={ref} style={{ color: theme.textColor }} {...props} />\n *   }\n * ))\n * ```\n *\n * @public\n */\nexport function track<T extends FunctionComponent<any>>(\n\tbaseComponent: T\n): React.NamedExoticComponent<React.ComponentProps<T>> {\n\tlet compare = null\n\tconst $$typeof = baseComponent['$$typeof' as keyof typeof baseComponent]\n\tif ($$typeof === ReactMemoSymbol) {\n\t\tbaseComponent = (baseComponent as any).type\n\t\tcompare = (baseComponent as any).compare\n\t}\n\tif ($$typeof === ReactForwardRefSymbol) {\n\t\treturn memo(forwardRef(new Proxy((baseComponent as any).render, ProxyHandlers) as any)) as any\n\t}\n\n\treturn memo(new Proxy(baseComponent, ProxyHandlers) as any, compare) as any\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,SAAgB,YAA+B,YAAY;AAC3D,SAAS,wBAAwB;;;AAmB1B,MAAM,gBAAgB;IAAA;;;;;;;;;;GAAA,GAY5B,OAAM,SAAA,EAA8B,OAAA,EAAc,aAAA,EAAoB;QAErE,WAAO,4MAAA,EAAiB,UAAU,WAAA,IAAe,UAAU,IAAA,IAAQ,gBAAgB,IAClF,UAAU,KAAA,CAAM,SAAS,aAAa;IAExC;AACD;AAaO,MAAM,kBAAkB,OAAO,GAAA,CAAI,YAAY;AAa/C,MAAM,wBAAwB,OAAO,GAAA,CAAI,mBAAmB;AA4C5D,SAAS,MACf,aAAA,EACsD;IACtD,IAAI,UAAU;IACd,MAAM,WAAW,aAAA,CAAc,UAAwC,CAAA;IACvE,IAAI,aAAa,iBAAiB;QACjC,gBAAiB,cAAsB,IAAA;QACvC,UAAW,cAAsB,OAAA;IAClC;IACA,IAAI,aAAa,uBAAuB;QACvC,WAAO,qKAAA,MAAK,2KAAA,EAAW,IAAI,MAAO,cAAsB,MAAA,EAAQ,aAAa,CAAQ,CAAC;IACvF;IAEA,WAAO,qKAAA,EAAK,IAAI,MAAM,eAAe,aAAa,GAAU,OAAO;AACpE","debugId":null}},
    {"offset": {"line": 2653, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useAtom.ts"],"sourcesContent":["import { Atom, AtomOptions, atom } from '@tldraw/state'\nimport { useState } from 'react'\n\n/**\n * Creates a new atom and returns it. The atom will be created only once.\n *\n * See `atom`.\n *\n * @example\n * ```ts\n * const Counter = track(function Counter () {\n *   const count = useAtom('count', 0)\n *   const increment = useCallback(() => count.set(count.get() + 1), [count])\n *   return <button onClick={increment}>{count.get()}</button>\n * })\n * ```\n *\n * @param name - The name of the atom. This does not need to be globally unique. It is used for debugging and performance profiling.\n * @param valueOrInitialiser - The initial value of the atom. If this is a function, it will be called to get the initial value.\n * @param options - Options for the atom.\n *\n * @public\n */\nexport function useAtom<Value, Diff = unknown>(\n\tname: string,\n\tvalueOrInitialiser: Value | (() => Value),\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn useState(() => {\n\t\tconst initialValue =\n\t\t\ttypeof valueOrInitialiser === 'function' ? (valueOrInitialiser as any)() : valueOrInitialiser\n\n\t\treturn atom(`useAtom(${name})`, initialValue, options)\n\t})[0]\n}\n"],"names":[],"mappings":";;;;;AAAA,SAA4B,YAAY;AACxC,SAAS,gBAAgB;;;AAsBlB,SAAS,QACf,IAAA,EACA,kBAAA,EACA,OAAA,EACoB;IACpB,WAAO,yKAAA;4BAAS,MAAM;YACrB,MAAM,eACL,OAAO,uBAAuB,aAAc,mBAA2B,IAAI;YAE5E,WAAO,2KAAA,EAAK,CAAA,QAAA,EAAW,IAAI,CAAA,CAAA,CAAA,EAAK,cAAc,OAAO;QACtD,CAAC;0BAAA,CAAE,CAAC,CAAA;AACL","debugId":null}},
    {"offset": {"line": 2676, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useComputed.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { Computed, ComputedOptions, computed } from '@tldraw/state'\nimport { useMemo } from 'react'\n\n/**\n * Creates a new computed signal that automatically tracks its dependencies and recalculates when they change.\n * This overload is for basic computed values without custom options.\n *\n * @param name - A descriptive name for the computed signal, used for debugging and identification\n * @param compute - A function that computes the value, automatically tracking any signal dependencies\n * @param deps - React dependency array that controls when the computed signal is recreated\n * @returns A computed signal containing the calculated value\n *\n * @example\n * ```ts\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * function UserProfile() {\n *   const fullName = useComputed(\n *     'fullName',\n *     () => `${firstName.get()} ${lastName.get()}`,\n *     [firstName, lastName]\n *   )\n *\n *   return <div>Welcome, {fullName.get()}!</div>\n * }\n * ```\n *\n * @public\n */\nexport function useComputed<Value>(name: string, compute: () => Value, deps: any[]): Computed<Value>\n\n/**\n * Creates a new computed signal with custom options for advanced behavior like custom equality checking,\n * diff computation, and history tracking. The computed signal will be created only once.\n *\n * @param name - A descriptive name for the computed signal, used for debugging and identification\n * @param compute - A function that computes the value, automatically tracking any signal dependencies\n * @param opts - Configuration options for the computed signal\n *   - isEqual - Custom equality function to determine if the computed value has changed\n *   - computeDiff - Function to compute diffs between old and new values for history tracking\n *   - historyLength - Maximum number of diffs to keep in history buffer for time-travel functionality\n * @param deps - React dependency array that controls when the computed signal is recreated\n * @returns A computed signal containing the calculated value with the specified options\n *\n * @example\n * ```ts\n * function ShoppingCart() {\n *   const items = useAtom('items', [])\n *\n *   // Computed with custom equality to avoid recalculation for equivalent arrays\n *   const sortedItems = useComputed(\n *     'sortedItems',\n *     () => items.get().sort((a, b) => a.name.localeCompare(b.name)),\n *     {\n *       isEqual: (a, b) => a.length === b.length && a.every((item, i) => item.id === b[i].id)\n *     },\n *     [items]\n *   )\n *\n *   return <ItemList items={sortedItems.get()} />\n * }\n * ```\n *\n * @public\n */\nexport function useComputed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: () => Value,\n\topts: ComputedOptions<Value, Diff>,\n\tdeps: any[]\n): Computed<Value>\n/**\n * Implementation function that handles both overloaded signatures of useComputed.\n * Uses the arguments object to dynamically determine which signature was called.\n *\n * This function creates a memoized computed signal that automatically tracks dependencies\n * and only recreates when the dependency array changes, providing optimal performance\n * in React components.\n *\n * @public\n */\nexport function useComputed() {\n\tconst name = arguments[0]\n\tconst compute = arguments[1]\n\tconst opts = arguments.length === 3 ? undefined : arguments[2]\n\tconst deps = arguments.length === 3 ? arguments[2] : arguments[3]\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\treturn useMemo(() => computed(`useComputed(${name})`, compute, opts), deps)\n}\n"],"names":[],"mappings":";;;;;AACA,SAAoC,gBAAgB;AACpD,SAAS,eAAe;;;AAiFjB,SAAS,cAAc;IAC7B,MAAM,OAAO,SAAA,CAAU,CAAC,CAAA;IACxB,MAAM,UAAU,SAAA,CAAU,CAAC,CAAA;IAC3B,MAAM,OAAO,UAAU,MAAA,KAAW,IAAI,KAAA,IAAY,SAAA,CAAU,CAAC,CAAA;IAC7D,MAAM,OAAO,UAAU,MAAA,KAAW,IAAI,SAAA,CAAU,CAAC,CAAA,GAAI,SAAA,CAAU,CAAC,CAAA;IAEhE,WAAO,wKAAA;+BAAQ,QAAM,mLAAA,EAAS,CAAA,YAAA,EAAe,IAAI,CAAA,CAAA,CAAA,EAAK,SAAS,IAAI;8BAAG,IAAI;AAC3E","debugId":null}},
    {"offset": {"line": 2700, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useQuickReactor.ts"],"sourcesContent":["import { EMPTY_ARRAY, EffectScheduler } from '@tldraw/state'\nimport { useEffect } from 'react'\n\n/**\n * A React hook that runs side effects immediately in response to signal changes, without throttling.\n * Unlike useReactor which batches updates to animation frames, useQuickReactor executes the effect\n * function immediately when dependencies change, making it ideal for critical updates that cannot wait.\n *\n * The effect runs immediately when the component mounts and whenever tracked signals change.\n * Updates are not throttled, so the effect executes synchronously on every change.\n *\n * @example\n * ```ts\n * function DataSynchronizer() {\n *   const criticalData = useAtom('criticalData', null)\n *\n *   useQuickReactor('sync-data', () => {\n *     const data = criticalData.get()\n *     if (data) {\n *       // Send immediately - don't wait for next frame\n *       sendToServer(data)\n *     }\n *   }, [criticalData])\n *\n *   return <div>Sync status updated</div>\n * }\n * ```\n *\n * @example\n * ```ts\n * function CursorUpdater({ editor }) {\n *   useQuickReactor('update-cursor', () => {\n *     const cursor = editor.getInstanceState().cursor\n *     document.body.style.cursor = cursor.type\n *   }, [])\n * }\n * ```\n *\n * @param name - A descriptive name for the reactor, used for debugging and performance profiling\n * @param reactFn - The effect function to execute when signals change. Should not return a value.\n * @param deps - Optional dependency array that controls when the reactor is recreated. Works like useEffect deps.\n * @public\n */\nexport function useQuickReactor(name: string, reactFn: () => void, deps: any[] = EMPTY_ARRAY) {\n\tuseEffect(() => {\n\t\tconst scheduler = new EffectScheduler(name, reactFn)\n\t\tscheduler.attach()\n\t\tscheduler.execute()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,aAAa,uBAAuB;AAC7C,SAAS,iBAAiB;;;AA0CnB,SAAS,gBAAgB,IAAA,EAAc,OAAA,EAAqB,OAAc,qLAAA,EAAa;IAC7F,IAAA,0KAAA;qCAAU,MAAM;YACf,MAAM,YAAY,IAAI,iMAAA,CAAgB,MAAM,OAAO;YACnD,UAAU,MAAA,CAAO;YACjB,UAAU,OAAA,CAAQ;YAClB;6CAAO,MAAM;oBACZ,UAAU,MAAA,CAAO;gBAClB;;QAED;oCAAG,IAAI;AACR","debugId":null}},
    {"offset": {"line": 2730, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useReactor.ts"],"sourcesContent":["import { EffectScheduler } from '@tldraw/state'\nimport { throttleToNextFrame } from '@tldraw/utils'\nimport { useEffect } from 'react'\n\n/**\n * A React hook that runs a side effect in response to changes in signals (reactive state).\n *\n * The effect function will automatically track any signals (atoms, computed values) that are\n * accessed during its execution. When any of those signals change, the effect will be\n * scheduled to run again on the next animation frame.\n *\n * This is useful for performing side effects (like updating the DOM, making API calls, or\n * updating external state) in response to changes in tldraw's reactive state system, while\n * keeping those effects efficiently batched and throttled.\n *\n * @example\n * ```tsx\n * import { useReactor, useEditor } from 'tldraw'\n *\n * function MyComponent() {\n *   const editor = useEditor()\n *\n *   // Update document title when shapes change\n *   useReactor(\n *     'update title',\n *     () => {\n *       const shapes = editor.getCurrentPageShapes()\n *       document.title = `Shapes: ${shapes.length}`\n *     },\n *     [editor]\n *   )\n *\n *   return <div>...</div>\n * }\n * ```\n *\n * @example\n * ```tsx\n * import { useReactor, useEditor } from 'tldraw'\n *\n * function SelectionAnnouncer() {\n *   const editor = useEditor()\n *\n *   // Announce selection changes for accessibility\n *   useReactor(\n *     'announce selection',\n *     () => {\n *       const selectedIds = editor.getSelectedShapeIds()\n *       if (selectedIds.length > 0) {\n *         console.log(`Selected ${selectedIds.length} shape(s)`)\n *       }\n *     },\n *     [editor]\n *   )\n *\n *   return null\n * }\n * ```\n *\n * @remarks\n * The effect is throttled to run at most once per animation frame using `requestAnimationFrame`.\n * This makes it suitable for effects that need to respond to state changes but don't need to\n * run synchronously.\n *\n * If you need the effect to run immediately without throttling, use {@link useQuickReactor} instead.\n *\n * The effect function will be re-created when any of the `deps` change, similar to React's\n * `useEffect`. The effect automatically tracks which signals it accesses, so you don't need\n * to manually specify them as dependencies.\n *\n * @param name - A debug name for the effect, useful for debugging and performance profiling.\n * @param reactFn - The effect function to run. Any signals accessed in this function will be tracked.\n * @param deps - React dependencies array. The effect will be recreated when these change. Defaults to `[]`.\n *\n * @public\n */\nexport function useReactor(name: string, reactFn: () => void, deps: undefined | any[] = []) {\n\tuseEffect(() => {\n\t\tlet cancelFn: () => void | undefined\n\t\tconst scheduler = new EffectScheduler(name, reactFn, {\n\t\t\tscheduleEffect: (cb) => {\n\t\t\t\tcancelFn = throttleToNextFrame(cb)\n\t\t\t},\n\t\t})\n\t\tscheduler.attach()\n\t\tscheduler.execute()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t\tcancelFn?.()\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,uBAAuB;;AAChC,SAAS,2BAA2B;AACpC,SAAS,iBAAiB;;;;AA0EnB,SAAS,WAAW,IAAA,EAAc,OAAA,EAAqB,OAA0B,CAAC,CAAA,EAAG;IAC3F,IAAA,0KAAA;gCAAU,MAAM;YACf,IAAI;YACJ,MAAM,YAAY,IAAI,iMAAA,CAAgB,MAAM,SAAS;gBACpD,cAAA;4CAAgB,CAAC,OAAO;wBACvB,eAAW,8LAAA,EAAoB,EAAE;oBAClC;;YACD,CAAC;YACD,UAAU,MAAA,CAAO;YACjB,UAAU,OAAA,CAAQ;YAClB;wCAAO,MAAM;oBACZ,UAAU,MAAA,CAAO;oBACjB,WAAW;gBACZ;;QAED;+BAAG,IAAI;AACR","debugId":null}},
    {"offset": {"line": 2770, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/lib/useValue.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { Signal, computed, react } from '@tldraw/state'\nimport { useMemo, useSyncExternalStore } from 'react'\n\n/**\n * Extracts the current value from a signal and subscribes the component to changes.\n *\n * This is the most straightforward way to read signal values in React components.\n * When the signal changes, the component will automatically re-render with the new value.\n *\n * Note: You do not need to use this hook if you are wrapping the component with {@link track},\n * as tracked components automatically subscribe to any signals accessed with `.get()`.\n *\n * @param value - The signal to read the value from\n * @returns The current value of the signal\n *\n * @example\n * ```ts\n * import { atom } from '@tldraw/state'\n * import { useValue } from '@tldraw/state-react'\n *\n * const count = atom('count', 0)\n *\n * function Counter() {\n *   const currentCount = useValue(count)\n *   return (\n *     <button onClick={() => count.set(currentCount + 1)}>\n *       Count: {currentCount}\n *     </button>\n *   )\n * }\n * ```\n *\n * @public\n */\nexport function useValue<Value>(value: Signal<Value>): Value\n\n/**\n * Creates a computed value with automatic dependency tracking and subscribes to changes.\n *\n * This overload allows you to compute a value from one or more signals with automatic\n * memoization. The computed function will only re-execute when its dependencies change,\n * and the component will only re-render when the computed result changes.\n *\n * @param name - A descriptive name for debugging purposes\n * @param fn - Function that computes the value, should call `.get()` on any signals it depends on\n * @param deps - Array of signals that the computed function depends on\n * @returns The computed value\n *\n * @example\n * ```ts\n * import { atom } from '@tldraw/state'\n * import { useValue } from '@tldraw/state-react'\n *\n * const firstName = atom('firstName', 'John')\n * const lastName = atom('lastName', 'Doe')\n *\n * function UserGreeting() {\n *   const fullName = useValue('fullName', () => {\n *     return `${firstName.get()} ${lastName.get()}`\n *   }, [firstName, lastName])\n *\n *   return <div>Hello {fullName}!</div>\n * }\n * ```\n *\n * @public\n */\nexport function useValue<Value>(name: string, fn: () => Value, deps: unknown[]): Value\n\n/**\n * Implementation function for useValue hook overloads.\n *\n * Handles both single signal subscription and computed value creation with dependency tracking.\n * Uses React's useSyncExternalStore for efficient subscription management and automatic cleanup.\n *\n * @internal\n */\nexport function useValue() {\n\tconst args = arguments\n\t// deps will be either the computed or the deps array\n\tconst deps = args.length === 3 ? args[2] : [args[0]]\n\tconst name = args.length === 3 ? args[0] : `useValue(${args[0].name})`\n\n\tconst { $val, subscribe, getSnapshot } = useMemo(() => {\n\t\tconst $val =\n\t\t\targs.length === 1 ? (args[0] as Signal<any>) : (computed(name, args[1]) as Signal<any>)\n\n\t\treturn {\n\t\t\t$val,\n\t\t\tsubscribe: (notify: () => void) => {\n\t\t\t\treturn react(`useValue(${name})`, () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$val.get()\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Will be rethrown during render if the component doesn't unmount first.\n\t\t\t\t\t}\n\t\t\t\t\tnotify()\n\t\t\t\t})\n\t\t\t},\n\t\t\tgetSnapshot: () => $val.lastChangedEpoch,\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n\n\tuseSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\treturn $val.__unsafe__getWithoutCapture()\n}\n"],"names":["$val"],"mappings":";;;;;;AACA,SAAiB,UAAU,aAAa;AACxC,SAAS,SAAS,4BAA4B;;;AA4EvC,SAAS,WAAW;IAC1B,MAAM,OAAO;IAEb,MAAM,OAAO,KAAK,MAAA,KAAW,IAAI,IAAA,CAAK,CAAC,CAAA,GAAI;QAAC,IAAA,CAAK,CAAC,CAAC;KAAA;IACnD,MAAM,OAAO,KAAK,MAAA,KAAW,IAAI,IAAA,CAAK,CAAC,CAAA,GAAI,CAAA,SAAA,EAAY,IAAA,CAAK,CAAC,CAAA,CAAE,IAAI,CAAA,CAAA,CAAA;IAEnE,MAAM,EAAE,IAAA,EAAM,SAAA,EAAW,WAAA,CAAY,CAAA,OAAI,wKAAA;4BAAQ,MAAM;YACtD,MAAMA,QACL,KAAK,MAAA,KAAW,IAAK,IAAA,CAAK,CAAC,CAAA,OAAqB,mLAAA,EAAS,MAAM,IAAA,CAAK,CAAC,CAAC;YAEvE,OAAO;gBACN,MAAAA;gBACA,SAAA;wCAAW,CAAC,WAAuB;wBAClC,WAAO,uLAAA,EAAM,CAAA,SAAA,EAAY,IAAI,CAAA,CAAA,CAAA;gDAAK,MAAM;gCACvC,IAAI;oCACHA,MAAK,GAAA,CAAI;gCACV,EAAA,OAAQ,CAER;gCACA,OAAO;4BACR,CAAC;;oBACF;;gBACA,WAAA;wCAAa,IAAMA,MAAK,gBAAA;;YACzB;QAED;2BAAG,IAAI;IAEP,IAAA,qLAAA,EAAqB,WAAW,aAAa,WAAW;IACxD,OAAO,KAAK,2BAAA,CAA4B;AACzC","debugId":null}},
    {"offset": {"line": 2818, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/state-react/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { track } from './lib/track'\nexport { useAtom } from './lib/useAtom'\nexport { useComputed } from './lib/useComputed'\nexport { useQuickReactor } from './lib/useQuickReactor'\nexport { useReactor } from './lib/useReactor'\nexport { useStateTracking } from './lib/useStateTracking'\nexport { useValue } from './lib/useValue'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB,SAAS,mBAAmB;AAC5B,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;AAC3B,SAAS,wBAAwB;AACjC,SAAS,gBAAgB;;;;;;;;;IAEzB,sMAAA,EACE,uBACA,SACA","debugId":null}},
    {"offset": {"line": 2871, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync/src/useSync.ts"],"sourcesContent":["import { atom, isSignal, transact } from '@tldraw/state'\nimport { useAtom } from '@tldraw/state-react'\nimport {\n\tClientWebSocketAdapter,\n\tTLCustomMessageHandler,\n\tTLPresenceMode,\n\tTLRemoteSyncError,\n\tTLSyncClient,\n\tTLSyncErrorCloseEventReason,\n} from '@tldraw/sync-core'\nimport { useEffect } from 'react'\nimport {\n\tEditor,\n\tInstancePresenceRecordType,\n\tSignal,\n\tTAB_ID,\n\tTLAssetStore,\n\tTLPresenceStateInfo,\n\tTLPresenceUserInfo,\n\tTLRecord,\n\tTLStore,\n\tTLStoreSchemaOptions,\n\tTLStoreWithStatus,\n\tcomputed,\n\tcreateTLStore,\n\tdefaultUserPreferences,\n\tgetDefaultUserPresence,\n\tgetUserPreferences,\n\tuniqueId,\n\tuseEvent,\n\tuseReactiveEvent,\n\tuseRefState,\n\tuseShallowObjectIdentity,\n\tuseTLSchemaFromUtils,\n\tuseValue,\n} from 'tldraw'\n\nconst MULTIPLAYER_EVENT_NAME = 'multiplayer.client'\n\nconst defaultCustomMessageHandler: TLCustomMessageHandler = () => {}\n\n/**\n * A store wrapper specifically for remote collaboration that excludes local-only states.\n * This type represents a tldraw store that is synchronized with a remote multiplayer server.\n *\n * Unlike the base TLStoreWithStatus, this excludes 'synced-local' and 'not-synced' states\n * since remote stores are always either loading, connected to a server, or in an error state.\n *\n * @example\n * ```tsx\n * function MyCollaborativeApp() {\n *   const store: RemoteTLStoreWithStatus = useSync({\n *     uri: 'wss://myserver.com/sync/room-123',\n *     assets: myAssetStore\n *   })\n *\n *   if (store.status === 'loading') {\n *     return <div>Connecting to multiplayer session...</div>\n *   }\n *\n *   if (store.status === 'error') {\n *     return <div>Connection failed: {store.error.message}</div>\n *   }\n *\n *   // store.status === 'synced-remote'\n *   return <Tldraw store={store.store} />\n * }\n * ```\n *\n * @public\n */\nexport type RemoteTLStoreWithStatus = Exclude<\n\tTLStoreWithStatus,\n\t{ status: 'synced-local' } | { status: 'not-synced' }\n>\n\n/**\n * Creates a reactive store synchronized with a multiplayer server for real-time collaboration.\n *\n * This hook manages the complete lifecycle of a collaborative tldraw session, including\n * WebSocket connection establishment, state synchronization, user presence, and error handling.\n * The returned store can be passed directly to the Tldraw component to enable multiplayer features.\n *\n * The store progresses through multiple states:\n * - `loading`: Establishing connection and synchronizing initial state\n * - `synced-remote`: Successfully connected and actively synchronizing changes\n * - `error`: Connection failed or synchronization error occurred\n *\n * For optimal performance with media assets, provide an `assets` store that implements\n * external blob storage. Without this, large images and videos will be stored inline\n * as base64, causing performance issues during serialization.\n *\n * @param opts - Configuration options for multiplayer synchronization\n *   - `uri` - WebSocket server URI (string or async function returning URI)\n *   - `assets` - Asset store for blob storage (required for production use)\n *   - `userInfo` - User information for presence system (can be reactive signal)\n *   - `getUserPresence` - Optional function to customize presence data\n *   - `onCustomMessageReceived` - Handler for custom socket messages\n *   - `roomId` - Room identifier for analytics (internal use)\n *   - `onMount` - Callback when editor mounts (internal use)\n *   - `trackAnalyticsEvent` - Analytics event tracker (internal use)\n *\n * @returns A reactive store wrapper with connection status and synchronized store\n *\n * @example\n * ```tsx\n * // Basic multiplayer setup\n * function CollaborativeApp() {\n *   const store = useSync({\n *     uri: 'wss://myserver.com/sync/room-123',\n *     assets: myAssetStore,\n *     userInfo: {\n *       id: 'user-1',\n *       name: 'Alice',\n *       color: '#ff0000'\n *     }\n *   })\n *\n *   if (store.status === 'loading') {\n *     return <div>Connecting to collaboration session...</div>\n *   }\n *\n *   if (store.status === 'error') {\n *     return <div>Failed to connect: {store.error.message}</div>\n *   }\n *\n *   return <Tldraw store={store.store} />\n * }\n * ```\n *\n * @example\n * ```tsx\n * // Dynamic authentication with reactive user info\n * import { atom } from '@tldraw/state'\n *\n * function AuthenticatedApp() {\n *   const currentUser = atom('user', { id: 'user-1', name: 'Alice', color: '#ff0000' })\n *\n *   const store = useSync({\n *     uri: async () => {\n *       const token = await getAuthToken()\n *       return `wss://myserver.com/sync/room-123?token=${token}`\n *     },\n *     assets: authenticatedAssetStore,\n *     userInfo: currentUser, // Reactive signal\n *     getUserPresence: (store, user) => {\n *       return {\n *         userId: user.id,\n *         userName: user.name,\n *         cursor: getCurrentCursor(store)\n *       }\n *     }\n *   })\n *\n *   return <Tldraw store={store.store} />\n * }\n * ```\n *\n * @public\n */\nexport function useSync(opts: UseSyncOptions & TLStoreSchemaOptions): RemoteTLStoreWithStatus {\n\tconst [state, setState] = useRefState<{\n\t\treadyClient?: TLSyncClient<TLRecord, TLStore>\n\t\terror?: Error\n\t} | null>(null)\n\tconst {\n\t\turi,\n\t\troomId = 'default',\n\t\tassets,\n\t\tonMount,\n\t\ttrackAnalyticsEvent: track,\n\t\tuserInfo,\n\t\tgetUserPresence: _getUserPresence,\n\t\tonCustomMessageReceived: _onCustomMessageReceived,\n\t\t...schemaOpts\n\t} = opts\n\n\t// This line will throw a type error if we add any new options to the useSync hook but we don't destructure them\n\t// This is required because otherwise the useTLSchemaFromUtils might return a new schema on every render if the newly-added option\n\t// is allowed to be unstable (e.g. userInfo)\n\tconst __never__: never = 0 as any as keyof Omit<typeof schemaOpts, keyof TLStoreSchemaOptions>\n\n\tconst schema = useTLSchemaFromUtils(schemaOpts)\n\n\tconst prefs = useShallowObjectIdentity(userInfo)\n\tconst getUserPresence = useReactiveEvent(_getUserPresence ?? getDefaultUserPresence)\n\tconst onCustomMessageReceived = useEvent(_onCustomMessageReceived ?? defaultCustomMessageHandler)\n\n\tconst userAtom = useAtom<TLPresenceUserInfo | Signal<TLPresenceUserInfo> | undefined>(\n\t\t'userAtom',\n\t\tprefs\n\t)\n\n\tuseEffect(() => {\n\t\tuserAtom.set(prefs)\n\t}, [prefs, userAtom])\n\n\tuseEffect(() => {\n\t\tconst storeId = uniqueId()\n\n\t\tconst userPreferences = computed<{ id: string; color: string; name: string }>(\n\t\t\t'userPreferences',\n\t\t\t() => {\n\t\t\t\tconst userStuff = userAtom.get()\n\t\t\t\tconst user = (isSignal(userStuff) ? userStuff.get() : userStuff) ?? getUserPreferences()\n\t\t\t\treturn {\n\t\t\t\t\tid: user.id,\n\t\t\t\t\tcolor: user.color ?? defaultUserPreferences.color,\n\t\t\t\t\tname: user.name ?? defaultUserPreferences.name,\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\tconst socket = new ClientWebSocketAdapter(async () => {\n\t\t\tconst uriString = typeof uri === 'string' ? uri : await uri()\n\n\t\t\t// set sessionId as a query param on the uri\n\t\t\tconst withParams = new URL(uriString)\n\t\t\tif (withParams.searchParams.has('sessionId')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'useSync. \"sessionId\" is a reserved query param name. Please use a different name'\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (withParams.searchParams.has('storeId')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'useSync. \"storeId\" is a reserved query param name. Please use a different name'\n\t\t\t\t)\n\t\t\t}\n\n\t\t\twithParams.searchParams.set('sessionId', TAB_ID)\n\t\t\twithParams.searchParams.set('storeId', storeId)\n\t\t\treturn withParams.toString()\n\t\t})\n\n\t\tlet didCancel = false\n\n\t\tconst collaborationStatusSignal = computed('collaboration status', () =>\n\t\t\tsocket.connectionStatus === 'error' ? 'offline' : socket.connectionStatus\n\t\t)\n\n\t\tconst syncMode = atom('sync mode', 'readwrite' as 'readonly' | 'readwrite')\n\n\t\tconst store = createTLStore({\n\t\t\tid: storeId,\n\t\t\tschema,\n\t\t\tassets,\n\t\t\tonMount,\n\t\t\tcollaboration: {\n\t\t\t\tstatus: collaborationStatusSignal,\n\t\t\t\tmode: syncMode,\n\t\t\t},\n\t\t})\n\n\t\tconst presence = computed('instancePresence', () => {\n\t\t\tconst presenceState = getUserPresence(store, userPreferences.get())\n\t\t\tif (!presenceState) return null\n\n\t\t\treturn InstancePresenceRecordType.create({\n\t\t\t\t...presenceState,\n\t\t\t\tid: InstancePresenceRecordType.createId(store.id),\n\t\t\t})\n\t\t})\n\n\t\tconst otherUserPresences = store.query.ids('instance_presence', () => ({\n\t\t\tuserId: { neq: userPreferences.get().id },\n\t\t}))\n\n\t\tconst presenceMode = computed<TLPresenceMode>('presenceMode', () => {\n\t\t\tif (otherUserPresences.get().size === 0) return 'solo'\n\t\t\treturn 'full'\n\t\t})\n\n\t\tconst client = new TLSyncClient({\n\t\t\tstore,\n\t\t\tsocket,\n\t\t\tdidCancel: () => didCancel,\n\t\t\tonLoad(client) {\n\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'load', roomId })\n\t\t\t\tsetState({ readyClient: client })\n\t\t\t},\n\t\t\tonSyncError(reason) {\n\t\t\t\tconsole.error('sync error', reason)\n\n\t\t\t\tswitch (reason) {\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.NOT_FOUND:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'room-not-found', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.FORBIDDEN:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'forbidden', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'not-authenticated', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tcase TLSyncErrorCloseEventReason.RATE_LIMITED:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'rate-limited', roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttrack?.(MULTIPLAYER_EVENT_NAME, { name: 'sync-error:' + reason, roomId })\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tsetState({ error: new TLRemoteSyncError(reason) })\n\t\t\t\tsocket.close()\n\t\t\t},\n\t\t\tonAfterConnect(_, { isReadonly }) {\n\t\t\t\ttransact(() => {\n\t\t\t\t\tsyncMode.set(isReadonly ? 'readonly' : 'readwrite')\n\t\t\t\t\t// if the server crashes and loses all data it can return an empty document\n\t\t\t\t\t// when it comes back up. This is a safety check to make sure that if something like\n\t\t\t\t\t// that happens, it won't render the app broken and require a restart. The user will\n\t\t\t\t\t// most likely lose all their changes though since they'll have been working with pages\n\t\t\t\t\t// that won't exist. There's certainly something we can do to make this better.\n\t\t\t\t\t// but the likelihood of this happening is very low and maybe not worth caring about beyond this.\n\t\t\t\t\tstore.ensureStoreIsUsable()\n\t\t\t\t})\n\t\t\t},\n\t\t\tonCustomMessageReceived,\n\t\t\tpresence,\n\t\t\tpresenceMode,\n\t\t})\n\n\t\treturn () => {\n\t\t\tdidCancel = true\n\t\t\tclient.close()\n\t\t\tsocket.close()\n\t\t\tsetState(null)\n\t\t}\n\t}, [\n\t\tassets,\n\t\tonMount,\n\t\tuserAtom,\n\t\troomId,\n\t\tschema,\n\t\tsetState,\n\t\ttrack,\n\t\turi,\n\t\tgetUserPresence,\n\t\tonCustomMessageReceived,\n\t])\n\n\treturn useValue<RemoteTLStoreWithStatus>(\n\t\t'remote synced store',\n\t\t() => {\n\t\t\tif (!state) return { status: 'loading' }\n\t\t\tif (state.error) return { status: 'error', error: state.error }\n\t\t\tif (!state.readyClient) return { status: 'loading' }\n\t\t\tconst connectionStatus = state.readyClient.socket.connectionStatus\n\t\t\treturn {\n\t\t\t\tstatus: 'synced-remote',\n\t\t\t\tconnectionStatus: connectionStatus === 'error' ? 'offline' : connectionStatus,\n\t\t\t\tstore: state.readyClient.store,\n\t\t\t}\n\t\t},\n\t\t[state]\n\t)\n}\n\n/**\n * Configuration options for the {@link useSync} hook to establish multiplayer collaboration.\n *\n * This interface defines the required and optional settings for connecting to a multiplayer\n * server, managing user presence, handling assets, and customizing the collaboration experience.\n *\n * @example\n * ```tsx\n * const syncOptions: UseSyncOptions = {\n *   uri: 'wss://myserver.com/sync/room-123',\n *   assets: myAssetStore,\n *   userInfo: {\n *     id: 'user-1',\n *     name: 'Alice',\n *     color: '#ff0000'\n *   },\n *   getUserPresence: (store, user) => ({\n *     userId: user.id,\n *     userName: user.name,\n *     cursor: getCursorPosition()\n *   })\n * }\n * ```\n *\n * @public\n */\nexport interface UseSyncOptions {\n\t/**\n\t * The WebSocket URI of the multiplayer server for real-time synchronization.\n\t *\n\t * Must include the protocol (wss:// for secure, ws:// for local development).\n\t * HTTP/HTTPS URLs will be automatically upgraded to WebSocket connections.\n\t *\n\t * Can be a static string or a function that returns a URI (useful for dynamic\n\t * authentication tokens or room routing). The function is called on each\n\t * connection attempt, allowing for token refresh and dynamic routing.\n\t *\n\t * Reserved query parameters `sessionId` and `storeId` are automatically added\n\t * by the sync system and should not be included in your URI.\n\t *\n\t * @example\n\t * ```ts\n\t * // Static URI\n\t * uri: 'wss://myserver.com/sync/room-123'\n\t *\n\t * // Dynamic URI with authentication\n\t * uri: async () => {\n\t *   const token = await getAuthToken()\n\t *   return `wss://myserver.com/sync/room-123?token=${token}`\n\t * }\n\t * ```\n\t */\n\turi: string | (() => string | Promise<string>)\n\n\t/**\n\t * User information for multiplayer presence and identification.\n\t *\n\t * Can be a static object or a reactive signal that updates when user\n\t * information changes. The presence system automatically updates when\n\t * reactive signals change, allowing real-time user profile updates.\n\t *\n\t * Should be synchronized with the `userPreferences` prop of the main\n\t * Tldraw component for consistent user experience. If not provided,\n\t * defaults to localStorage-based user preferences.\n\t *\n\t * @example\n\t * ```ts\n\t * // Static user info\n\t * userInfo: { id: 'user-123', name: 'Alice', color: '#ff0000' }\n\t *\n\t * // Reactive user info\n\t * const userSignal = atom('user', { id: 'user-123', name: 'Alice', color: '#ff0000' })\n\t * userInfo: userSignal\n\t * ```\n\t */\n\tuserInfo?: TLPresenceUserInfo | Signal<TLPresenceUserInfo>\n\n\t/**\n\t * Asset store implementation for handling file uploads and storage.\n\t *\n\t * Required for production applications to handle images, videos, and other\n\t * media efficiently. Without an asset store, files are stored inline as\n\t * base64, which causes performance issues with large files.\n\t *\n\t * The asset store must implement upload (for new files) and resolve\n\t * (for displaying existing files) methods. For prototyping, you can use\n\t * {@link tldraw#inlineBase64AssetStore} but this is not recommended for production.\n\t *\n\t * @example\n\t * ```ts\n\t * const myAssetStore: TLAssetStore = {\n\t *   upload: async (asset, file) => {\n\t *     const url = await uploadToCloudStorage(file)\n\t *     return { src: url }\n\t *   },\n\t *   resolve: (asset, context) => {\n\t *     return getOptimizedUrl(asset.src, context)\n\t *   }\n\t * }\n\t * ```\n\t */\n\tassets: TLAssetStore\n\n\t/**\n\t * Handler for receiving custom messages sent through the multiplayer connection.\n\t *\n\t * Use this to implement custom communication channels between clients beyond\n\t * the standard shape and presence synchronization. Messages are sent using\n\t * the TLSyncClient's sendMessage method.\n\t *\n\t * @param data - The custom message data received from another client\n\t *\n\t * @example\n\t * ```ts\n\t * onCustomMessageReceived: (data) => {\n\t *   if (data.type === 'chat') {\n\t *     displayChatMessage(data.message, data.userId)\n\t *   }\n\t * }\n\t * ```\n\t */\n\tonCustomMessageReceived?(data: any): void\n\n\t/** @internal */\n\tonMount?(editor: Editor): void\n\t/** @internal used for analytics only, we should refactor this away */\n\troomId?: string\n\t/** @internal */\n\ttrackAnalyticsEvent?(name: string, data: { [key: string]: any }): void\n\n\t/**\n\t * A reactive function that returns a {@link @tldraw/tlschema#TLInstancePresence} object.\n\t *\n\t * This function is called reactively whenever the store state changes and\n\t * determines what presence information to broadcast to other clients. The\n\t * result is synchronized across all connected clients for displaying cursors,\n\t * selections, and other collaborative indicators.\n\t *\n\t * If not provided, uses the default implementation which includes standard\n\t * cursor position and selection state. Custom implementations allow you to\n\t * add additional presence data like current tool, view state, or custom status.\n\t *\n\t * See {@link @tldraw/tlschema#getDefaultUserPresence} for\n\t * the default implementation of this function.\n\t *\n\t * @param store - The current TLStore\n\t * @param user - The current user information\n\t * @returns Presence state to broadcast to other clients, or null to hide presence\n\t *\n\t * @example\n\t * ```ts\n\t * getUserPresence: (store, user) => {\n\t *   return {\n\t *     userId: user.id,\n\t *     userName: user.name,\n\t *     cursor: { x: 100, y: 200 },\n\t *     currentTool: 'select',\n\t *     isActive: true\n\t *   }\n\t * }\n\t * ```\n\t */\n\tgetUserPresence?(store: TLStore, user: TLPresenceUserInfo): TLPresenceStateInfo | null\n}\n"],"names":["client"],"mappings":"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","debugId":null}},
    {"offset": {"line": 3099, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync/src/useSyncDemo.ts"],"sourcesContent":["import { useCallback, useMemo } from 'react'\nimport {\n\tAssetRecordType,\n\tEditor,\n\tMediaHelpers,\n\tSignal,\n\tTLAsset,\n\tTLAssetStore,\n\tTLPresenceStateInfo,\n\tTLPresenceUserInfo,\n\tTLStore,\n\tTLStoreSchemaOptions,\n\tclamp,\n\tdefaultBindingUtils,\n\tdefaultShapeUtils,\n\tgetHashForString,\n\tuniqueId,\n\tuseShallowObjectIdentity,\n} from 'tldraw'\nimport { RemoteTLStoreWithStatus, useSync } from './useSync'\n\n/** @public */\nexport interface UseSyncDemoOptions {\n\t/**\n\t * The room ID to sync with. Make sure the room ID is unique. The namespace is shared by\n\t * everyone using the demo server. Consider prefixing it with your company or project name.\n\t */\n\troomId: string\n\t/**\n\t * A signal that contains the user information needed for multiplayer features.\n\t * This should be synchronized with the `userPreferences` configuration for the main `<Tldraw />` component.\n\t * If not provided, a default implementation based on localStorage will be used.\n\t */\n\tuserInfo?: TLPresenceUserInfo | Signal<TLPresenceUserInfo>\n\n\t/** @internal */\n\thost?: string\n\n\t/**\n\t * {@inheritdoc UseSyncOptions.getUserPresence}\n\t * @public\n\t */\n\tgetUserPresence?(store: TLStore, user: TLPresenceUserInfo): TLPresenceStateInfo | null\n}\n\n/**\n * Safely accesses environment variables across different bundling environments.\n *\n * Depending on the environment this package is used in, process.env may not be available. This function\n * wraps `process.env` accesses in a try/catch to prevent runtime errors in environments where process\n * is not defined.\n *\n * The reason that this is just a try/catch and not a dynamic check e.g. `process &&\n * process.env[key]` is that many bundlers implement `process.env.WHATEVER` using compile-time\n * string replacement, rather than actually creating a runtime implementation of a `process` object.\n *\n * @param cb - Callback function that accesses an environment variable\n * @returns The environment variable value if available, otherwise undefined\n * @internal\n */\nfunction getEnv(cb: () => string | undefined): string | undefined {\n\ttry {\n\t\treturn cb()\n\t} catch {\n\t\treturn undefined\n\t}\n}\n\nconst DEMO_WORKER = getEnv(() => process.env.TLDRAW_BEMO_URL) ?? 'https://demo.tldraw.xyz'\nconst IMAGE_WORKER = getEnv(() => process.env.TLDRAW_IMAGE_URL) ?? 'https://images.tldraw.xyz'\n\n/**\n * Creates a tldraw store synced with a multiplayer room hosted on tldraw's demo server `https://demo.tldraw.xyz`.\n *\n * The store can be passed directly into the `<Tldraw />` component to enable multiplayer features.\n * It will handle loading states, and enable multiplayer UX like user cursors and following.\n *\n * All data on the demo server is\n *\n * - Deleted after a day or so.\n * - Publicly accessible to anyone who knows the room ID. Use your company name as a prefix to help avoid collisions, or generate UUIDs for maximum privacy.\n *\n * @example\n * ```tsx\n * function MyApp() {\n *     const store = useSyncDemo({roomId: 'my-app-test-room'})\n *     return <Tldraw store={store} />\n * }\n * ```\n *\n * @param options - Options for the multiplayer demo sync store. See {@link UseSyncDemoOptions} and {@link tldraw#TLStoreSchemaOptions}.\n *\n * @public\n */\nexport function useSyncDemo(\n\toptions: UseSyncDemoOptions & TLStoreSchemaOptions\n): RemoteTLStoreWithStatus {\n\tconst { roomId, host = DEMO_WORKER, ..._syncOpts } = options\n\tconst assets = useMemo(() => createDemoAssetStore(host), [host])\n\n\tconst syncOpts = useShallowObjectIdentity(_syncOpts)\n\tconst syncOptsWithDefaults = useMemo(() => {\n\t\tif ('schema' in syncOpts && syncOpts.schema) return syncOpts\n\n\t\treturn {\n\t\t\t...syncOpts,\n\t\t\tshapeUtils:\n\t\t\t\t'shapeUtils' in syncOpts\n\t\t\t\t\t? [...defaultShapeUtils, ...(syncOpts.shapeUtils ?? [])]\n\t\t\t\t\t: defaultShapeUtils,\n\t\t\tbindingUtils:\n\t\t\t\t'bindingUtils' in syncOpts\n\t\t\t\t\t? [...defaultBindingUtils, ...(syncOpts.bindingUtils ?? [])]\n\t\t\t\t\t: defaultBindingUtils,\n\t\t}\n\t}, [syncOpts])\n\n\treturn useSync({\n\t\turi: `${host}/connect/${encodeURIComponent(roomId)}`,\n\t\troomId,\n\t\tassets,\n\t\tonMount: useCallback(\n\t\t\t(editor: Editor) => {\n\t\t\t\teditor.registerExternalAssetHandler('url', async ({ url }) => {\n\t\t\t\t\treturn await createAssetFromUrlUsingDemoServer(host, url)\n\t\t\t\t})\n\t\t\t},\n\t\t\t[host]\n\t\t),\n\t\t...syncOptsWithDefaults,\n\t})\n}\n\n/**\n * Determines whether file uploads should be disabled for a given host.\n *\n * Uploads are disabled for production tldraw domains to prevent abuse of the demo server\n * infrastructure. This includes tldraw.com and tldraw.xyz domains and their subdomains.\n *\n * @param host - The host URL to check for upload restrictions\n * @returns True if uploads should be disabled, false otherwise\n * @internal\n */\nfunction shouldDisallowUploads(host: string) {\n\tconst disallowedHosts = ['tldraw.com', 'tldraw.xyz']\n\treturn disallowedHosts.some(\n\t\t(disallowedHost) => host === disallowedHost || host.endsWith(`.${disallowedHost}`)\n\t)\n}\n\n/**\n * Creates an asset store implementation optimized for the tldraw demo server.\n *\n * This asset store handles file uploads to the demo server and provides intelligent\n * asset resolution with automatic image optimization based on network conditions,\n * screen density, and display size. It includes safeguards to prevent uploads to\n * production domains and optimizes images through the tldraw image processing service.\n *\n * @param host - The demo server host URL for file uploads and asset resolution\n * @returns A TLAssetStore implementation with upload and resolve capabilities\n * @example\n * ```ts\n * const assetStore = createDemoAssetStore('https://demo.tldraw.xyz')\n *\n * // Upload a file\n * const result = await assetStore.upload(asset, file)\n * console.log('Uploaded to:', result.src)\n *\n * // Resolve optimized asset URL\n * const optimizedUrl = assetStore.resolve(imageAsset, {\n *   steppedScreenScale: 1.5,\n *   dpr: 2,\n *   networkEffectiveType: '4g'\n * })\n * ```\n * @internal\n */\nfunction createDemoAssetStore(host: string): TLAssetStore {\n\treturn {\n\t\tupload: async (_asset, file) => {\n\t\t\tif (shouldDisallowUploads(host)) {\n\t\t\t\talert('Uploading images is disabled in this demo.')\n\t\t\t\tthrow new Error('Uploading images is disabled in this demo.')\n\t\t\t}\n\t\t\tconst id = uniqueId()\n\n\t\t\tconst objectName = `${id}-${file.name}`.replace(/\\W/g, '-')\n\t\t\tconst url = `${host}/uploads/${objectName}`\n\n\t\t\tawait fetch(url, {\n\t\t\t\tmethod: 'POST',\n\t\t\t\tbody: file,\n\t\t\t})\n\n\t\t\treturn { src: url }\n\t\t},\n\n\t\tresolve(asset, context) {\n\t\t\tif (!asset.props.src) return null\n\n\t\t\t// We don't deal with videos at the moment.\n\t\t\tif (asset.type === 'video') return asset.props.src\n\n\t\t\t// Assert it's an image to make TS happy.\n\t\t\tif (asset.type !== 'image') return null\n\n\t\t\t// Don't try to transform data: URLs, yikes.\n\t\t\tif (!asset.props.src.startsWith('http:') && !asset.props.src.startsWith('https:'))\n\t\t\t\treturn asset.props.src\n\n\t\t\tif (context.shouldResolveToOriginal) return asset.props.src\n\n\t\t\t// Don't try to transform animated images.\n\t\t\tif (MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || asset.props.isAnimated)\n\t\t\t\treturn asset.props.src\n\n\t\t\t// Don't try to transform vector images.\n\t\t\tif (MediaHelpers.isVectorImageType(asset?.props.mimeType)) return asset.props.src\n\n\t\t\tconst url = new URL(asset.props.src)\n\n\t\t\t// we only transform images that are hosted on domains we control\n\t\t\tconst isTldrawImage =\n\t\t\t\turl.origin === host || /\\.tldraw\\.(?:com|xyz|dev|workers\\.dev)$/.test(url.host)\n\n\t\t\tif (!isTldrawImage) return asset.props.src\n\n\t\t\t// Assets that are under a certain file size aren't worth transforming (and incurring cost).\n\t\t\t// We still send them through the image worker to get them optimized though.\n\t\t\tconst { fileSize = 0 } = asset.props\n\t\t\tconst isWorthResizing = fileSize >= 1024 * 1024 * 1.5\n\n\t\t\tif (isWorthResizing) {\n\t\t\t\t// N.B. navigator.connection is only available in certain browsers (mainly Blink-based browsers)\n\t\t\t\t// 4g is as high the 'effectiveType' goes and we can pick a lower effective image quality for slower connections.\n\t\t\t\tconst networkCompensation =\n\t\t\t\t\t!context.networkEffectiveType || context.networkEffectiveType === '4g' ? 1 : 0.5\n\n\t\t\t\tconst width = Math.ceil(\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\tasset.props.w *\n\t\t\t\t\t\t\tclamp(context.steppedScreenScale, 1 / 32, 1) *\n\t\t\t\t\t\t\tnetworkCompensation *\n\t\t\t\t\t\t\tcontext.dpr,\n\t\t\t\t\t\tasset.props.w\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\t\turl.searchParams.set('w', width.toString())\n\t\t\t}\n\n\t\t\tconst newUrl = `${IMAGE_WORKER}/${url.host}/${url.toString().slice(url.origin.length + 1)}`\n\t\t\treturn newUrl\n\t\t},\n\t}\n}\n\n/**\n * Creates a bookmark asset by fetching metadata from a URL using the demo server.\n *\n * This function uses the demo server's bookmark unfurling service to extract metadata\n * like title, description, favicon, and preview image from a given URL. If the metadata\n * fetch fails, it returns a blank bookmark asset with just the URL.\n *\n * @param host - The demo server host URL to use for bookmark unfurling\n * @param url - The URL to create a bookmark asset from\n * @returns A promise that resolves to a TLAsset of type 'bookmark' with extracted metadata\n * @example\n * ```ts\n * const asset = await createAssetFromUrlUsingDemoServer(\n *   'https://demo.tldraw.xyz',\n *   'https://example.com'\n * )\n *\n * console.log(asset.props.title) // \"Example Domain\"\n * console.log(asset.props.description) // \"This domain is for use in illustrative examples...\"\n * ```\n * @internal\n */\nasync function createAssetFromUrlUsingDemoServer(host: string, url: string): Promise<TLAsset> {\n\tconst urlHash = getHashForString(url)\n\ttry {\n\t\t// First, try to get the meta data from our endpoint\n\t\tconst fetchUrl = new URL(`${host}/bookmarks/unfurl`)\n\t\tfetchUrl.searchParams.set('url', url)\n\n\t\tconst meta = (await (await fetch(fetchUrl, { method: 'POST' })).json()) as {\n\t\t\tdescription?: string\n\t\t\timage?: string\n\t\t\tfavicon?: string\n\t\t\ttitle?: string\n\t\t} | null\n\n\t\treturn {\n\t\t\tid: AssetRecordType.createId(urlHash),\n\t\t\ttypeName: 'asset',\n\t\t\ttype: 'bookmark',\n\t\t\tprops: {\n\t\t\t\tsrc: url,\n\t\t\t\tdescription: meta?.description ?? '',\n\t\t\t\timage: meta?.image ?? '',\n\t\t\t\tfavicon: meta?.favicon ?? '',\n\t\t\t\ttitle: meta?.title ?? '',\n\t\t\t},\n\t\t\tmeta: {},\n\t\t}\n\t} catch (error) {\n\t\t// Otherwise, fallback to a blank bookmark\n\t\tconsole.error(error)\n\t\treturn {\n\t\t\tid: AssetRecordType.createId(urlHash),\n\t\t\ttypeName: 'asset',\n\t\t\ttype: 'bookmark',\n\t\t\tprops: {\n\t\t\t\tsrc: url,\n\t\t\t\tdescription: '',\n\t\t\t\timage: '',\n\t\t\t\tfavicon: '',\n\t\t\t\ttitle: '',\n\t\t\t},\n\t\t\tmeta: {},\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3260, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\n// eslint-disable-next-line local/no-export-star\nexport * from '@tldraw/sync-core'\n\nexport { useSync, type RemoteTLStoreWithStatus, type UseSyncOptions } from './useSync'\nexport { useSyncDemo, type UseSyncDemoOptions } from './useSyncDemo'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAE7C,cAAc;AAEd,SAAS,eAAkE;AAC3E,SAAS,mBAA4C;;;;;IAErD,sMAAA,EACE,gBACA,SACA","debugId":null}}]
}