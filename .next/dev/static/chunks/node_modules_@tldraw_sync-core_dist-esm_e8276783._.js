(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/chunk.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "JsonChunkAssembler",
    ()=>JsonChunkAssembler,
    "chunk",
    ()=>chunk
]);
const MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES = 1024 * 1024;
const MAX_BYTES_PER_CHAR = 4;
const MAX_SAFE_MESSAGE_SIZE = MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES / MAX_BYTES_PER_CHAR;
function chunk(msg, maxSafeMessageSize = MAX_SAFE_MESSAGE_SIZE) {
    if (msg.length < maxSafeMessageSize) {
        return [
            msg
        ];
    } else {
        const chunks = [];
        let chunkNumber = 0;
        let offset = msg.length;
        while(offset > 0){
            const prefix = `${chunkNumber}_`;
            const chunkSize = Math.max(Math.min(maxSafeMessageSize - prefix.length, offset), 1);
            chunks.unshift(prefix + msg.slice(offset - chunkSize, offset));
            offset -= chunkSize;
            chunkNumber++;
        }
        return chunks;
    }
}
const chunkRe = /^(\d+)_(.*)$/;
class JsonChunkAssembler {
    /**
   * Current assembly state - either 'idle' or tracking chunks being received
   */ state = "idle";
    /**
   * Processes a single message, which can be either a complete JSON object or a chunk.
   * For complete JSON objects (starting with '{'), parses immediately.
   * For chunks (prefixed with "{number}_"), accumulates until all chunks received.
   *
   * @param msg - The message to process, either JSON or chunk format
   * @returns Result object with data/stringified on success, error object on failure, or null for incomplete chunks
   * 	- `{ data: object, stringified: string }` - Successfully parsed complete message
   * 	- `{ error: Error }` - Parse error or invalid chunk sequence
   * 	- `null` - Chunk received but more chunks expected
   *
   * @example
   * ```ts
   * const assembler = new JsonChunkAssembler()
   *
   * // Complete JSON message
   * const result = assembler.handleMessage('{"key": "value"}')
   * if (result && 'data' in result) {
   *   console.log(result.data) // { key: "value" }
   * }
   *
   * // Chunked message sequence
   * assembler.handleMessage('2_hel') // null - more chunks expected
   * assembler.handleMessage('1_lo ') // null - more chunks expected
   * assembler.handleMessage('0_wor') // { data: "hello wor", stringified: "hello wor" }
   * ```
   */ handleMessage(msg) {
        if (msg.startsWith("{")) {
            const error = this.state === "idle" ? void 0 : new Error("Unexpected non-chunk message");
            this.state = "idle";
            return error ? {
                error
            } : {
                data: JSON.parse(msg),
                stringified: msg
            };
        } else {
            const match = chunkRe.exec(msg);
            if (!match) {
                this.state = "idle";
                return {
                    error: new Error("Invalid chunk: " + JSON.stringify(msg.slice(0, 20) + "..."))
                };
            }
            const numChunksRemaining = Number(match[1]);
            const data = match[2];
            if (this.state === "idle") {
                this.state = {
                    chunksReceived: [
                        data
                    ],
                    totalChunks: numChunksRemaining + 1
                };
            } else {
                this.state.chunksReceived.push(data);
                if (numChunksRemaining !== this.state.totalChunks - this.state.chunksReceived.length) {
                    this.state = "idle";
                    return {
                        error: new Error(`Chunks received in wrong order`)
                    };
                }
            }
            if (this.state.chunksReceived.length === this.state.totalChunks) {
                try {
                    const stringified = this.state.chunksReceived.join("");
                    const data2 = JSON.parse(stringified);
                    return {
                        data: data2,
                        stringified
                    };
                } catch (e) {
                    return {
                        error: e
                    };
                } finally{
                    this.state = "idle";
                }
            }
            return null;
        }
    }
}
;
 //# sourceMappingURL=chunk.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/diff.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RecordOpType",
    ()=>RecordOpType,
    "ValueOpType",
    ()=>ValueOpType,
    "applyObjectDiff",
    ()=>applyObjectDiff,
    "diffRecord",
    ()=>diffRecord,
    "getNetworkDiff",
    ()=>getNetworkDiff
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash.isequal/index.js [app-client] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-client] (ecmascript)");
;
const RecordOpType = {
    Put: "put",
    Patch: "patch",
    Remove: "remove"
};
function getNetworkDiff(diff) {
    let res = null;
    for (const [k, v] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntries"])(diff.added)){
        if (!res) res = {};
        res[k] = [
            RecordOpType.Put,
            v
        ];
    }
    for (const [from, to] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapValues"])(diff.updated)){
        const diff2 = diffRecord(from, to);
        if (diff2) {
            if (!res) res = {};
            res[to.id] = [
                RecordOpType.Patch,
                diff2
            ];
        }
    }
    for (const removed of Object.keys(diff.removed)){
        if (!res) res = {};
        res[removed] = [
            RecordOpType.Remove
        ];
    }
    return res;
}
const ValueOpType = {
    Put: "put",
    Delete: "delete",
    Append: "append",
    Patch: "patch"
};
function diffRecord(prev, next) {
    return diffObject(prev, next, /* @__PURE__ */ new Set([
        "props"
    ]));
}
function diffObject(prev, next, nestedKeys) {
    if (prev === next) {
        return null;
    }
    let result = null;
    for (const key of Object.keys(prev)){
        if (!(key in next)) {
            if (!result) result = {};
            result[key] = [
                ValueOpType.Delete
            ];
            continue;
        }
        const prevVal = prev[key];
        const nextVal = next[key];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(prevVal, nextVal)) {
            if (nestedKeys?.has(key) && prevVal && nextVal) {
                const diff = diffObject(prevVal, nextVal);
                if (diff) {
                    if (!result) result = {};
                    result[key] = [
                        ValueOpType.Patch,
                        diff
                    ];
                }
            } else if (Array.isArray(nextVal) && Array.isArray(prevVal)) {
                const op = diffArray(prevVal, nextVal);
                if (op) {
                    if (!result) result = {};
                    result[key] = op;
                }
            } else {
                if (!result) result = {};
                result[key] = [
                    ValueOpType.Put,
                    nextVal
                ];
            }
        }
    }
    for (const key of Object.keys(next)){
        if (!(key in prev)) {
            if (!result) result = {};
            result[key] = [
                ValueOpType.Put,
                next[key]
            ];
        }
    }
    return result;
}
function diffValue(valueA, valueB) {
    if (Object.is(valueA, valueB)) return null;
    if (Array.isArray(valueA) && Array.isArray(valueB)) {
        return diffArray(valueA, valueB);
    } else if (!valueA || !valueB || typeof valueA !== "object" || typeof valueB !== "object") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(valueA, valueB) ? null : [
            ValueOpType.Put,
            valueB
        ];
    } else {
        const diff = diffObject(valueA, valueB);
        return diff ? [
            ValueOpType.Patch,
            diff
        ] : null;
    }
}
function diffArray(prevArray, nextArray) {
    if (Object.is(prevArray, nextArray)) return null;
    if (prevArray.length === nextArray.length) {
        const maxPatchIndexes = Math.max(prevArray.length / 5, 1);
        const toPatchIndexes = [];
        for(let i = 0; i < prevArray.length; i++){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(prevArray[i], nextArray[i])) {
                toPatchIndexes.push(i);
                if (toPatchIndexes.length > maxPatchIndexes) {
                    return [
                        ValueOpType.Put,
                        nextArray
                    ];
                }
            }
        }
        if (toPatchIndexes.length === 0) {
            return null;
        }
        const diff = {};
        for (const i of toPatchIndexes){
            const prevItem = prevArray[i];
            const nextItem = nextArray[i];
            if (!prevItem || !nextItem) {
                diff[i] = [
                    ValueOpType.Put,
                    nextItem
                ];
            } else if (typeof prevItem === "object" && typeof nextItem === "object") {
                const op = diffValue(prevItem, nextItem);
                if (op) {
                    diff[i] = op;
                }
            } else {
                diff[i] = [
                    ValueOpType.Put,
                    nextItem
                ];
            }
        }
        return [
            ValueOpType.Patch,
            diff
        ];
    }
    for(let i = 0; i < prevArray.length; i++){
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(prevArray[i], nextArray[i])) {
            return [
                ValueOpType.Put,
                nextArray
            ];
        }
    }
    return [
        ValueOpType.Append,
        nextArray.slice(prevArray.length),
        prevArray.length
    ];
}
function applyObjectDiff(object, objectDiff) {
    if (!object || typeof object !== "object") return object;
    const isArray = Array.isArray(object);
    let newObject = void 0;
    const set = (k, v)=>{
        if (!newObject) {
            if (isArray) {
                newObject = [
                    ...object
                ];
            } else {
                newObject = {
                    ...object
                };
            }
        }
        if (isArray) {
            newObject[Number(k)] = v;
        } else {
            newObject[k] = v;
        }
    };
    for (const [key, op] of Object.entries(objectDiff)){
        switch(op[0]){
            case ValueOpType.Put:
                {
                    const value = op[1];
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(object[key], value)) {
                        set(key, value);
                    }
                    break;
                }
            case ValueOpType.Append:
                {
                    const values = op[1];
                    const offset = op[2];
                    const arr = object[key];
                    if (Array.isArray(arr) && arr.length === offset) {
                        set(key, [
                            ...arr,
                            ...values
                        ]);
                    }
                    break;
                }
            case ValueOpType.Patch:
                {
                    if (object[key] && typeof object[key] === "object") {
                        const diff = op[1];
                        const patched = applyObjectDiff(object[key], diff);
                        if (patched !== object[key]) {
                            set(key, patched);
                        }
                    }
                    break;
                }
            case ValueOpType.Delete:
                {
                    if (key in object) {
                        if (!newObject) {
                            if (isArray) {
                                console.error("Can't delete array item yet (this should never happen)");
                                newObject = [
                                    ...object
                                ];
                            } else {
                                newObject = {
                                    ...object
                                };
                            }
                        }
                        delete newObject[key];
                    }
                }
        }
    }
    return newObject ?? object;
}
;
 //# sourceMappingURL=diff.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/interval.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "interval",
    ()=>interval
]);
function interval(cb, timeout) {
    const i = setInterval(cb, timeout);
    return ()=>clearInterval(i);
}
;
 //# sourceMappingURL=interval.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/protocol.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TLIncompatibilityReason",
    ()=>TLIncompatibilityReason,
    "getTlsyncProtocolVersion",
    ()=>getTlsyncProtocolVersion
]);
const TLSYNC_PROTOCOL_VERSION = 7;
function getTlsyncProtocolVersion() {
    return TLSYNC_PROTOCOL_VERSION;
}
const TLIncompatibilityReason = {
    ClientTooOld: "clientTooOld",
    ServerTooOld: "serverTooOld",
    InvalidRecord: "invalidRecord",
    InvalidOperation: "invalidOperation"
};
;
 //# sourceMappingURL=protocol.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TLSyncClient",
    ()=>TLSyncClient,
    "TLSyncErrorCloseEventCode",
    ()=>TLSyncErrorCloseEventCode,
    "TLSyncErrorCloseEventReason",
    ()=>TLSyncErrorCloseEventReason
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$EffectScheduler$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/EffectScheduler.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/transactions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$throttle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/throttle.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash.isequal/index.js [app-client] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/id.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/diff.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$interval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/interval.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/protocol.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const TLSyncErrorCloseEventCode = 4099;
const TLSyncErrorCloseEventReason = {
    /** Room or resource not found */ NOT_FOUND: "NOT_FOUND",
    /** User lacks permission to access the room */ FORBIDDEN: "FORBIDDEN",
    /** User authentication required or invalid */ NOT_AUTHENTICATED: "NOT_AUTHENTICATED",
    /** Unexpected server error occurred */ UNKNOWN_ERROR: "UNKNOWN_ERROR",
    /** Client protocol version too old */ CLIENT_TOO_OLD: "CLIENT_TOO_OLD",
    /** Server protocol version too old */ SERVER_TOO_OLD: "SERVER_TOO_OLD",
    /** Client sent invalid or corrupted record data */ INVALID_RECORD: "INVALID_RECORD",
    /** Client exceeded rate limits */ RATE_LIMITED: "RATE_LIMITED",
    /** Room has reached maximum capacity */ ROOM_FULL: "ROOM_FULL"
};
const PING_INTERVAL = 5e3;
const MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION = PING_INTERVAL * 2;
class TLSyncClient {
    /** The last clock time from the most recent server update */ lastServerClock = -1;
    lastServerInteractionTimestamp = Date.now();
    /** The queue of in-flight push requests that have not yet been acknowledged by the server */ pendingPushRequests = [];
    /**
   * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we
   * take this diff, reverse it, and apply that to the store, our store will match exactly the most
   * recent state of the server that we know about
   */ speculativeChanges = {
        added: {},
        updated: {},
        removed: {}
    };
    disposables = [];
    store;
    socket;
    presenceState;
    presenceMode;
    // isOnline is true when we have an open socket connection and we have
    // established a connection with the server room (i.e. we have received a 'connect' message)
    isConnectedToRoom = false;
    /**
   * The client clock is essentially a counter for push requests Each time a push request is created
   * the clock is incremented. This clock is sent with the push request to the server, and the
   * server returns it with the response so that we can match up the response with the request.
   *
   * The clock may also be used at one point in the future to allow the client to re-send push
   * requests idempotently (i.e. the server will keep track of each client's clock and not execute
   * requests it has already handled), but at the time of writing this is neither needed nor
   * implemented.
   */ clientClock = 0;
    /**
   * Callback executed immediately after successful connection to sync room.
   * Use this to perform any post-connection setup required for your application,
   * such as initializing default content or updating UI state.
   *
   * @param self - The TLSyncClient instance that connected
   * @param details - Connection details
   *   - isReadonly - Whether the connection is in read-only mode
   */ onAfterConnect;
    onCustomMessageReceived;
    isDebugging = false;
    debug(...args) {
        if (this.isDebugging) {
            console.debug(...args);
        }
    }
    presenceType;
    didCancel;
    /**
   * Creates a new TLSyncClient instance to manage synchronization with a remote server.
   *
   * @param config - Configuration object for the sync client
   *   - store - The local tldraw store to synchronize
   *   - socket - WebSocket adapter for server communication
   *   - presence - Reactive signal containing current user's presence data
   *   - presenceMode - Optional signal controlling presence sharing (defaults to 'full')
   *   - onLoad - Callback fired when initial sync completes successfully
   *   - onSyncError - Callback fired when sync fails with error reason
   *   - onCustomMessageReceived - Optional handler for custom messages
   *   - onAfterConnect - Optional callback fired after successful connection
   *   - self - The TLSyncClient instance
   *   - details - Connection details including readonly status
   *   - didCancel - Optional function to check if sync should be cancelled
   */ constructor(config){
        this.didCancel = config.didCancel;
        this.presenceType = config.store.scopedTypes.presence.values().next().value ?? null;
        if (typeof window !== "undefined") {
            ;
            window.tlsync = this;
        }
        this.store = config.store;
        this.socket = config.socket;
        this.onAfterConnect = config.onAfterConnect;
        this.onCustomMessageReceived = config.onCustomMessageReceived;
        let didLoad = false;
        this.presenceState = config.presence;
        this.presenceMode = config.presenceMode;
        this.disposables.push(// when local 'user' changes are made, send them to the server
        // or stash them locally in offline mode
        this.store.listen(({ changes })=>{
            if (this.didCancel?.()) return this.close();
            this.debug("received store changes", {
                changes
            });
            this.push(changes);
        }, {
            source: "user",
            scope: "document"
        }), // when the server sends us events, handle them
        this.socket.onReceiveMessage((msg)=>{
            if (this.didCancel?.()) return this.close();
            this.debug("received message from server", msg);
            this.handleServerEvent(msg);
            if (!didLoad) {
                didLoad = true;
                config.onLoad(this);
            }
        }), // handle switching between online and offline
        this.socket.onStatusChange((ev)=>{
            if (this.didCancel?.()) return this.close();
            this.debug("socket status changed", ev.status);
            if (ev.status === "online") {
                this.sendConnectMessage();
            } else {
                this.resetConnection();
                if (ev.status === "error") {
                    didLoad = true;
                    config.onSyncError(ev.reason);
                    this.close();
                }
            }
        }), // Send a ping every PING_INTERVAL ms while online
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$interval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["interval"])(()=>{
            if (this.didCancel?.()) return this.close();
            this.debug("ping loop", {
                isConnectedToRoom: this.isConnectedToRoom
            });
            if (!this.isConnectedToRoom) return;
            try {
                this.socket.sendMessage({
                    type: "ping"
                });
            } catch (error) {
                console.warn("ping failed, resetting", error);
                this.resetConnection();
            }
        }, PING_INTERVAL), // Check the server connection health, reset the connection if needed
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$interval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["interval"])(()=>{
            if (this.didCancel?.()) return this.close();
            this.debug("health check loop", {
                isConnectedToRoom: this.isConnectedToRoom
            });
            if (!this.isConnectedToRoom) return;
            const timeSinceLastServerInteraction = Date.now() - this.lastServerInteractionTimestamp;
            if (timeSinceLastServerInteraction < MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION) {
                this.debug("health check passed", {
                    timeSinceLastServerInteraction
                });
                return;
            }
            console.warn(`Haven't heard from the server in a while, resetting connection...`);
            this.resetConnection();
        }, PING_INTERVAL * 2));
        if (this.presenceState) {
            this.disposables.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$EffectScheduler$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["react"])("pushPresence", ()=>{
                if (this.didCancel?.()) return this.close();
                const mode = this.presenceMode?.get();
                if (mode !== "full") return;
                this.pushPresence(this.presenceState.get());
            }));
        }
        if (this.socket.connectionStatus === "online") {
            this.sendConnectMessage();
        }
    }
    latestConnectRequestId = null;
    /**
   * This is the first message that is sent over a newly established socket connection. And we need
   * to wait for the response before this client can be used.
   */ sendConnectMessage() {
        if (this.isConnectedToRoom) {
            console.error("sendConnectMessage called while already connected");
            return;
        }
        this.debug("sending connect message");
        this.latestConnectRequestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uniqueId"])();
        this.socket.sendMessage({
            type: "connect",
            connectRequestId: this.latestConnectRequestId,
            schema: this.store.schema.serialize(),
            protocolVersion: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTlsyncProtocolVersion"])(),
            lastServerClock: this.lastServerClock
        });
    }
    /** Switch to offline mode */ resetConnection(hard = false) {
        this.debug("resetting connection");
        if (hard) {
            this.lastServerClock = 0;
        }
        const keys = Object.keys(this.store.serialize("presence"));
        if (keys.length > 0) {
            this.store.mergeRemoteChanges(()=>{
                this.store.remove(keys);
            });
        }
        this.lastPushedPresenceState = null;
        this.isConnectedToRoom = false;
        this.pendingPushRequests = [];
        this.incomingDiffBuffer = [];
        if (this.socket.connectionStatus === "online") {
            this.socket.restart();
        }
    }
    /**
   * Invoked when the socket connection comes online, either for the first time or as the result of
   * a reconnect. The goal is to rebase on the server's state and fire off a new push request for
   * any local changes that were made while offline.
   */ didReconnect(event) {
        this.debug("did reconnect", event);
        if (event.connectRequestId !== this.latestConnectRequestId) {
            return;
        }
        this.latestConnectRequestId = null;
        if (this.isConnectedToRoom) {
            console.error("didReconnect called while already connected");
            this.resetConnection(true);
            return;
        }
        if (this.pendingPushRequests.length > 0) {
            console.error("pendingPushRequests should already be empty when we reconnect");
            this.resetConnection(true);
            return;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transact"])(()=>{
            const stashedChanges = this.speculativeChanges;
            this.speculativeChanges = {
                added: {},
                updated: {},
                removed: {}
            };
            this.store.mergeRemoteChanges(()=>{
                const wipeDiff = {};
                const wipeAll = event.hydrationType === "wipe_all";
                if (!wipeAll) {
                    this.store.applyDiff((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reverseRecordsDiff"])(stashedChanges), {
                        runCallbacks: false
                    });
                }
                for (const [id, record] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntries"])(this.store.serialize("all"))){
                    if (wipeAll && this.store.scopedTypes.document.has(record.typeName) || record.typeName === this.presenceType) {
                        wipeDiff[id] = [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove
                        ];
                    }
                }
                this.applyNetworkDiff({
                    ...wipeDiff,
                    ...event.diff
                }, true);
                this.isConnectedToRoom = true;
                const speculativeChanges = this.store.filterChangesByScope(this.store.extractingChanges(()=>{
                    this.store.applyDiff(stashedChanges);
                }), "document");
                if (speculativeChanges) this.push(speculativeChanges);
            });
            this.onAfterConnect?.(this, {
                isReadonly: event.isReadonly
            });
            const presence = this.presenceState?.get();
            if (presence) {
                this.pushPresence(presence);
            }
        });
        this.lastServerClock = event.serverClock;
    }
    incomingDiffBuffer = [];
    /** Handle events received from the server */ handleServerEvent(event) {
        this.debug("received server event", event);
        this.lastServerInteractionTimestamp = Date.now();
        switch(event.type){
            case "connect":
                this.didReconnect(event);
                break;
            // legacy v4 events
            case "patch":
            case "push_result":
                if (!this.isConnectedToRoom) break;
                this.incomingDiffBuffer.push(event);
                this.scheduleRebase();
                break;
            case "data":
                if (!this.isConnectedToRoom) break;
                this.incomingDiffBuffer.push(...event.data);
                this.scheduleRebase();
                break;
            case "incompatibility_error":
                console.error("incompatibility error is legacy and should no longer be sent by the server");
                break;
            case "pong":
                break;
            case "custom":
                this.onCustomMessageReceived?.call(null, event.data);
                break;
            default:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exhaustiveSwitchError"])(event);
        }
    }
    /**
   * Closes the sync client and cleans up all resources.
   *
   * Call this method when you no longer need the sync client to prevent
   * memory leaks and close the WebSocket connection. After calling close(),
   * the client cannot be reused.
   *
   * @example
   * ```ts
   * // Clean shutdown
   * syncClient.close()
   * ```
   */ close() {
        this.debug("closing");
        this.disposables.forEach((dispose)=>dispose());
        this.flushPendingPushRequests.cancel?.();
        this.scheduleRebase.cancel?.();
    }
    lastPushedPresenceState = null;
    pushPresence(nextPresence) {
        this.store._flushHistory();
        if (!this.isConnectedToRoom) {
            return;
        }
        let presence = void 0;
        if (!this.lastPushedPresenceState && nextPresence) {
            presence = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                nextPresence
            ];
        } else if (this.lastPushedPresenceState && nextPresence) {
            const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffRecord"])(this.lastPushedPresenceState, nextPresence);
            if (diff) {
                presence = [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch,
                    diff
                ];
            }
        }
        if (!presence) return;
        this.lastPushedPresenceState = nextPresence;
        const lastPush = this.pendingPushRequests.at(-1);
        if (lastPush && !lastPush.sent && !lastPush.request.presence) {
            lastPush.request.presence = presence;
            return;
        }
        const req = {
            type: "push",
            clientClock: this.clientClock++,
            presence
        };
        if ("TURBOPACK compile-time truthy", 1) {
            this.pendingPushRequests.push({
                request: req,
                sent: false
            });
            this.flushPendingPushRequests();
        }
    }
    /** Push a change to the server, or stash it locally if we're offline */ push(change) {
        this.debug("push", change);
        const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNetworkDiff"])(change);
        if (!diff) return;
        this.speculativeChanges = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["squashRecordDiffs"])([
            this.speculativeChanges,
            change
        ]);
        if (!this.isConnectedToRoom) {
            return;
        }
        const pushRequest = {
            type: "push",
            diff,
            clientClock: this.clientClock++
        };
        this.pendingPushRequests.push({
            request: pushRequest,
            sent: false
        });
        this.flushPendingPushRequests();
    }
    /** Send any unsent push requests to the server */ flushPendingPushRequests = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$throttle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fpsThrottle"])(()=>{
        this.debug("flushing pending push requests", {
            isConnectedToRoom: this.isConnectedToRoom,
            pendingPushRequests: this.pendingPushRequests
        });
        if (!this.isConnectedToRoom || this.store.isPossiblyCorrupted()) {
            return;
        }
        for (const pendingPushRequest of this.pendingPushRequests){
            if (!pendingPushRequest.sent) {
                if (this.socket.connectionStatus !== "online") {
                    return;
                }
                this.socket.sendMessage(pendingPushRequest.request);
                pendingPushRequest.sent = true;
            }
        }
    });
    /**
   * Applies a 'network' diff to the store this does value-based equality checking so that if the
   * data is the same (as opposed to merely identical with ===), then no change is made and no
   * changes will be propagated back to store listeners
   */ applyNetworkDiff(diff, runCallbacks) {
        this.debug("applyNetworkDiff", diff);
        const changes = {
            added: {},
            updated: {},
            removed: {}
        };
        let hasChanges = false;
        for (const [id, op] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntries"])(diff)){
            if (op[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put) {
                const existing = this.store.get(id);
                if (existing && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(existing, op[1])) {
                    hasChanges = true;
                    changes.updated[id] = [
                        existing,
                        op[1]
                    ];
                } else {
                    hasChanges = true;
                    changes.added[id] = op[1];
                }
            } else if (op[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch) {
                const record = this.store.get(id);
                if (!record) {
                    continue;
                }
                const patched = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyObjectDiff"])(record, op[1]);
                hasChanges = true;
                changes.updated[id] = [
                    record,
                    patched
                ];
            } else if (op[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove) {
                if (this.store.has(id)) {
                    hasChanges = true;
                    changes.removed[id] = this.store.get(id);
                }
            }
        }
        if (hasChanges) {
            this.store.applyDiff(changes, {
                runCallbacks
            });
        }
    }
    // eslint-disable-next-line local/prefer-class-methods
    rebase = ()=>{
        this.store._flushHistory();
        if (this.incomingDiffBuffer.length === 0) return;
        const diffs = this.incomingDiffBuffer;
        this.incomingDiffBuffer = [];
        try {
            this.store.mergeRemoteChanges(()=>{
                this.store.applyDiff((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reverseRecordsDiff"])(this.speculativeChanges), {
                    runCallbacks: false
                });
                for (const diff of diffs){
                    if (diff.type === "patch") {
                        this.applyNetworkDiff(diff.diff, true);
                        continue;
                    }
                    if (this.pendingPushRequests.length === 0) {
                        throw new Error("Received push_result but there are no pending push requests");
                    }
                    if (this.pendingPushRequests[0].request.clientClock !== diff.clientClock) {
                        throw new Error("Received push_result for a push request that is not at the front of the queue");
                    }
                    if (diff.action === "discard") {
                        this.pendingPushRequests.shift();
                    } else if (diff.action === "commit") {
                        const { request } = this.pendingPushRequests.shift();
                        if ("diff" in request && request.diff) {
                            this.applyNetworkDiff(request.diff, true);
                        }
                    } else {
                        this.applyNetworkDiff(diff.action.rebaseWithDiff, true);
                        this.pendingPushRequests.shift();
                    }
                }
                try {
                    this.speculativeChanges = this.store.extractingChanges(()=>{
                        for (const { request } of this.pendingPushRequests){
                            if (!("diff" in request) || !request.diff) continue;
                            this.applyNetworkDiff(request.diff, true);
                        }
                    });
                } catch (e) {
                    console.error(e);
                    this.speculativeChanges = {
                        added: {},
                        updated: {},
                        removed: {}
                    };
                    this.resetConnection();
                }
            });
            this.lastServerClock = diffs.at(-1)?.serverClock ?? this.lastServerClock;
        } catch (e) {
            console.error(e);
            this.store.ensureStoreIsUsable();
            this.resetConnection();
        }
    };
    scheduleRebase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$throttle$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fpsThrottle"])(this.rebase);
}
;
 //# sourceMappingURL=TLSyncClient.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/ClientWebSocketAdapter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ACTIVE_MAX_DELAY",
    ()=>ACTIVE_MAX_DELAY,
    "ACTIVE_MIN_DELAY",
    ()=>ACTIVE_MIN_DELAY,
    "ATTEMPT_TIMEOUT",
    ()=>ATTEMPT_TIMEOUT,
    "ClientWebSocketAdapter",
    ()=>ClientWebSocketAdapter,
    "DELAY_EXPONENT",
    ()=>DELAY_EXPONENT,
    "INACTIVE_MAX_DELAY",
    ()=>INACTIVE_MAX_DELAY,
    "INACTIVE_MIN_DELAY",
    ()=>INACTIVE_MIN_DELAY,
    "ReconnectManager",
    ()=>ReconnectManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Atom.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/warn.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$chunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/chunk.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs [app-client] (ecmascript)");
;
;
;
;
function listenTo(target, event, handler) {
    target.addEventListener(event, handler);
    return ()=>{
        target.removeEventListener(event, handler);
    };
}
function debug(...args) {
    if (typeof window !== "undefined" && window.__tldraw_socket_debug) {
        const now = /* @__PURE__ */ new Date();
        console.log(`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`, ...args);
    }
}
class ClientWebSocketAdapter {
    _ws = null;
    isDisposed = false;
    /** @internal */ _reconnectManager;
    /**
   * Permanently closes the WebSocket adapter and disposes of all resources.
   * Once closed, the adapter cannot be reused and should be discarded.
   * This method is idempotent - calling it multiple times has no additional effect.
   */ // TODO: .close should be a project-wide interface with a common contract (.close()d thing
    //       can only be garbage collected, and can't be used anymore)
    close() {
        this.isDisposed = true;
        this._reconnectManager.close();
        this._ws?.close();
    }
    /**
   * Creates a new ClientWebSocketAdapter instance.
   *
   * @param getUri - Function that returns the WebSocket URI to connect to.
   *                 Can return a string directly or a Promise that resolves to a string.
   *                 This function is called each time a connection attempt is made,
   *                 allowing for dynamic URI generation (e.g., for authentication tokens).
   */ constructor(getUri){
        this._reconnectManager = new ReconnectManager(this, getUri);
    }
    _handleConnect() {
        debug("handleConnect");
        this._connectionStatus.set("online");
        this.statusListeners.forEach((cb)=>cb({
                status: "online"
            }));
        this._reconnectManager.connected();
    }
    _handleDisconnect(reason, closeCode, didOpen, closeReason) {
        closeReason = closeReason || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].UNKNOWN_ERROR;
        debug("handleDisconnect", {
            currentStatus: this.connectionStatus,
            closeCode,
            reason
        });
        let newStatus;
        switch(reason){
            case "closed":
                if (closeCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventCode"]) {
                    newStatus = "error";
                } else {
                    newStatus = "offline";
                }
                break;
            case "manual":
                newStatus = "offline";
                break;
        }
        if (closeCode === 1006 && !didOpen) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$warn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warnOnce"])("Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to.");
        }
        if (// it the status changed
        this.connectionStatus !== newStatus && // ignore errors if we're already in the offline state
        !(newStatus === "error" && this.connectionStatus === "offline")) {
            this._connectionStatus.set(newStatus);
            this.statusListeners.forEach((cb)=>cb(newStatus === "error" ? {
                    status: "error",
                    reason: closeReason
                } : {
                    status: newStatus
                }));
        }
        this._reconnectManager.disconnected();
    }
    _setNewSocket(ws) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this.isDisposed, "Tried to set a new websocket on a disposed socket");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this._ws === null || this._ws.readyState === WebSocket.CLOSED || this._ws.readyState === WebSocket.CLOSING, `Tried to set a new websocket in when the existing one was ${this._ws?.readyState}`);
        let didOpen = false;
        ws.onopen = ()=>{
            debug("ws.onopen");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this._ws === ws, "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open");
            didOpen = true;
            this._handleConnect();
        };
        ws.onclose = (event)=>{
            debug("ws.onclose", event);
            if (this._ws === ws) {
                this._handleDisconnect("closed", event.code, didOpen, event.reason);
            } else {
                debug("ignoring onclose for an orphaned socket");
            }
        };
        ws.onerror = (event)=>{
            debug("ws.onerror", event);
            if (this._ws === ws) {
                this._handleDisconnect("closed");
            } else {
                debug("ignoring onerror for an orphaned socket");
            }
        };
        ws.onmessage = (ev)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this._ws === ws, "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages");
            const parsed = JSON.parse(ev.data.toString());
            this.messageListeners.forEach((cb)=>cb(parsed));
        };
        this._ws = ws;
    }
    _closeSocket() {
        if (this._ws === null) return;
        this._ws.close();
        this._ws = null;
        this._handleDisconnect("manual");
    }
    // TLPersistentClientSocket stuff
    _connectionStatus = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["atom"])("websocket connection status", "initial");
    /**
   * Gets the current connection status of the WebSocket.
   *
   * @returns The current connection status: 'online', 'offline', or 'error'
   */ // eslint-disable-next-line no-restricted-syntax
    get connectionStatus() {
        const status = this._connectionStatus.get();
        return status === "initial" ? "offline" : status;
    }
    /**
   * Sends a message to the server through the WebSocket connection.
   * Messages are automatically chunked if they exceed size limits.
   *
   * @param msg - The message to send to the server
   *
   * @example
   * ```ts
   * adapter.sendMessage({
   *   type: 'push',
   *   diff: { 'shape:abc123': [2, { x: [1, 150] }] }
   * })
   * ```
   */ sendMessage(msg) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this.isDisposed, "Tried to send message on a disposed socket");
        if (!this._ws) return;
        if (this.connectionStatus === "online") {
            const chunks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$chunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["chunk"])(JSON.stringify(msg));
            for (const part of chunks){
                this._ws.send(part);
            }
        } else {
            console.warn("Tried to send message while " + this.connectionStatus);
        }
    }
    messageListeners = /* @__PURE__ */ new Set();
    /**
   * Registers a callback to handle incoming messages from the server.
   *
   * @param cb - Callback function that will be called with each received message
   * @returns A cleanup function to remove the message listener
   *
   * @example
   * ```ts
   * const unsubscribe = adapter.onReceiveMessage((message) => {
   *   switch (message.type) {
   *     case 'connect':
   *       console.log('Connected to room')
   *       break
   *     case 'data':
   *       console.log('Received data:', message.diff)
   *       break
   *   }
   * })
   *
   * // Later, remove the listener
   * unsubscribe()
   * ```
   */ onReceiveMessage(cb) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this.isDisposed, "Tried to add message listener on a disposed socket");
        this.messageListeners.add(cb);
        return ()=>{
            this.messageListeners.delete(cb);
        };
    }
    statusListeners = /* @__PURE__ */ new Set();
    /**
   * Registers a callback to handle connection status changes.
   *
   * @param cb - Callback function that will be called when the connection status changes
   * @returns A cleanup function to remove the status listener
   *
   * @example
   * ```ts
   * const unsubscribe = adapter.onStatusChange((status) => {
   *   if (status.status === 'error') {
   *     console.error('Connection error:', status.reason)
   *   } else {
   *     console.log('Status changed to:', status.status)
   *   }
   * })
   *
   * // Later, remove the listener
   * unsubscribe()
   * ```
   */ onStatusChange(cb) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this.isDisposed, "Tried to add status listener on a disposed socket");
        this.statusListeners.add(cb);
        return ()=>{
            this.statusListeners.delete(cb);
        };
    }
    /**
   * Manually restarts the WebSocket connection.
   * This closes the current connection (if any) and attempts to establish a new one.
   * Useful for implementing connection loss detection and recovery.
   *
   * @example
   * ```ts
   * // Restart connection after detecting it's stale
   * if (lastPongTime < Date.now() - 30000) {
   *   adapter.restart()
   * }
   * ```
   */ restart() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(!this.isDisposed, "Tried to restart a disposed socket");
        debug("restarting");
        this._closeSocket();
        this._reconnectManager.maybeReconnected();
    }
}
const ACTIVE_MIN_DELAY = 500;
const ACTIVE_MAX_DELAY = 2e3;
const INACTIVE_MIN_DELAY = 1e3;
const INACTIVE_MAX_DELAY = 1e3 * 60 * 5;
const DELAY_EXPONENT = 1.5;
const ATTEMPT_TIMEOUT = 1e3;
class ReconnectManager {
    /**
   * Creates a new ReconnectManager instance.
   *
   * socketAdapter - The ClientWebSocketAdapter instance to manage
   * getUri - Function that returns the WebSocket URI for connection attempts
   */ constructor(socketAdapter, getUri){
        this.socketAdapter = socketAdapter;
        this.getUri = getUri;
        this.subscribeToReconnectHints();
        this.disposables.push(listenTo(window, "offline", ()=>{
            debug("window went offline");
            this.socketAdapter._closeSocket();
        }));
        this.state = "pendingAttempt";
        this.intendedDelay = ACTIVE_MIN_DELAY;
        this.scheduleAttempt();
    }
    isDisposed = false;
    disposables = [
        ()=>{
            if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
            if (this.recheckConnectingTimeout) clearTimeout(this.recheckConnectingTimeout);
        }
    ];
    reconnectTimeout = null;
    recheckConnectingTimeout = null;
    lastAttemptStart = null;
    intendedDelay = ACTIVE_MIN_DELAY;
    state;
    subscribeToReconnectHints() {
        this.disposables.push(listenTo(window, "online", ()=>{
            debug("window went online");
            this.maybeReconnected();
        }), listenTo(document, "visibilitychange", ()=>{
            if (!document.hidden) {
                debug("document became visible");
                this.maybeReconnected();
            }
        }));
        if (Object.prototype.hasOwnProperty.call(navigator, "connection")) {
            const connection = navigator["connection"];
            this.disposables.push(listenTo(connection, "change", ()=>{
                debug("navigator.connection change");
                this.maybeReconnected();
            }));
        }
    }
    scheduleAttempt() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this.state === "pendingAttempt");
        debug("scheduling a connection attempt");
        Promise.resolve(this.getUri()).then((uri)=>{
            if (this.state !== "pendingAttempt" || this.isDisposed) return;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this.socketAdapter._ws?.readyState !== WebSocket.OPEN, "There should be no connection attempts while already connected");
            this.lastAttemptStart = Date.now();
            this.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)));
            this.state = "pendingAttemptResult";
        });
    }
    getMaxDelay() {
        return document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY;
    }
    getMinDelay() {
        return document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY;
    }
    clearReconnectTimeout() {
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
            this.reconnectTimeout = null;
        }
    }
    clearRecheckConnectingTimeout() {
        if (this.recheckConnectingTimeout) {
            clearTimeout(this.recheckConnectingTimeout);
            this.recheckConnectingTimeout = null;
        }
    }
    /**
   * Checks if reconnection should be attempted and initiates it if appropriate.
   * This method is called in response to network events, tab visibility changes,
   * and other hints that connectivity may have been restored.
   *
   * The method intelligently handles various connection states:
   * - Already connected: no action needed
   * - Currently connecting: waits or retries based on attempt age
   * - Disconnected: initiates immediate reconnection attempt
   *
   * @example
   * ```ts
   * // Called automatically on network/visibility events, but can be called manually
   * manager.maybeReconnected()
   * ```
   */ maybeReconnected() {
        debug("ReconnectManager.maybeReconnected");
        this.clearRecheckConnectingTimeout();
        if (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {
            debug("ReconnectManager.maybeReconnected: already connected");
            return;
        }
        if (this.socketAdapter._ws?.readyState === WebSocket.CONNECTING) {
            debug("ReconnectManager.maybeReconnected: connecting");
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(this.lastAttemptStart, "ReadyState=CONNECTING without lastAttemptStart should be impossible");
            const sinceLastStart = Date.now() - this.lastAttemptStart;
            if (sinceLastStart < ATTEMPT_TIMEOUT) {
                debug("ReconnectManager.maybeReconnected: connecting, rechecking later");
                this.recheckConnectingTimeout = setTimeout(()=>this.maybeReconnected(), ATTEMPT_TIMEOUT - sinceLastStart);
            } else {
                debug("ReconnectManager.maybeReconnected: connecting, but for too long, retry now");
                this.clearRecheckConnectingTimeout();
                this.socketAdapter._closeSocket();
            }
            return;
        }
        debug("ReconnectManager.maybeReconnected: closing/closed/null, retry now");
        this.intendedDelay = ACTIVE_MIN_DELAY;
        this.disconnected();
    }
    /**
   * Handles disconnection events and schedules reconnection attempts with exponential backoff.
   * This method is called when the WebSocket connection is lost or fails to establish.
   *
   * It implements intelligent delay calculation based on:
   * - Previous attempt timing
   * - Current tab visibility (active vs inactive delays)
   * - Exponential backoff for repeated failures
   *
   * @example
   * ```ts
   * // Called automatically when connection is lost
   * // Schedules reconnection with appropriate delay
   * manager.disconnected()
   * ```
   */ disconnected() {
        debug("ReconnectManager.disconnected");
        if (this.socketAdapter._ws?.readyState !== WebSocket.OPEN && this.socketAdapter._ws?.readyState !== WebSocket.CONNECTING) {
            debug("ReconnectManager.disconnected: websocket is not OPEN or CONNECTING");
            this.clearReconnectTimeout();
            let delayLeft;
            if (this.state === "connected") {
                this.intendedDelay = this.getMinDelay();
                delayLeft = this.intendedDelay;
            } else {
                delayLeft = this.lastAttemptStart !== null ? this.lastAttemptStart + this.intendedDelay - Date.now() : 0;
            }
            if (delayLeft > 0) {
                debug("ReconnectManager.disconnected: delaying, delayLeft", delayLeft);
                this.state = "delay";
                this.reconnectTimeout = setTimeout(()=>this.disconnected(), delayLeft);
            } else {
                this.state = "pendingAttempt";
                this.intendedDelay = Math.min(this.getMaxDelay(), Math.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT);
                debug("ReconnectManager.disconnected: attempting a connection, next delay", this.intendedDelay);
                this.scheduleAttempt();
            }
        }
    }
    /**
   * Handles successful connection events and resets reconnection state.
   * This method is called when the WebSocket successfully connects to the server.
   *
   * It clears any pending reconnection attempts and resets the delay back to minimum
   * for future connection attempts.
   *
   * @example
   * ```ts
   * // Called automatically when WebSocket opens successfully
   * manager.connected()
   * ```
   */ connected() {
        debug("ReconnectManager.connected");
        if (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {
            debug("ReconnectManager.connected: websocket is OPEN");
            this.state = "connected";
            this.clearReconnectTimeout();
            this.intendedDelay = ACTIVE_MIN_DELAY;
        }
    }
    /**
   * Permanently closes the reconnection manager and cleans up all resources.
   * This stops all pending reconnection attempts and removes event listeners.
   * Once closed, the manager cannot be reused.
   */ close() {
        this.disposables.forEach((d)=>d());
        this.isDisposed = true;
    }
}
function httpToWs(url) {
    return url.replace(/^http(s)?:/, "ws$1:");
}
;
 //# sourceMappingURL=ClientWebSocketAdapter.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/RoomSession.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RoomSessionState",
    ()=>RoomSessionState,
    "SESSION_IDLE_TIMEOUT",
    ()=>SESSION_IDLE_TIMEOUT,
    "SESSION_REMOVAL_WAIT_TIME",
    ()=>SESSION_REMOVAL_WAIT_TIME,
    "SESSION_START_WAIT_TIME",
    ()=>SESSION_START_WAIT_TIME
]);
const RoomSessionState = {
    /** Session is waiting for the initial connect message from the client */ AwaitingConnectMessage: "awaiting-connect-message",
    /** Session is disconnected but waiting for final cleanup before removal */ AwaitingRemoval: "awaiting-removal",
    /** Session is fully connected and actively synchronizing */ Connected: "connected"
};
const SESSION_START_WAIT_TIME = 1e4;
const SESSION_REMOVAL_WAIT_TIME = 5e3;
const SESSION_IDLE_TIMEOUT = 2e4;
;
 //# sourceMappingURL=RoomSession.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLRemoteSyncError.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TLRemoteSyncError",
    ()=>TLRemoteSyncError
]);
class TLRemoteSyncError extends Error {
    /**
   * Creates a new TLRemoteSyncError with the specified reason.
   *
   * reason - The specific reason code or custom string describing why the sync failed.
   *                 When using predefined reasons from TLSyncErrorCloseEventReason, the client
   *                 can handle specific error types appropriately. Custom strings allow for
   *                 application-specific error details.
   */ constructor(reason){
        super(`sync error: ${reason}`);
        this.reason = reason;
    }
    name = "RemoteSyncError";
}
;
 //# sourceMappingURL=TLRemoteSyncError.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/ServerSocketAdapter.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ServerSocketAdapter",
    ()=>ServerSocketAdapter
]);
class ServerSocketAdapter {
    /**
   * Creates a new ServerSocketAdapter instance.
   *
   * opts - Configuration options for the adapter
   */ constructor(opts){
        this.opts = opts;
    }
    /**
   * Checks if the underlying WebSocket connection is currently open and ready to send messages.
   *
   * @returns True if the connection is open (readyState === 1), false otherwise
   */ // eslint-disable-next-line no-restricted-syntax
    get isOpen() {
        return this.opts.ws.readyState === 1;
    }
    /**
   * Sends a sync protocol message to the connected client. The message is JSON stringified
   * before being sent through the WebSocket. If configured, the onBeforeSendMessage callback
   * is invoked before sending.
   *
   * @param msg - The sync protocol message to send
   */ // see TLRoomSocket for details on why this accepts a union and not just arrays
    sendMessage(msg) {
        const message = JSON.stringify(msg);
        this.opts.onBeforeSendMessage?.(msg, message);
        this.opts.ws.send(message);
    }
    /**
   * Closes the WebSocket connection with an optional close code and reason.
   *
   * @param code - Optional close code (default: 1000 for normal closure)
   * @param reason - Optional human-readable reason for closing
   */ close(code, reason) {
        this.opts.ws.close(code, reason);
    }
}
;
 //# sourceMappingURL=ServerSocketAdapter.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/findMin.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findMin",
    ()=>findMin
]);
function findMin(values) {
    let min = null;
    for (const value of values){
        if (min === null) {
            min = value;
        } else if (value < min) {
            min = value;
        }
    }
    return min;
}
;
 //# sourceMappingURL=findMin.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncRoom.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DATA_MESSAGE_DEBOUNCE_INTERVAL",
    ()=>DATA_MESSAGE_DEBOUNCE_INTERVAL,
    "DocumentState",
    ()=>DocumentState,
    "MAX_TOMBSTONES",
    ()=>MAX_TOMBSTONES,
    "TLSyncRoom",
    ()=>TLSyncRoom,
    "TOMBSTONE_PRUNE_BUFFER_SIZE",
    ()=>TOMBSTONE_PRUNE_BUFFER_SIZE
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/transactions.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/migrate.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/tlschema/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$records$2f$TLDocument$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/tlschema/dist-esm/records/TLDocument.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$records$2f$TLPage$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/tlschema/dist-esm/records/TLPage.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash.isequal/index.js [app-client] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/value.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoevents$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/nanoevents/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/RoomSession.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/diff.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$findMin$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/findMin.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$interval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/interval.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/protocol.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const MAX_TOMBSTONES = 3e3;
const TOMBSTONE_PRUNE_BUFFER_SIZE = 300;
const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1e3 / 60;
const timeSince = (time)=>Date.now() - time;
class DocumentState {
    constructor(state, lastChangedClock, recordType){
        this.state = state;
        this.lastChangedClock = lastChangedClock;
        this.recordType = recordType;
    }
    /**
   * Create a DocumentState instance without validating the record data.
   * Used for performance when validation has already been performed.
   *
   * @param state - The record data
   * @param lastChangedClock - Clock value when this record was last modified
   * @param recordType - The record type definition for validation
   * @returns A new DocumentState instance
   */ static createWithoutValidating(state, lastChangedClock, recordType) {
        return new DocumentState(state, lastChangedClock, recordType);
    }
    /**
   * Create a DocumentState instance with validation of the record data.
   *
   * @param state - The record data to validate
   * @param lastChangedClock - Clock value when this record was last modified
   * @param recordType - The record type definition for validation
   * @returns Result containing the DocumentState or validation error
   */ static createAndValidate(state, lastChangedClock, recordType) {
        try {
            recordType.validate(state);
        } catch (error) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].err(error);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(new DocumentState(state, lastChangedClock, recordType));
    }
    /**
   * Replace the current state with new state and calculate the diff.
   *
   * @param state - The new record state
   * @param clock - The new clock value
   * @returns Result containing the diff and new DocumentState, or null if no changes, or validation error
   */ replaceState(state, clock) {
        const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["diffRecord"])(this.state, state);
        if (!diff) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(null);
        try {
            this.recordType.validate(state);
        } catch (error) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].err(error);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok([
            diff,
            new DocumentState(state, clock, this.recordType)
        ]);
    }
    /**
   * Apply a diff to the current state and return the resulting changes.
   *
   * @param diff - The object diff to apply
   * @param clock - The new clock value
   * @returns Result containing the final diff and new DocumentState, or null if no changes, or validation error
   */ mergeDiff(diff, clock) {
        const newState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyObjectDiff"])(this.state, diff);
        return this.replaceState(newState, clock);
    }
}
function getDocumentClock(snapshot) {
    if (typeof snapshot.documentClock === "number") {
        return snapshot.documentClock;
    }
    let max = 0;
    for (const doc of snapshot.documents){
        max = Math.max(max, doc.lastChangedClock);
    }
    for (const tombstone of Object.values(snapshot.tombstones ?? {})){
        max = Math.max(max, tombstone);
    }
    return max;
}
class TLSyncRoom {
    // A table of connected clients
    sessions = /* @__PURE__ */ new Map();
    // eslint-disable-next-line local/prefer-class-methods
    pruneSessions = ()=>{
        for (const client of this.sessions.values()){
            switch(client.state){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected:
                    {
                        const hasTimedOut = timeSince(client.lastInteractionTime) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SESSION_IDLE_TIMEOUT"];
                        if (hasTimedOut || !client.socket.isOpen) {
                            this.cancelSession(client.sessionId);
                        }
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].AwaitingConnectMessage:
                    {
                        const hasTimedOut = timeSince(client.sessionStartTime) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SESSION_START_WAIT_TIME"];
                        if (hasTimedOut || !client.socket.isOpen) {
                            this.removeSession(client.sessionId);
                        }
                        break;
                    }
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].AwaitingRemoval:
                    {
                        const hasTimedOut = timeSince(client.cancellationTime) > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SESSION_REMOVAL_WAIT_TIME"];
                        if (hasTimedOut) {
                            this.removeSession(client.sessionId);
                        }
                        break;
                    }
                default:
                    {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exhaustiveSwitchError"])(client);
                    }
            }
        }
    };
    disposables = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$interval$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["interval"])(this.pruneSessions, 2e3)
    ];
    _isClosed = false;
    /**
   * Close the room and clean up all resources. Disconnects all sessions
   * and stops background processes.
   */ close() {
        this.disposables.forEach((d)=>d());
        this.sessions.forEach((session)=>{
            session.socket.close();
        });
        this._isClosed = true;
    }
    /**
   * Check if the room has been closed and is no longer accepting connections.
   *
   * @returns True if the room is closed
   */ isClosed() {
        return this._isClosed;
    }
    events = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanoevents$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNanoEvents"])();
    // Values associated with each uid (must be serializable).
    /** @internal */ documents;
    tombstones;
    // this clock should start higher than the client, to make sure that clients who sync with their
    // initial lastServerClock value get the full state
    // in this case clients will start with 0, and the server will start with 1
    clock;
    documentClock;
    tombstoneHistoryStartsAtClock;
    // map from record id to clock upon deletion
    serializedSchema;
    documentTypes;
    presenceType;
    log;
    schema;
    constructor(opts){
        this.schema = opts.schema;
        let snapshot = opts.snapshot;
        this.log = opts.log;
        this.onDataChange = opts.onDataChange;
        this.onPresenceChange = opts.onPresenceChange;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNativeStructuredClone"], "TLSyncRoom is supposed to run either on Cloudflare Workersor on a 18+ version of Node.js, which both support the native structuredClone API");
        this.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()));
        this.documentTypes = new Set(Object.values(this.schema.types).filter((t)=>t.scope === "document").map((t)=>t.typeName));
        const presenceTypes = new Set(Object.values(this.schema.types).filter((t)=>t.scope === "presence"));
        if (presenceTypes.size > 1) {
            throw new Error(`TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`);
        }
        this.presenceType = presenceTypes.values().next()?.value ?? null;
        if (!snapshot) {
            snapshot = {
                clock: 0,
                documentClock: 0,
                documents: [
                    {
                        state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$records$2f$TLDocument$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DocumentRecordType"].create({
                            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$records$2f$TLDocument$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLDOCUMENT_ID"]
                        }),
                        lastChangedClock: 0
                    },
                    {
                        state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$records$2f$TLPage$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PageRecordType"].create({
                            name: "Page 1",
                            index: "a1"
                        }),
                        lastChangedClock: 0
                    }
                ]
            };
        }
        this.clock = snapshot.clock;
        let didIncrementClock = false;
        const ensureClockDidIncrement = (_reason)=>{
            if (!didIncrementClock) {
                didIncrementClock = true;
                this.clock++;
            }
        };
        this.tombstones = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AtomMap"]("room tombstones", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntriesIterable"])(snapshot.tombstones ?? {}));
        this.documents = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AtomMap"]("room documents", (function*() {
            for (const doc of snapshot.documents){
                if (this.documentTypes.has(doc.state.typeName)) {
                    yield [
                        doc.state.id,
                        DocumentState.createWithoutValidating(doc.state, doc.lastChangedClock, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertExists"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOwnProperty"])(this.schema.types, doc.state.typeName)))
                    ];
                } else {
                    ensureClockDidIncrement("doc type was not doc type");
                    this.tombstones.set(doc.state.id, this.clock);
                }
            }
        }).call(this));
        this.tombstoneHistoryStartsAtClock = snapshot.tombstoneHistoryStartsAtClock ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$findMin$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findMin"])(this.tombstones.values()) ?? this.clock;
        if (this.tombstoneHistoryStartsAtClock === 0) {
            this.tombstoneHistoryStartsAtClock++;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transact"])(()=>{
            const schema = snapshot.schema ?? this.schema.serializeEarliestVersion();
            const migrationsToApply = this.schema.getMigrationsSince(schema);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(migrationsToApply.ok, "Failed to get migrations");
            if (migrationsToApply.value.length > 0) {
                const store = {};
                for (const [k, v] of this.documents.entries()){
                    store[k] = v.state;
                }
                const migrationResult = this.schema.migrateStoreSnapshot({
                    store,
                    schema
                }, {
                    mutateInputStore: true
                });
                if (migrationResult.type === "error") {
                    throw new Error("Failed to migrate: " + migrationResult.reason);
                }
                for(const id in migrationResult.value){
                    if (!Object.prototype.hasOwnProperty.call(migrationResult.value, id)) {
                        continue;
                    }
                    const r = migrationResult.value[id];
                    const existing = this.documents.get(id);
                    if (!existing || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(existing.state, r)) {
                        ensureClockDidIncrement("record was added or updated during migration");
                        this.documents.set(r.id, DocumentState.createWithoutValidating(r, this.clock, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertExists"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOwnProperty"])(this.schema.types, r.typeName))));
                    }
                }
                for (const id of this.documents.keys()){
                    if (!migrationResult.value[id]) {
                        ensureClockDidIncrement("record was removed during migration");
                        this.tombstones.set(id, this.clock);
                        this.documents.delete(id);
                    }
                }
            }
            this.pruneTombstones();
        });
        if (didIncrementClock) {
            this.documentClock = this.clock;
            opts.onDataChange?.();
        } else {
            this.documentClock = getDocumentClock(snapshot);
        }
    }
    didSchedulePrune = true;
    // eslint-disable-next-line local/prefer-class-methods
    pruneTombstones = ()=>{
        this.didSchedulePrune = false;
        if (this.tombstones.size > MAX_TOMBSTONES) {
            const entries = Array.from(this.tombstones.entries());
            entries.sort((a, b)=>a[1] - b[1]);
            let idx = entries.length - 1 - MAX_TOMBSTONES + TOMBSTONE_PRUNE_BUFFER_SIZE;
            const cullClock = entries[idx++][1];
            while(idx < entries.length && entries[idx][1] === cullClock){
                idx++;
            }
            const keysToDelete = entries.slice(0, idx).map(([key])=>key);
            this.tombstoneHistoryStartsAtClock = cullClock + 1;
            this.tombstones.deleteMany(keysToDelete);
        }
    };
    getDocument(id) {
        return this.documents.get(id);
    }
    addDocument(id, state, clock) {
        if (this.tombstones.has(id)) {
            this.tombstones.delete(id);
        }
        const createResult = DocumentState.createAndValidate(state, clock, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertExists"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOwnProperty"])(this.schema.types, state.typeName)));
        if (!createResult.ok) return createResult;
        this.documents.set(id, createResult.value);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(void 0);
    }
    removeDocument(id, clock) {
        this.documents.delete(id);
        this.tombstones.set(id, clock);
        if (!this.didSchedulePrune) {
            this.didSchedulePrune = true;
            setTimeout(this.pruneTombstones, 0);
        }
    }
    /**
   * Get a complete snapshot of the current room state that can be persisted
   * and later used to restore the room.
   *
   * @returns Room snapshot containing all documents, tombstones, and metadata
   * @example
   * ```ts
   * const snapshot = room.getSnapshot()
   * await database.saveRoomSnapshot(roomId, snapshot)
   *
   * // Later, restore from snapshot
   * const restoredRoom = new TLSyncRoom({
   *   schema: mySchema,
   *   snapshot: snapshot
   * })
   * ```
   */ getSnapshot() {
        const tombstones = Object.fromEntries(this.tombstones.entries());
        const documents = [];
        for (const doc of this.documents.values()){
            if (this.documentTypes.has(doc.state.typeName)) {
                documents.push({
                    state: doc.state,
                    lastChangedClock: doc.lastChangedClock
                });
            }
        }
        return {
            clock: this.clock,
            documentClock: this.documentClock,
            tombstones,
            tombstoneHistoryStartsAtClock: this.tombstoneHistoryStartsAtClock,
            schema: this.serializedSchema,
            documents
        };
    }
    /**
   * Send a message to a particular client. Debounces data events
   *
   * @param sessionId - The id of the session to send the message to.
   * @param message - The message to send.
   */ sendMessage(sessionId, message) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            this.log?.warn?.("Tried to send message to unknown session", message.type);
            return;
        }
        if (session.state !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected) {
            this.log?.warn?.("Tried to send message to disconnected client", message.type);
            return;
        }
        if (session.socket.isOpen) {
            if (message.type !== "patch" && message.type !== "push_result") {
                if (message.type !== "pong") {
                    this._flushDataMessages(sessionId);
                }
                session.socket.sendMessage(message);
            } else {
                if (session.debounceTimer === null) {
                    session.socket.sendMessage({
                        type: "data",
                        data: [
                            message
                        ]
                    });
                    session.debounceTimer = setTimeout(()=>this._flushDataMessages(sessionId), DATA_MESSAGE_DEBOUNCE_INTERVAL);
                } else {
                    session.outstandingDataMessages.push(message);
                }
            }
        } else {
            this.cancelSession(session.sessionId);
        }
    }
    // needs to accept sessionId and not a session because the session might be dead by the time
    // the timer fires
    _flushDataMessages(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session || session.state !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected) {
            return;
        }
        session.debounceTimer = null;
        if (session.outstandingDataMessages.length > 0) {
            session.socket.sendMessage({
                type: "data",
                data: session.outstandingDataMessages
            });
            session.outstandingDataMessages.length = 0;
        }
    }
    /** @internal */ removeSession(sessionId, fatalReason) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            this.log?.warn?.("Tried to remove unknown session");
            return;
        }
        this.sessions.delete(sessionId);
        const presence = this.getDocument(session.presenceId ?? "");
        try {
            if (fatalReason) {
                session.socket.close(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventCode"], fatalReason);
            } else {
                session.socket.close();
            }
        } catch  {}
        if (presence) {
            this.documents.delete(session.presenceId);
            this.broadcastPatch({
                diff: {
                    [session.presenceId]: [
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove
                    ]
                },
                sourceSessionId: sessionId
            });
        }
        this.events.emit("session_removed", {
            sessionId,
            meta: session.meta
        });
        if (this.sessions.size === 0) {
            this.events.emit("room_became_empty");
        }
    }
    cancelSession(sessionId) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            return;
        }
        if (session.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].AwaitingRemoval) {
            this.log?.warn?.("Tried to cancel session that is already awaiting removal");
            return;
        }
        this.sessions.set(sessionId, {
            state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].AwaitingRemoval,
            sessionId,
            presenceId: session.presenceId,
            socket: session.socket,
            cancellationTime: Date.now(),
            meta: session.meta,
            isReadonly: session.isReadonly,
            requiresLegacyRejection: session.requiresLegacyRejection
        });
        try {
            session.socket.close();
        } catch  {}
    }
    /**
   * Broadcast a patch to all connected clients except the one with the sessionId provided.
   * Automatically handles schema migration for clients on different versions.
   *
   * @param message - The broadcast message
   *   - diff - The network diff to broadcast to all clients
   *   - sourceSessionId - Optional ID of the session that originated this change (excluded from broadcast)
   * @returns This room instance for method chaining
   * @example
   * ```ts
   * room.broadcastPatch({
   *   diff: { 'shape:123': [RecordOpType.Put, newShapeData] },
   *   sourceSessionId: 'user-456' // This user won't receive the broadcast
   * })
   * ```
   */ broadcastPatch(message) {
        const { diff, sourceSessionId } = message;
        this.sessions.forEach((session)=>{
            if (session.state !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected) return;
            if (sourceSessionId === session.sessionId) return;
            if (!session.socket.isOpen) {
                this.cancelSession(session.sessionId);
                return;
            }
            const res = this.migrateDiffForSession(session.serializedSchema, diff);
            if (!res.ok) {
                this.rejectSession(session.sessionId, res.error === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                return;
            }
            this.sendMessage(session.sessionId, {
                type: "patch",
                diff: res.value,
                serverClock: this.clock
            });
        });
        return this;
    }
    /**
   * Send a custom message to a connected client. Useful for application-specific
   * communication that doesn't involve document synchronization.
   *
   * @param sessionId - The ID of the session to send the message to
   * @param data - The custom payload to send (will be JSON serialized)
   * @example
   * ```ts
   * // Send a custom notification
   * room.sendCustomMessage('user-123', {
   *   type: 'notification',
   *   message: 'Document saved successfully'
   * })
   *
   * // Send user-specific data
   * room.sendCustomMessage('user-456', {
   *   type: 'user_permissions',
   *   canEdit: true,
   *   canDelete: false
   * })
   * ```
   */ sendCustomMessage(sessionId, data) {
        this.sendMessage(sessionId, {
            type: "custom",
            data
        });
    }
    /**
   * Register a new client session with the room. The session will be in an awaiting
   * state until it sends a connect message with protocol handshake.
   *
   * @param opts - Session configuration
   *   - sessionId - Unique identifier for this session
   *   - socket - WebSocket adapter for communication
   *   - meta - Application-specific metadata for this session
   *   - isReadonly - Whether this session can modify documents
   * @returns This room instance for method chaining
   * @example
   * ```ts
   * room.handleNewSession({
   *   sessionId: crypto.randomUUID(),
   *   socket: new WebSocketAdapter(ws),
   *   meta: { userId: '123', name: 'Alice', avatar: 'url' },
   *   isReadonly: !hasEditPermission
   * })
   * ```
   *
   * @internal
   */ handleNewSession(opts) {
        const { sessionId, socket, meta, isReadonly } = opts;
        const existing = this.sessions.get(sessionId);
        this.sessions.set(sessionId, {
            state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].AwaitingConnectMessage,
            sessionId,
            socket,
            presenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,
            sessionStartTime: Date.now(),
            meta,
            isReadonly: isReadonly ?? false,
            // this gets set later during handleConnectMessage
            requiresLegacyRejection: false
        });
        return this;
    }
    /**
   * When we send a diff to a client, if that client is on a lower version than us, we need to make
   * the diff compatible with their version. At the moment this means migrating each affected record
   * to the client's version and sending the whole record again. We can optimize this later by
   * keeping the previous versions of records around long enough to recalculate these diffs for
   * older client versions.
   */ migrateDiffForSession(serializedSchema, diff) {
        if (serializedSchema === this.serializedSchema) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(diff);
        }
        const result = {};
        for (const [id, op] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntriesIterable"])(diff)){
            if (op[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove) {
                result[id] = op;
                continue;
            }
            const doc = this.getDocument(id);
            if (!doc) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].err(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew);
            }
            const migrationResult = this.schema.migratePersistedRecord(doc.state, serializedSchema, "down");
            if (migrationResult.type === "error") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].err(migrationResult.reason);
            }
            result[id] = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                migrationResult.value
            ];
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(result);
    }
    /**
   * Process an incoming message from a client session. Handles connection requests,
   * data synchronization pushes, and ping/pong for connection health.
   *
   * @param sessionId - The ID of the session that sent the message
   * @param message - The client message to process
   * @example
   * ```ts
   * // Typically called by WebSocket message handlers
   * websocket.onMessage((data) => {
   *   const message = JSON.parse(data)
   *   room.handleMessage(sessionId, message)
   * })
   * ```
   */ async handleMessage(sessionId, message) {
        const session = this.sessions.get(sessionId);
        if (!session) {
            this.log?.warn?.("Received message from unknown session");
            return;
        }
        switch(message.type){
            case "connect":
                {
                    return this.handleConnectRequest(session, message);
                }
            case "push":
                {
                    return this.handlePushRequest(session, message);
                }
            case "ping":
                {
                    if (session.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected) {
                        session.lastInteractionTime = Date.now();
                    }
                    return this.sendMessage(session.sessionId, {
                        type: "pong"
                    });
                }
            default:
                {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exhaustiveSwitchError"])(message);
                }
        }
    }
    /**
   * Reject and disconnect a session due to incompatibility or other fatal errors.
   * Sends appropriate error messages before closing the connection.
   *
   * @param sessionId - The session to reject
   * @param fatalReason - The reason for rejection (optional)
   * @example
   * ```ts
   * // Reject due to version mismatch
   * room.rejectSession('user-123', TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)
   *
   * // Reject due to permission issue
   * room.rejectSession('user-456', 'Insufficient permissions')
   * ```
   */ rejectSession(sessionId, fatalReason) {
        const session = this.sessions.get(sessionId);
        if (!session) return;
        if (!fatalReason) {
            this.removeSession(sessionId);
            return;
        }
        if (session.requiresLegacyRejection) {
            try {
                if (session.socket.isOpen) {
                    let legacyReason;
                    switch(fatalReason){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD:
                            legacyReason = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLIncompatibilityReason"].ClientTooOld;
                            break;
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD:
                            legacyReason = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLIncompatibilityReason"].ServerTooOld;
                            break;
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD:
                            legacyReason = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLIncompatibilityReason"].InvalidRecord;
                            break;
                        default:
                            legacyReason = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLIncompatibilityReason"].InvalidOperation;
                            break;
                    }
                    session.socket.sendMessage({
                        type: "incompatibility_error",
                        reason: legacyReason
                    });
                }
            } catch  {} finally{
                this.removeSession(sessionId);
            }
        } else {
            this.removeSession(sessionId, fatalReason);
        }
    }
    handleConnectRequest(session, message) {
        let theirProtocolVersion = message.protocolVersion;
        if (theirProtocolVersion === 5) {
            theirProtocolVersion = 6;
        }
        session.requiresLegacyRejection = theirProtocolVersion === 6;
        if (theirProtocolVersion === 6) {
            theirProtocolVersion++;
        }
        if (theirProtocolVersion == null || theirProtocolVersion < (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTlsyncProtocolVersion"])()) {
            this.rejectSession(session.sessionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
            return;
        } else if (theirProtocolVersion > (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTlsyncProtocolVersion"])()) {
            this.rejectSession(session.sessionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD);
            return;
        }
        if (message.schema == null) {
            this.rejectSession(session.sessionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
            return;
        }
        const migrations = this.schema.getMigrationsSince(message.schema);
        if (!migrations.ok || migrations.value.some((m)=>m.scope === "store" || !m.down)) {
            this.rejectSession(session.sessionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
            return;
        }
        const sessionSchema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(message.schema, this.serializedSchema) ? this.serializedSchema : message.schema;
        const connect = async (msg)=>{
            this.sessions.set(session.sessionId, {
                state: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected,
                sessionId: session.sessionId,
                presenceId: session.presenceId,
                socket: session.socket,
                serializedSchema: sessionSchema,
                lastInteractionTime: Date.now(),
                debounceTimer: null,
                outstandingDataMessages: [],
                meta: session.meta,
                isReadonly: session.isReadonly,
                requiresLegacyRejection: session.requiresLegacyRejection
            });
            this.sendMessage(session.sessionId, msg);
        };
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transaction"])((rollback)=>{
            if (// if the client requests changes since a time before we have tombstone history, send them the full state
            message.lastServerClock < this.tombstoneHistoryStartsAtClock || // similarly, if they ask for a time we haven't reached yet, send them the full state
            // this will only happen if the DB is reset (or there is no db) and the server restarts
            // or if the server exits/crashes with unpersisted changes
            message.lastServerClock > this.clock) {
                const diff = {};
                for (const [id, doc] of this.documents.entries()){
                    if (id !== session.presenceId) {
                        diff[id] = [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                            doc.state
                        ];
                    }
                }
                const migrated = this.migrateDiffForSession(sessionSchema, diff);
                if (!migrated.ok) {
                    rollback();
                    this.rejectSession(session.sessionId, migrated.error === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                    return;
                }
                connect({
                    type: "connect",
                    connectRequestId: message.connectRequestId,
                    hydrationType: "wipe_all",
                    protocolVersion: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTlsyncProtocolVersion"])(),
                    schema: this.schema.serialize(),
                    serverClock: this.clock,
                    diff: migrated.value,
                    isReadonly: session.isReadonly
                });
            } else {
                const diff = {};
                for (const doc of this.documents.values()){
                    if (doc.lastChangedClock > message.lastServerClock) {
                        diff[doc.state.id] = [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                            doc.state
                        ];
                    } else if (this.presenceType?.isId(doc.state.id) && doc.state.id !== session.presenceId) {
                        diff[doc.state.id] = [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                            doc.state
                        ];
                    }
                }
                for (const [id, deletedAtClock] of this.tombstones.entries()){
                    if (deletedAtClock > message.lastServerClock) {
                        diff[id] = [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove
                        ];
                    }
                }
                const migrated = this.migrateDiffForSession(sessionSchema, diff);
                if (!migrated.ok) {
                    rollback();
                    this.rejectSession(session.sessionId, migrated.error === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                    return;
                }
                connect({
                    type: "connect",
                    connectRequestId: message.connectRequestId,
                    hydrationType: "wipe_presence",
                    schema: this.schema.serialize(),
                    protocolVersion: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTlsyncProtocolVersion"])(),
                    serverClock: this.clock,
                    diff: migrated.value,
                    isReadonly: session.isReadonly
                });
            }
        });
    }
    handlePushRequest(session, message) {
        if (session && session.state !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected) {
            return;
        }
        if (session) {
            session.lastInteractionTime = Date.now();
        }
        this.clock++;
        const initialDocumentClock = this.documentClock;
        let didPresenceChange = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transaction"])((rollback)=>{
            const docChanges = {
                diff: null
            };
            const presenceChanges = {
                diff: null
            };
            const propagateOp = (changes, id, op)=>{
                if (!changes.diff) changes.diff = {};
                changes.diff[id] = op;
            };
            const fail = (reason, underlyingError)=>{
                rollback();
                if (session) {
                    this.rejectSession(session.sessionId, reason);
                } else {
                    throw new Error("failed to apply changes: " + reason, underlyingError);
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && ("TURBOPACK compile-time value", "development") !== "test") {
                    this.log?.error?.("failed to apply push", reason, message, underlyingError);
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].err(void 0);
            };
            const addDocument = (changes, id, _state)=>{
                const res = session ? this.schema.migratePersistedRecord(_state, session.serializedSchema, "up") : {
                    type: "success",
                    value: _state
                };
                if (res.type === "error") {
                    return fail(res.reason === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooOld ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                }
                const { value: state } = res;
                const doc = this.getDocument(id);
                if (doc) {
                    const diff = doc.replaceState(state, this.clock);
                    if (!diff.ok) {
                        return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD);
                    }
                    if (diff.value) {
                        this.documents.set(id, diff.value[1]);
                        propagateOp(changes, id, [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch,
                            diff.value[0]
                        ]);
                    }
                } else {
                    const result = this.addDocument(id, state, this.clock);
                    if (!result.ok) {
                        return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD);
                    }
                    propagateOp(changes, id, [
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                        state
                    ]);
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(void 0);
            };
            const patchDocument = (changes, id, patch)=>{
                const doc = this.getDocument(id);
                if (!doc) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(void 0);
                const downgraded = session ? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, "down") : {
                    type: "success",
                    value: doc.state
                };
                if (downgraded.type === "error") {
                    return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                }
                if (downgraded.value === doc.state) {
                    const diff = doc.mergeDiff(patch, this.clock);
                    if (!diff.ok) {
                        return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD);
                    }
                    if (diff.value) {
                        this.documents.set(id, diff.value[1]);
                        propagateOp(changes, id, [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch,
                            diff.value[0]
                        ]);
                    }
                } else {
                    const patched = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyObjectDiff"])(downgraded.value, patch);
                    const upgraded = session ? this.schema.migratePersistedRecord(patched, session.serializedSchema, "up") : {
                        type: "success",
                        value: patched
                    };
                    if (upgraded.type === "error") {
                        return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                    }
                    const diff = doc.replaceState(upgraded.value, this.clock);
                    if (!diff.ok) {
                        return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD);
                    }
                    if (diff.value) {
                        this.documents.set(id, diff.value[1]);
                        propagateOp(changes, id, [
                            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch,
                            diff.value[0]
                        ]);
                    }
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Result"].ok(void 0);
            };
            const { clientClock } = message;
            if (this.presenceType && session?.presenceId && "presence" in message && message.presence) {
                if (!session) throw new Error("session is required for presence pushes");
                const id = session.presenceId;
                const [type, val] = message.presence;
                const { typeName } = this.presenceType;
                switch(type){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put:
                        {
                            const res = addDocument(presenceChanges, id, {
                                ...val,
                                id,
                                typeName
                            });
                            if (!res.ok) return;
                            break;
                        }
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch:
                        {
                            const res = patchDocument(presenceChanges, id, {
                                ...val,
                                id: [
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValueOpType"].Put,
                                    id
                                ],
                                typeName: [
                                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ValueOpType"].Put,
                                    typeName
                                ]
                            });
                            if (!res.ok) return;
                            break;
                        }
                }
            }
            if (message.diff && !session?.isReadonly) {
                for (const [id, op] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapEntriesIterable"])(message.diff)){
                    switch(op[0]){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put:
                            {
                                if (!this.documentTypes.has(op[1].typeName)) {
                                    return fail(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].INVALID_RECORD);
                                }
                                const res = addDocument(docChanges, id, op[1]);
                                if (!res.ok) return;
                                break;
                            }
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Patch:
                            {
                                const res = patchDocument(docChanges, id, op[1]);
                                if (!res.ok) return;
                                break;
                            }
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove:
                            {
                                const doc = this.getDocument(id);
                                if (!doc) {
                                    continue;
                                }
                                this.removeDocument(id, this.clock);
                                propagateOp(docChanges, id, op);
                                break;
                            }
                    }
                }
            }
            if (// if there was only a presence push, the client doesn't need to do anything aside from
            // shift the push request.
            !message.diff || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(docChanges.diff, message.diff)) {
                if (session) {
                    this.sendMessage(session.sessionId, {
                        type: "push_result",
                        serverClock: this.clock,
                        clientClock,
                        action: "commit"
                    });
                }
            } else if (!docChanges.diff) {
                if (session) {
                    this.sendMessage(session.sessionId, {
                        type: "push_result",
                        serverClock: this.clock,
                        clientClock,
                        action: "discard"
                    });
                }
            } else {
                if (session) {
                    const migrateResult = this.migrateDiffForSession(session.serializedSchema, docChanges.diff);
                    if (!migrateResult.ok) {
                        return fail(migrateResult.error === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].SERVER_TOO_OLD : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].CLIENT_TOO_OLD);
                    }
                    this.sendMessage(session.sessionId, {
                        type: "push_result",
                        serverClock: this.clock,
                        clientClock,
                        action: {
                            rebaseWithDiff: migrateResult.value
                        }
                    });
                }
            }
            if (docChanges.diff || presenceChanges.diff) {
                this.broadcastPatch({
                    sourceSessionId: session?.sessionId,
                    diff: {
                        ...docChanges.diff,
                        ...presenceChanges.diff
                    }
                });
            }
            if (docChanges.diff) {
                this.documentClock = this.clock;
            }
            if (presenceChanges.diff) {
                didPresenceChange = true;
            }
            return;
        });
        if (this.documentClock !== initialDocumentClock) {
            this.onDataChange?.();
        }
        if (didPresenceChange) {
            this.onPresenceChange?.();
        }
    }
    /**
   * Handle the event when a client disconnects. Cleans up the session and
   * removes any presence information.
   *
   * @param sessionId - The session that disconnected
   * @example
   * ```ts
   * websocket.onClose(() => {
   *   room.handleClose(sessionId)
   * })
   * ```
   */ handleClose(sessionId) {
        this.cancelSession(sessionId);
    }
    /**
   * Apply changes to the room's store in a transactional way. Changes are
   * automatically synchronized to all connected clients.
   *
   * @param updater - Function that receives store methods to make changes
   * @returns Promise that resolves when the transaction is complete
   * @example
   * ```ts
   * // Add multiple shapes atomically
   * await room.updateStore((store) => {
   *   store.put(createShape({ type: 'geo', x: 100, y: 100 }))
   *   store.put(createShape({ type: 'text', x: 200, y: 200 }))
   * })
   *
   * // Async operations are supported
   * await room.updateStore(async (store) => {
   *   const template = await loadTemplate()
   *   template.shapes.forEach(shape => store.put(shape))
   * })
   * ```
   */ async updateStore(updater) {
        if (this._isClosed) {
            throw new Error("Cannot update store on a closed room");
        }
        const context = new StoreUpdateContext(Object.fromEntries(this.getSnapshot().documents.map((d)=>[
                d.state.id,
                d.state
            ])));
        try {
            await updater(context);
        } finally{
            context.close();
        }
        const diff = context.toDiff();
        if (Object.keys(diff).length === 0) {
            return;
        }
        this.handlePushRequest(null, {
            type: "push",
            diff,
            clientClock: 0
        });
    }
}
class StoreUpdateContext {
    constructor(snapshot){
        this.snapshot = snapshot;
    }
    updates = {
        puts: {},
        deletes: /* @__PURE__ */ new Set()
    };
    put(record) {
        if (this._isClosed) throw new Error("StoreUpdateContext is closed");
        if (record.id in this.snapshot && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(this.snapshot[record.id], record)) {
            delete this.updates.puts[record.id];
        } else {
            this.updates.puts[record.id] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["structuredClone"])(record);
        }
        this.updates.deletes.delete(record.id);
    }
    delete(recordOrId) {
        if (this._isClosed) throw new Error("StoreUpdateContext is closed");
        const id = typeof recordOrId === "string" ? recordOrId : recordOrId.id;
        delete this.updates.puts[id];
        if (this.snapshot[id]) {
            this.updates.deletes.add(id);
        }
    }
    get(id) {
        if (this._isClosed) throw new Error("StoreUpdateContext is closed");
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(this.updates.puts, id)) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["structuredClone"])(this.updates.puts[id]);
        }
        if (this.updates.deletes.has(id)) {
            return null;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["structuredClone"])(this.snapshot[id] ?? null);
    }
    getAll() {
        if (this._isClosed) throw new Error("StoreUpdateContext is closed");
        const result = Object.values(this.updates.puts);
        for (const [id, record] of Object.entries(this.snapshot)){
            if (!this.updates.deletes.has(id) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasOwnProperty"])(this.updates.puts, id)) {
                result.push(record);
            }
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["structuredClone"])(result);
    }
    toDiff() {
        const diff = {};
        for (const [id, record] of Object.entries(this.updates.puts)){
            diff[id] = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Put,
                record
            ];
        }
        for (const id of this.updates.deletes){
            diff[id] = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RecordOpType"].Remove
            ];
        }
        return diff;
    }
    _isClosed = false;
    close() {
        this._isClosed = true;
    }
}
;
 //# sourceMappingURL=TLSyncRoom.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSocketRoom.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TLSocketRoom",
    ()=>TLSocketRoom
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/tlschema/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$createTLSchema$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/tlschema/dist-esm/createTLSchema.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/value.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/RoomSession.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$ServerSocketAdapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/ServerSocketAdapter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncRoom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncRoom.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$chunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/chunk.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
class TLSocketRoom {
    /**
   * Creates a new TLSocketRoom instance for managing collaborative document synchronization.
   *
   * opts - Configuration options for the room
   *   - initialSnapshot - Optional initial document state to load
   *   - schema - Store schema defining record types and validation
   *   - clientTimeout - Milliseconds to wait before disconnecting inactive clients
   *   - log - Optional logger for warnings and errors
   *   - onSessionRemoved - Called when a client session is removed
   *   - onBeforeSendMessage - Called before sending messages to clients
   *   - onAfterReceiveMessage - Called after receiving messages from clients
   *   - onDataChange - Called when document data changes
   *   - onPresenceChange - Called when presence data changes
   */ constructor(opts){
        this.opts = opts;
        const initialSnapshot = opts.initialSnapshot && "store" in opts.initialSnapshot ? convertStoreSnapshotToRoomSnapshot(opts.initialSnapshot) : opts.initialSnapshot;
        this.syncCallbacks = {
            onDataChange: opts.onDataChange,
            onPresenceChange: opts.onPresenceChange
        };
        this.room = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncRoom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncRoom"]({
            ...this.syncCallbacks,
            schema: opts.schema ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$tlschema$2f$dist$2d$esm$2f$createTLSchema$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTLSchema"])(),
            snapshot: initialSnapshot,
            log: opts.log
        });
        this.room.events.on("session_removed", (args)=>{
            this.sessions.delete(args.sessionId);
            if (this.opts.onSessionRemoved) {
                this.opts.onSessionRemoved(this, {
                    sessionId: args.sessionId,
                    numSessionsRemaining: this.room.sessions.size,
                    meta: args.meta
                });
            }
        });
        this.log = "log" in opts ? opts.log : {
            error: console.error
        };
    }
    room;
    sessions = /* @__PURE__ */ new Map();
    log;
    syncCallbacks;
    /**
   * Returns the number of active sessions.
   * Note that this is not the same as the number of connected sockets!
   * Sessions time out a few moments after sockets close, to smooth over network hiccups.
   *
   * @returns the number of active sessions
   */ getNumActiveSessions() {
        return this.room.sessions.size;
    }
    /**
   * Handles a new client WebSocket connection, creating a session within the room.
   * This should be called whenever a client establishes a WebSocket connection to join
   * the collaborative document.
   *
   * @param opts - Connection options
   *   - sessionId - Unique identifier for the client session (typically from browser tab)
   *   - socket - WebSocket-like object for client communication
   *   - isReadonly - Whether the client can modify the document (defaults to false)
   *   - meta - Additional session metadata (required if SessionMeta is not void)
   *
   * @example
   * ```ts
   * // Handle new WebSocket connection
   * room.handleSocketConnect({
   *   sessionId: 'user-session-abc123',
   *   socket: webSocketConnection,
   *   isReadonly: !userHasEditPermission
   * })
   * ```
   *
   * @example
   * ```ts
   * // With session metadata
   * room.handleSocketConnect({
   *   sessionId: 'session-xyz',
   *   socket: ws,
   *   meta: { userId: 'user-123', name: 'Alice' }
   * })
   * ```
   */ handleSocketConnect(opts) {
        const { sessionId, socket, isReadonly = false } = opts;
        const handleSocketMessage = (event)=>this.handleSocketMessage(sessionId, event.data);
        const handleSocketError = this.handleSocketError.bind(this, sessionId);
        const handleSocketClose = this.handleSocketClose.bind(this, sessionId);
        this.sessions.set(sessionId, {
            assembler: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$chunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonChunkAssembler"](),
            socket,
            unlisten: ()=>{
                socket.removeEventListener?.("message", handleSocketMessage);
                socket.removeEventListener?.("close", handleSocketClose);
                socket.removeEventListener?.("error", handleSocketError);
            }
        });
        this.room.handleNewSession({
            sessionId,
            isReadonly,
            socket: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$ServerSocketAdapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ServerSocketAdapter"]({
                ws: socket,
                onBeforeSendMessage: this.opts.onBeforeSendMessage ? (message, stringified)=>this.opts.onBeforeSendMessage({
                        sessionId,
                        message,
                        stringified,
                        meta: this.room.sessions.get(sessionId)?.meta
                    }) : void 0
            }),
            meta: "meta" in opts ? opts.meta : void 0
        });
        socket.addEventListener?.("message", handleSocketMessage);
        socket.addEventListener?.("close", handleSocketClose);
        socket.addEventListener?.("error", handleSocketError);
    }
    /**
   * Processes a message received from a client WebSocket. Use this method in server
   * environments where WebSocket event listeners cannot be attached directly to socket
   * instances (e.g., Bun.serve, Cloudflare Workers with WebSocket hibernation).
   *
   * The method handles message chunking/reassembly and forwards complete messages
   * to the underlying sync room for processing.
   *
   * @param sessionId - Session identifier matching the one used in handleSocketConnect
   * @param message - Raw message data from the client (string or binary)
   *
   * @example
   * ```ts
   * // In a Bun.serve handler
   * server.upgrade(req, {
   *   data: { sessionId, room },
   *   upgrade(res, req) {
   *     // Connection established
   *   },
   *   message(ws, message) {
   *     const { sessionId, room } = ws.data
   *     room.handleSocketMessage(sessionId, message)
   *   }
   * })
   * ```
   */ handleSocketMessage(sessionId, message) {
        const assembler = this.sessions.get(sessionId)?.assembler;
        if (!assembler) {
            this.log?.warn?.("Received message from unknown session", sessionId);
            return;
        }
        try {
            const messageString = typeof message === "string" ? message : new TextDecoder().decode(message);
            const res = assembler.handleMessage(messageString);
            if (!res) {
                return;
            }
            if ("data" in res) {
                if (this.opts.onAfterReceiveMessage) {
                    const session = this.room.sessions.get(sessionId);
                    if (session) {
                        this.opts.onAfterReceiveMessage({
                            sessionId,
                            message: res.data,
                            stringified: res.stringified,
                            meta: session.meta
                        });
                    }
                }
                this.room.handleMessage(sessionId, res.data);
            } else {
                this.log?.error?.("Error assembling message", res.error);
                this.handleSocketError(sessionId);
            }
        } catch (e) {
            this.log?.error?.(e);
            this.room.rejectSession(sessionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncErrorCloseEventReason"].UNKNOWN_ERROR);
        }
    }
    /**
   * Handles a WebSocket error for the specified session. Use this in server environments
   * where socket event listeners cannot be attached directly. This will initiate cleanup
   * and session removal for the affected client.
   *
   * @param sessionId - Session identifier matching the one used in handleSocketConnect
   *
   * @example
   * ```ts
   * // In a custom WebSocket handler
   * socket.addEventListener('error', () => {
   *   room.handleSocketError(sessionId)
   * })
   * ```
   */ handleSocketError(sessionId) {
        this.room.handleClose(sessionId);
    }
    /**
   * Handles a WebSocket close event for the specified session. Use this in server
   * environments where socket event listeners cannot be attached directly. This will
   * initiate cleanup and session removal for the disconnected client.
   *
   * @param sessionId - Session identifier matching the one used in handleSocketConnect
   *
   * @example
   * ```ts
   * // In a custom WebSocket handler
   * socket.addEventListener('close', () => {
   *   room.handleSocketClose(sessionId)
   * })
   * ```
   */ handleSocketClose(sessionId) {
        this.room.handleClose(sessionId);
    }
    /**
   * Returns the current document clock value. The clock is a monotonically increasing
   * integer that increments with each document change, providing a consistent ordering
   * of changes across the distributed system.
   *
   * @returns The current document clock value
   *
   * @example
   * ```ts
   * const clock = room.getCurrentDocumentClock()
   * console.log(`Document is at version ${clock}`)
   * ```
   */ getCurrentDocumentClock() {
        return this.room.documentClock;
    }
    /**
   * Retrieves a deeply cloned copy of a record from the document store.
   * Returns undefined if the record doesn't exist. The returned record is
   * safe to mutate without affecting the original store data.
   *
   * @param id - Unique identifier of the record to retrieve
   * @returns Deep clone of the record, or undefined if not found
   *
   * @example
   * ```ts
   * const shape = room.getRecord('shape:abc123')
   * if (shape) {
   *   console.log('Shape position:', shape.x, shape.y)
   *   // Safe to modify without affecting store
   *   shape.x = 100
   * }
   * ```
   */ getRecord(id) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["structuredClone"])(this.room.documents.get(id)?.state);
    }
    /**
   * Returns information about all active sessions in the room. Each session
   * represents a connected client with their current connection status and metadata.
   *
   * @returns Array of session information objects containing:
   *   - sessionId - Unique session identifier
   *   - isConnected - Whether the session has an active WebSocket connection
   *   - isReadonly - Whether the session can modify the document
   *   - meta - Custom session metadata
   *
   * @example
   * ```ts
   * const sessions = room.getSessions()
   * console.log(`Room has ${sessions.length} active sessions`)
   *
   * for (const session of sessions) {
   *   console.log(`${session.sessionId}: ${session.isConnected ? 'online' : 'offline'}`)
   *   if (session.isReadonly) {
   *     console.log('  (read-only access)')
   *   }
   * }
   * ```
   */ getSessions() {
        return [
            ...this.room.sessions.values()
        ].map((session)=>{
            return {
                sessionId: session.sessionId,
                isConnected: session.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RoomSessionState"].Connected,
                isReadonly: session.isReadonly,
                meta: session.meta
            };
        });
    }
    /**
   * Creates a complete snapshot of the current document state, including all records
   * and synchronization metadata. This snapshot can be persisted to storage and used
   * to restore the room state later or revert to a previous version.
   *
   * @returns Complete room snapshot including documents, clock values, and tombstones
   *
   * @example
   * ```ts
   * // Capture current state for persistence
   * const snapshot = room.getCurrentSnapshot()
   * await saveToDatabase(roomId, JSON.stringify(snapshot))
   *
   * // Later, restore from snapshot
   * const savedSnapshot = JSON.parse(await loadFromDatabase(roomId))
   * const newRoom = new TLSocketRoom({ initialSnapshot: savedSnapshot })
   * ```
   */ getCurrentSnapshot() {
        return this.room.getSnapshot();
    }
    /**
   * Retrieves all presence records from the document store. Presence records
   * contain ephemeral user state like cursor positions and selections.
   *
   * @returns Object mapping record IDs to presence record data
   * @internal
   */ getPresenceRecords() {
        const result = {};
        for (const document of this.room.documents.values()){
            if (document.state.typeName === this.room.presenceType?.typeName) {
                result[document.state.id] = document.state;
            }
        }
        return result;
    }
    /**
   * Returns a JSON-serialized snapshot of the current document state. This is
   * equivalent to JSON.stringify(getCurrentSnapshot()) but provided as a convenience.
   *
   * @returns JSON string representation of the room snapshot
   * @internal
   */ getCurrentSerializedSnapshot() {
        return JSON.stringify(this.room.getSnapshot());
    }
    /**
   * Loads a document snapshot, completely replacing the current room state.
   * This will disconnect all current clients and update the document to match
   * the provided snapshot. Use this for restoring from backups or implementing
   * document versioning.
   *
   * @param snapshot - Room or store snapshot to load
   *
   * @example
   * ```ts
   * // Restore from a saved snapshot
   * const backup = JSON.parse(await loadBackup(roomId))
   * room.loadSnapshot(backup)
   *
   * // All clients will be disconnected and need to reconnect
   * // to see the restored document state
   * ```
   */ loadSnapshot(snapshot) {
        if ("store" in snapshot) {
            snapshot = convertStoreSnapshotToRoomSnapshot(snapshot);
        }
        const oldRoom = this.room;
        const oldRoomSnapshot = oldRoom.getSnapshot();
        const oldIds = oldRoomSnapshot.documents.map((d)=>d.state.id);
        const newIds = new Set(snapshot.documents.map((d)=>d.state.id));
        const removedIds = oldIds.filter((id)=>!newIds.has(id));
        const tombstones = {
            ...oldRoomSnapshot.tombstones
        };
        removedIds.forEach((id)=>{
            tombstones[id] = oldRoom.clock + 1;
        });
        newIds.forEach((id)=>{
            delete tombstones[id];
        });
        const newRoom = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncRoom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TLSyncRoom"]({
            ...this.syncCallbacks,
            schema: oldRoom.schema,
            snapshot: {
                clock: oldRoom.clock + 1,
                documentClock: oldRoom.clock + 1,
                documents: snapshot.documents.map((d)=>({
                        lastChangedClock: oldRoom.clock + 1,
                        state: d.state
                    })),
                schema: snapshot.schema,
                tombstones,
                tombstoneHistoryStartsAtClock: oldRoomSnapshot.tombstoneHistoryStartsAtClock
            },
            log: this.log
        });
        this.room = newRoom;
        oldRoom.close();
    }
    /**
   * Executes a transaction to modify the document store. Changes made within the
   * transaction are atomic and will be synchronized to all connected clients.
   * The transaction provides isolation from concurrent changes until it commits.
   *
   * @param updater - Function that receives store methods to make changes
   *   - store.get(id) - Retrieve a record (safe to mutate, but must call put() to commit)
   *   - store.put(record) - Save a modified record
   *   - store.getAll() - Get all records in the store
   *   - store.delete(id) - Remove a record from the store
   * @returns Promise that resolves when the transaction completes
   *
   * @example
   * ```ts
   * // Update multiple shapes in a single transaction
   * await room.updateStore(store => {
   *   const shape1 = store.get('shape:abc123')
   *   const shape2 = store.get('shape:def456')
   *
   *   if (shape1) {
   *     shape1.x = 100
   *     store.put(shape1)
   *   }
   *
   *   if (shape2) {
   *     shape2.meta.approved = true
   *     store.put(shape2)
   *   }
   * })
   * ```
   *
   * @example
   * ```ts
   * // Async transaction with external API call
   * await room.updateStore(async store => {
   *   const doc = store.get('document:main')
   *   if (doc) {
   *     doc.lastModified = await getCurrentTimestamp()
   *     store.put(doc)
   *   }
   * })
   * ```
   */ async updateStore(updater) {
        return this.room.updateStore(updater);
    }
    /**
   * Sends a custom message to a specific client session. This allows sending
   * application-specific data that doesn't modify the document state, such as
   * notifications, chat messages, or custom commands.
   *
   * @param sessionId - Target session identifier
   * @param data - Custom payload to send (will be JSON serialized)
   *
   * @example
   * ```ts
   * // Send a notification to a specific user
   * room.sendCustomMessage('session-123', {
   *   type: 'notification',
   *   message: 'Your changes have been saved'
   * })
   *
   * // Send a chat message
   * room.sendCustomMessage('session-456', {
   *   type: 'chat',
   *   from: 'Alice',
   *   text: 'Great work on this design!'
   * })
   * ```
   */ sendCustomMessage(sessionId, data) {
        this.room.sendCustomMessage(sessionId, data);
    }
    /**
   * Immediately removes a session from the room and closes its WebSocket connection.
   * The client will attempt to reconnect automatically unless a fatal reason is provided.
   *
   * @param sessionId - Session identifier to remove
   * @param fatalReason - Optional fatal error reason that prevents reconnection
   *
   * @example
   * ```ts
   * // Kick a user (they can reconnect)
   * room.closeSession('session-troublemaker')
   *
   * // Permanently ban a user
   * room.closeSession('session-banned', 'PERMISSION_DENIED')
   *
   * // Close session due to inactivity
   * room.closeSession('session-idle', 'TIMEOUT')
   * ```
   */ closeSession(sessionId, fatalReason) {
        this.room.rejectSession(sessionId, fatalReason);
    }
    /**
   * Closes the room and disconnects all connected clients. This should be called
   * when shutting down the room permanently, such as during server shutdown or
   * when the room is no longer needed. Once closed, the room cannot be reopened.
   *
   * @example
   * ```ts
   * // Clean shutdown when no users remain
   * if (room.getNumActiveSessions() === 0) {
   *   await persistSnapshot(room.getCurrentSnapshot())
   *   room.close()
   * }
   *
   * // Server shutdown
   * process.on('SIGTERM', () => {
   *   for (const room of activeRooms.values()) {
   *     room.close()
   *   }
   * })
   * ```
   */ close() {
        this.room.close();
    }
    /**
   * Checks whether the room has been permanently closed. Closed rooms cannot
   * accept new connections or process further changes.
   *
   * @returns True if the room is closed, false if still active
   *
   * @example
   * ```ts
   * if (room.isClosed()) {
   *   console.log('Room has been shut down')
   *   // Create a new room or redirect users
   * } else {
   *   // Room is still accepting connections
   *   room.handleSocketConnect({ sessionId, socket })
   * }
   * ```
   */ isClosed() {
        return this.room.isClosed();
    }
}
function convertStoreSnapshotToRoomSnapshot(snapshot) {
    return {
        clock: 0,
        documentClock: 0,
        documents: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["objectMapValues"])(snapshot.store).map((state)=>({
                state,
                lastChangedClock: 0
            })),
        schema: snapshot.schema,
        tombstones: {}
    };
}
;
 //# sourceMappingURL=TLSocketRoom.mjs.map
}),
"[project]/node_modules/@tldraw/sync-core/dist-esm/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/version.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$chunk$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/chunk.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$ClientWebSocketAdapter$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/ClientWebSocketAdapter.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$diff$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/diff.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$protocol$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/protocol.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$RoomSession$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/RoomSession.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLRemoteSyncError$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLRemoteSyncError.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSocketRoom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSocketRoom.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncClient$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncClient.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$sync$2d$core$2f$dist$2d$esm$2f$lib$2f$TLSyncRoom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/sync-core/dist-esm/lib/TLSyncRoom.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["registerTldrawLibraryVersion"])("@tldraw/sync-core", "4.1.1", "esm");
;
 //# sourceMappingURL=index.mjs.map
}),
]);

//# sourceMappingURL=node_modules_%40tldraw_sync-core_dist-esm_e8276783._.js.map