{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/chunk.ts"],"sourcesContent":["// quarter of a megabyte, max possible utf-8 string size\n\n// cloudflare workers only accept messages of max 1mb\nconst MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES = 1024 * 1024\n// utf-8 is max 4 bytes per char\nconst MAX_BYTES_PER_CHAR = 4\n\n// in the (admittedly impossible) worst case, the max size is 1/4 of a megabyte\nconst MAX_SAFE_MESSAGE_SIZE = MAX_CLIENT_SENT_MESSAGE_SIZE_BYTES / MAX_BYTES_PER_CHAR\n\n/**\n * Splits a string into smaller chunks suitable for transmission over WebSockets.\n * This function ensures messages don't exceed size limits imposed by platforms like Cloudflare Workers (1MB max).\n * Each chunk is prefixed with a number indicating how many more chunks follow.\n *\n * @param msg - The string to split into chunks\n * @param maxSafeMessageSize - Maximum safe size for each chunk in characters. Defaults to quarter megabyte to account for UTF-8 encoding\n * @returns Array of chunked strings, each prefixed with \"\\{number\\}_\" where number indicates remaining chunks\n *\n * @example\n * ```ts\n * // Small message - returns as single chunk\n * chunk('hello world') // ['hello world']\n *\n * // Large message - splits into multiple chunks\n * chunk('very long message...', 10)\n * // ['2_very long', '1_ message', '0_...']\n * ```\n *\n * @internal\n */\nexport function chunk(msg: string, maxSafeMessageSize = MAX_SAFE_MESSAGE_SIZE) {\n\tif (msg.length < maxSafeMessageSize) {\n\t\treturn [msg]\n\t} else {\n\t\tconst chunks = []\n\t\tlet chunkNumber = 0\n\t\tlet offset = msg.length\n\t\twhile (offset > 0) {\n\t\t\tconst prefix = `${chunkNumber}_`\n\t\t\tconst chunkSize = Math.max(Math.min(maxSafeMessageSize - prefix.length, offset), 1)\n\t\t\tchunks.unshift(prefix + msg.slice(offset - chunkSize, offset))\n\t\t\toffset -= chunkSize\n\t\t\tchunkNumber++\n\t\t}\n\t\treturn chunks\n\t}\n}\n\nconst chunkRe = /^(\\d+)_(.*)$/\n\n/**\n * Assembles chunked JSON messages back into complete objects.\n * Handles both regular JSON messages and chunked messages created by the chunk() function.\n * Maintains internal state to track partially received chunked messages.\n *\n * @example\n * ```ts\n * const assembler = new JsonChunkAssembler()\n *\n * // Handle regular JSON message\n * const result1 = assembler.handleMessage('{\"hello\": \"world\"}')\n * // Returns: { data: { hello: \"world\" }, stringified: '{\"hello\": \"world\"}' }\n *\n * // Handle chunked message\n * assembler.handleMessage('1_hello') // Returns: null (partial)\n * const result2 = assembler.handleMessage('0_ world')\n * // Returns: { data: \"hello world\", stringified: \"hello world\" }\n * ```\n *\n * @public\n */\nexport class JsonChunkAssembler {\n\t/**\n\t * Current assembly state - either 'idle' or tracking chunks being received\n\t */\n\tstate:\n\t\t| 'idle'\n\t\t| {\n\t\t\t\tchunksReceived: string[]\n\t\t\t\ttotalChunks: number\n\t\t  } = 'idle'\n\n\t/**\n\t * Processes a single message, which can be either a complete JSON object or a chunk.\n\t * For complete JSON objects (starting with '{'), parses immediately.\n\t * For chunks (prefixed with \"{number}_\"), accumulates until all chunks received.\n\t *\n\t * @param msg - The message to process, either JSON or chunk format\n\t * @returns Result object with data/stringified on success, error object on failure, or null for incomplete chunks\n\t * \t- `{ data: object, stringified: string }` - Successfully parsed complete message\n\t * \t- `{ error: Error }` - Parse error or invalid chunk sequence\n\t * \t- `null` - Chunk received but more chunks expected\n\t *\n\t * @example\n\t * ```ts\n\t * const assembler = new JsonChunkAssembler()\n\t *\n\t * // Complete JSON message\n\t * const result = assembler.handleMessage('{\"key\": \"value\"}')\n\t * if (result && 'data' in result) {\n\t *   console.log(result.data) // { key: \"value\" }\n\t * }\n\t *\n\t * // Chunked message sequence\n\t * assembler.handleMessage('2_hel') // null - more chunks expected\n\t * assembler.handleMessage('1_lo ') // null - more chunks expected\n\t * assembler.handleMessage('0_wor') // { data: \"hello wor\", stringified: \"hello wor\" }\n\t * ```\n\t */\n\thandleMessage(msg: string): { error: Error } | { stringified: string; data: object } | null {\n\t\tif (msg.startsWith('{')) {\n\t\t\tconst error = this.state === 'idle' ? undefined : new Error('Unexpected non-chunk message')\n\t\t\tthis.state = 'idle'\n\t\t\treturn error ? { error } : { data: JSON.parse(msg), stringified: msg }\n\t\t} else {\n\t\t\tconst match = chunkRe.exec(msg)!\n\t\t\tif (!match) {\n\t\t\t\tthis.state = 'idle'\n\t\t\t\treturn { error: new Error('Invalid chunk: ' + JSON.stringify(msg.slice(0, 20) + '...')) }\n\t\t\t}\n\t\t\tconst numChunksRemaining = Number(match[1])\n\t\t\tconst data = match[2]\n\n\t\t\tif (this.state === 'idle') {\n\t\t\t\tthis.state = {\n\t\t\t\t\tchunksReceived: [data],\n\t\t\t\t\ttotalChunks: numChunksRemaining + 1,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.state.chunksReceived.push(data)\n\t\t\t\tif (numChunksRemaining !== this.state.totalChunks - this.state.chunksReceived.length) {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t\treturn { error: new Error(`Chunks received in wrong order`) }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.state.chunksReceived.length === this.state.totalChunks) {\n\t\t\t\ttry {\n\t\t\t\t\tconst stringified = this.state.chunksReceived.join('')\n\t\t\t\t\tconst data = JSON.parse(stringified)\n\t\t\t\t\treturn { data, stringified }\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn { error: e as Error }\n\t\t\t\t} finally {\n\t\t\t\t\tthis.state = 'idle'\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null\n\t\t}\n\t}\n}\n"],"names":["data"],"mappings":";;;;;;AAGA,MAAM,qCAAqC,OAAO;AAElD,MAAM,qBAAqB;AAG3B,MAAM,wBAAwB,qCAAqC;AAuB5D,SAAS,MAAM,GAAA,EAAa,qBAAqB,qBAAA,EAAuB;IAC9E,IAAI,IAAI,MAAA,GAAS,oBAAoB;QACpC,OAAO;YAAC,GAAG;SAAA;IACZ,OAAO;QACN,MAAM,SAAS,CAAC,CAAA;QAChB,IAAI,cAAc;QAClB,IAAI,SAAS,IAAI,MAAA;QACjB,MAAO,SAAS,EAAG;YAClB,MAAM,SAAS,GAAG,WAAW,CAAA,CAAA,CAAA;YAC7B,MAAM,YAAY,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,qBAAqB,OAAO,MAAA,EAAQ,MAAM,GAAG,CAAC;YAClF,OAAO,OAAA,CAAQ,SAAS,IAAI,KAAA,CAAM,SAAS,WAAW,MAAM,CAAC;YAC7D,UAAU;YACV;QACD;QACA,OAAO;IACR;AACD;AAEA,MAAM,UAAU;AAuBT,MAAM,mBAAmB;IAAA;;GAAA,GAI/B,QAKO,OAAA;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA6BP,cAAc,GAAA,EAA8E;QAC3F,IAAI,IAAI,UAAA,CAAW,GAAG,GAAG;YACxB,MAAM,QAAQ,IAAA,CAAK,KAAA,KAAU,SAAS,KAAA,IAAY,IAAI,MAAM,8BAA8B;YAC1F,IAAA,CAAK,KAAA,GAAQ;YACb,OAAO,QAAQ;gBAAE;YAAM,IAAI;gBAAE,MAAM,KAAK,KAAA,CAAM,GAAG;gBAAG,aAAa;YAAI;QACtE,OAAO;YACN,MAAM,QAAQ,QAAQ,IAAA,CAAK,GAAG;YAC9B,IAAI,CAAC,OAAO;gBACX,IAAA,CAAK,KAAA,GAAQ;gBACb,OAAO;oBAAE,OAAO,IAAI,MAAM,oBAAoB,KAAK,SAAA,CAAU,IAAI,KAAA,CAAM,GAAG,EAAE,IAAI,KAAK,CAAC;gBAAE;YACzF;YACA,MAAM,qBAAqB,OAAO,KAAA,CAAM,CAAC,CAAC;YAC1C,MAAM,OAAO,KAAA,CAAM,CAAC,CAAA;YAEpB,IAAI,IAAA,CAAK,KAAA,KAAU,QAAQ;gBAC1B,IAAA,CAAK,KAAA,GAAQ;oBACZ,gBAAgB;wBAAC,IAAI;qBAAA;oBACrB,aAAa,qBAAqB;gBACnC;YACD,OAAO;gBACN,IAAA,CAAK,KAAA,CAAM,cAAA,CAAe,IAAA,CAAK,IAAI;gBACnC,IAAI,uBAAuB,IAAA,CAAK,KAAA,CAAM,WAAA,GAAc,IAAA,CAAK,KAAA,CAAM,cAAA,CAAe,MAAA,EAAQ;oBACrF,IAAA,CAAK,KAAA,GAAQ;oBACb,OAAO;wBAAE,OAAO,IAAI,MAAM,CAAA,8BAAA,CAAgC;oBAAE;gBAC7D;YACD;YACA,IAAI,IAAA,CAAK,KAAA,CAAM,cAAA,CAAe,MAAA,KAAW,IAAA,CAAK,KAAA,CAAM,WAAA,EAAa;gBAChE,IAAI;oBACH,MAAM,cAAc,IAAA,CAAK,KAAA,CAAM,cAAA,CAAe,IAAA,CAAK,EAAE;oBACrD,MAAMA,QAAO,KAAK,KAAA,CAAM,WAAW;oBACnC,OAAO;wBAAE,MAAAA;wBAAM;oBAAY;gBAC5B,EAAA,OAAS,GAAG;oBACX,OAAO;wBAAE,OAAO;oBAAW;gBAC5B,SAAE;oBACD,IAAA,CAAK,KAAA,GAAQ;gBACd;YACD;YACA,OAAO;QACR;IACD;AACD","debugId":null}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/diff.ts"],"sourcesContent":["import { RecordsDiff, UnknownRecord } from '@tldraw/store'\nimport { isEqual, objectMapEntries, objectMapValues } from '@tldraw/utils'\n\n/**\n * Constants representing the types of operations that can be applied to records in network diffs.\n * These operations describe how a record has been modified during synchronization.\n *\n * @internal\n */\nexport const RecordOpType = {\n\tPut: 'put',\n\tPatch: 'patch',\n\tRemove: 'remove',\n} as const\n\n/**\n * Union type of all possible record operation types.\n *\n * @internal\n */\nexport type RecordOpType = (typeof RecordOpType)[keyof typeof RecordOpType]\n\n/**\n * Represents a single operation to be applied to a record during synchronization.\n *\n * @param R - The record type being operated on\n *\n * @internal\n */\nexport type RecordOp<R extends UnknownRecord> =\n\t| [typeof RecordOpType.Put, R]\n\t| [typeof RecordOpType.Patch, ObjectDiff]\n\t| [typeof RecordOpType.Remove]\n\n/**\n * A one-way (non-reversible) diff designed for small json footprint. These are mainly intended to\n * be sent over the wire. Either as push requests from the client to the server, or as patch\n * operations in the opposite direction.\n *\n * Each key in this object is the id of a record that has been added, updated, or removed.\n *\n * @internal\n */\nexport interface NetworkDiff<R extends UnknownRecord> {\n\t[id: string]: RecordOp<R>\n}\n\n/**\n * Converts a (reversible, verbose) RecordsDiff into a (non-reversible, concise) NetworkDiff\n * suitable for transmission over the network. This function optimizes the diff representation\n * for minimal bandwidth usage while maintaining all necessary change information.\n *\n * @param diff - The RecordsDiff containing added, updated, and removed records\n * @returns A compact NetworkDiff for network transmission, or null if no changes exist\n *\n * @example\n * ```ts\n * const recordsDiff = {\n *   added: { 'shape:1': newShape },\n *   updated: { 'shape:2': [oldShape, updatedShape] },\n *   removed: { 'shape:3': removedShape }\n * }\n *\n * const networkDiff = getNetworkDiff(recordsDiff)\n * // Returns: {\n * //   'shape:1': ['put', newShape],\n * //   'shape:2': ['patch', { x: ['put', 100] }],\n * //   'shape:3': ['remove']\n * // }\n * ```\n *\n * @internal\n */\nexport function getNetworkDiff<R extends UnknownRecord>(\n\tdiff: RecordsDiff<R>\n): NetworkDiff<R> | null {\n\tlet res: NetworkDiff<R> | null = null\n\n\tfor (const [k, v] of objectMapEntries(diff.added)) {\n\t\tif (!res) res = {}\n\t\tres[k] = [RecordOpType.Put, v]\n\t}\n\n\tfor (const [from, to] of objectMapValues(diff.updated)) {\n\t\tconst diff = diffRecord(from, to)\n\t\tif (diff) {\n\t\t\tif (!res) res = {}\n\t\t\tres[to.id] = [RecordOpType.Patch, diff]\n\t\t}\n\t}\n\n\tfor (const removed of Object.keys(diff.removed)) {\n\t\tif (!res) res = {}\n\t\tres[removed] = [RecordOpType.Remove]\n\t}\n\n\treturn res\n}\n\n/**\n * Constants representing the types of operations that can be applied to individual values\n * within object diffs. These operations describe how object properties have changed.\n *\n * @internal\n */\nexport const ValueOpType = {\n\tPut: 'put',\n\tDelete: 'delete',\n\tAppend: 'append',\n\tPatch: 'patch',\n} as const\n/**\n * Union type of all possible value operation types.\n *\n * @internal\n */\nexport type ValueOpType = (typeof ValueOpType)[keyof typeof ValueOpType]\n\n/**\n * Operation that replaces a value entirely with a new value.\n *\n * @internal\n */\nexport type PutOp = [type: typeof ValueOpType.Put, value: unknown]\n/**\n * Operation that appends new values to the end of an array.\n *\n * @internal\n */\nexport type AppendOp = [type: typeof ValueOpType.Append, values: unknown[], offset: number]\n/**\n * Operation that applies a nested diff to an object or array.\n *\n * @internal\n */\nexport type PatchOp = [type: typeof ValueOpType.Patch, diff: ObjectDiff]\n/**\n * Operation that removes a property from an object.\n *\n * @internal\n */\nexport type DeleteOp = [type: typeof ValueOpType.Delete]\n\n/**\n * Union type representing any value operation that can be applied during diffing.\n *\n * @internal\n */\nexport type ValueOp = PutOp | AppendOp | PatchOp | DeleteOp\n\n/**\n * Represents the differences between two objects as a mapping of property names\n * to the operations needed to transform one object into another.\n *\n * @internal\n */\nexport interface ObjectDiff {\n\t[k: string]: ValueOp\n}\n\n/**\n * Computes the difference between two record objects, generating an ObjectDiff\n * that describes how to transform the previous record into the next record.\n * This function is optimized for tldraw records and treats 'props' as a nested object.\n *\n * @param prev - The previous version of the record\n * @param next - The next version of the record\n * @returns An ObjectDiff describing the changes, or null if no changes exist\n *\n * @example\n * ```ts\n * const oldShape = { id: 'shape:1', x: 100, y: 200, props: { color: 'red' } }\n * const newShape = { id: 'shape:1', x: 150, y: 200, props: { color: 'blue' } }\n *\n * const diff = diffRecord(oldShape, newShape)\n * // Returns: {\n * //   x: ['put', 150],\n * //   props: ['patch', { color: ['put', 'blue'] }]\n * // }\n * ```\n *\n * @internal\n */\nexport function diffRecord(prev: object, next: object): ObjectDiff | null {\n\treturn diffObject(prev, next, new Set(['props']))\n}\n\nfunction diffObject(prev: object, next: object, nestedKeys?: Set<string>): ObjectDiff | null {\n\tif (prev === next) {\n\t\treturn null\n\t}\n\tlet result: ObjectDiff | null = null\n\tfor (const key of Object.keys(prev)) {\n\t\t// if key is not in next then it was deleted\n\t\tif (!(key in next)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Delete]\n\t\t\tcontinue\n\t\t}\n\t\t// if key is in both places, then compare values\n\t\tconst prevVal = (prev as any)[key]\n\t\tconst nextVal = (next as any)[key]\n\t\tif (!isEqual(prevVal, nextVal)) {\n\t\t\tif (nestedKeys?.has(key) && prevVal && nextVal) {\n\t\t\t\tconst diff = diffObject(prevVal, nextVal)\n\t\t\t\tif (diff) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = [ValueOpType.Patch, diff]\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(nextVal) && Array.isArray(prevVal)) {\n\t\t\t\tconst op = diffArray(prevVal, nextVal)\n\t\t\t\tif (op) {\n\t\t\t\t\tif (!result) result = {}\n\t\t\t\t\tresult[key] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!result) result = {}\n\t\t\t\tresult[key] = [ValueOpType.Put, nextVal]\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key of Object.keys(next)) {\n\t\t// if key is in next but not in prev then it was added\n\t\tif (!(key in prev)) {\n\t\t\tif (!result) result = {}\n\t\t\tresult[key] = [ValueOpType.Put, (next as any)[key]]\n\t\t}\n\t}\n\treturn result\n}\n\nfunction diffValue(valueA: unknown, valueB: unknown): ValueOp | null {\n\tif (Object.is(valueA, valueB)) return null\n\tif (Array.isArray(valueA) && Array.isArray(valueB)) {\n\t\treturn diffArray(valueA, valueB)\n\t} else if (!valueA || !valueB || typeof valueA !== 'object' || typeof valueB !== 'object') {\n\t\treturn isEqual(valueA, valueB) ? null : [ValueOpType.Put, valueB]\n\t} else {\n\t\tconst diff = diffObject(valueA, valueB)\n\t\treturn diff ? [ValueOpType.Patch, diff] : null\n\t}\n}\n\nfunction diffArray(prevArray: unknown[], nextArray: unknown[]): PutOp | AppendOp | PatchOp | null {\n\tif (Object.is(prevArray, nextArray)) return null\n\t// if lengths are equal, check for patch operation\n\tif (prevArray.length === nextArray.length) {\n\t\t// bail out if more than len/5 items need patching\n\t\tconst maxPatchIndexes = Math.max(prevArray.length / 5, 1)\n\t\tconst toPatchIndexes = []\n\t\tfor (let i = 0; i < prevArray.length; i++) {\n\t\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\t\ttoPatchIndexes.push(i)\n\t\t\t\tif (toPatchIndexes.length > maxPatchIndexes) {\n\t\t\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (toPatchIndexes.length === 0) {\n\t\t\t// same length and no items changed, so no diff\n\t\t\treturn null\n\t\t}\n\t\tconst diff: ObjectDiff = {}\n\t\tfor (const i of toPatchIndexes) {\n\t\t\tconst prevItem = prevArray[i]\n\t\t\tconst nextItem = nextArray[i]\n\t\t\tif (!prevItem || !nextItem) {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t} else if (typeof prevItem === 'object' && typeof nextItem === 'object') {\n\t\t\t\tconst op = diffValue(prevItem, nextItem)\n\t\t\t\tif (op) {\n\t\t\t\t\tdiff[i] = op\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdiff[i] = [ValueOpType.Put, nextItem]\n\t\t\t}\n\t\t}\n\t\treturn [ValueOpType.Patch, diff]\n\t}\n\n\t// if lengths are not equal, check for append operation, and bail out\n\t// to replace whole array if any shared elems changed\n\tfor (let i = 0; i < prevArray.length; i++) {\n\t\tif (!isEqual(prevArray[i], nextArray[i])) {\n\t\t\treturn [ValueOpType.Put, nextArray]\n\t\t}\n\t}\n\n\treturn [ValueOpType.Append, nextArray.slice(prevArray.length), prevArray.length]\n}\n\n/**\n * Applies an ObjectDiff to an object, returning a new object with the changes applied.\n * This function handles all value operation types and creates a shallow copy when modifications\n * are needed. If no changes are required, the original object is returned.\n *\n * @param object - The object to apply the diff to\n * @param objectDiff - The ObjectDiff containing the operations to apply\n * @returns A new object with the diff applied, or the original object if no changes were needed\n *\n * @example\n * ```ts\n * const original = { x: 100, y: 200, props: { color: 'red' } }\n * const diff = {\n *   x: ['put', 150],\n *   props: ['patch', { color: ['put', 'blue'] }]\n * }\n *\n * const updated = applyObjectDiff(original, diff)\n * // Returns: { x: 150, y: 200, props: { color: 'blue' } }\n * ```\n *\n * @internal\n */\nexport function applyObjectDiff<T extends object>(object: T, objectDiff: ObjectDiff): T {\n\t// don't patch nulls\n\tif (!object || typeof object !== 'object') return object\n\tconst isArray = Array.isArray(object)\n\tlet newObject: any | undefined = undefined\n\tconst set = (k: any, v: any) => {\n\t\tif (!newObject) {\n\t\t\tif (isArray) {\n\t\t\t\tnewObject = [...object]\n\t\t\t} else {\n\t\t\t\tnewObject = { ...object }\n\t\t\t}\n\t\t}\n\t\tif (isArray) {\n\t\t\tnewObject[Number(k)] = v\n\t\t} else {\n\t\t\tnewObject[k] = v\n\t\t}\n\t}\n\tfor (const [key, op] of Object.entries(objectDiff)) {\n\t\tswitch (op[0]) {\n\t\t\tcase ValueOpType.Put: {\n\t\t\t\tconst value = op[1]\n\t\t\t\tif (!isEqual(object[key as keyof T], value)) {\n\t\t\t\t\tset(key, value)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Append: {\n\t\t\t\tconst values = op[1]\n\t\t\t\tconst offset = op[2]\n\t\t\t\tconst arr = object[key as keyof T]\n\t\t\t\tif (Array.isArray(arr) && arr.length === offset) {\n\t\t\t\t\tset(key, [...arr, ...values])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Patch: {\n\t\t\t\tif (object[key as keyof T] && typeof object[key as keyof T] === 'object') {\n\t\t\t\t\tconst diff = op[1]\n\t\t\t\t\tconst patched = applyObjectDiff(object[key as keyof T] as object, diff)\n\t\t\t\t\tif (patched !== object[key as keyof T]) {\n\t\t\t\t\t\tset(key, patched)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase ValueOpType.Delete: {\n\t\t\t\tif (key in object) {\n\t\t\t\t\tif (!newObject) {\n\t\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\t\tconsole.error(\"Can't delete array item yet (this should never happen)\")\n\t\t\t\t\t\t\tnewObject = [...object]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewObject = { ...object }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete newObject[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newObject ?? object\n}\n"],"names":["diff"],"mappings":"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","debugId":null}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/interval.ts"],"sourcesContent":["/**\n * Creates a repeating timer that executes a callback at regular intervals and returns a cleanup function.\n *\n * This utility function wraps the standard `setInterval`/`clearInterval` pattern into a more convenient\n * interface that returns a dispose function for cleanup. It's commonly used in the sync system for\n * periodic tasks like health checks, ping operations, and session pruning.\n *\n * @param cb - The callback function to execute at each interval\n * @param timeout - The time interval in milliseconds between callback executions\n * @returns A cleanup function that stops the interval when called\n *\n * @example\n * ```ts\n * // Create a periodic health check\n * const stopHealthCheck = interval(() => {\n *   console.log('Checking server health...')\n *   checkServerConnection()\n * }, 5000)\n *\n * // Later, stop the health check\n * stopHealthCheck()\n * ```\n *\n * @example\n * ```ts\n * // Use in a disposables array for cleanup management\n * class MyClass {\n *   private disposables = [\n *     interval(() => this.sendPing(), 30000),\n *     interval(() => this.pruneSessions(), 2000)\n *   ]\n *\n *   dispose() {\n *     this.disposables.forEach(dispose => dispose())\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function interval(cb: () => void, timeout: number) {\n\tconst i = setInterval(cb, timeout)\n\treturn () => clearInterval(i)\n}\n"],"names":[],"mappings":";;;;AAwCO,SAAS,SAAS,EAAA,EAAgB,OAAA,EAAiB;IACzD,MAAM,IAAI,YAAY,IAAI,OAAO;IACjC,OAAO,IAAM,cAAc,CAAC;AAC7B","debugId":null}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/protocol.ts"],"sourcesContent":["import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { NetworkDiff, ObjectDiff, RecordOpType } from './diff'\n\nconst TLSYNC_PROTOCOL_VERSION = 7\n\n/**\n * Gets the current tldraw sync protocol version number.\n *\n * This version number is used during WebSocket connection handshake to ensure\n * client and server compatibility. When versions don't match, the connection\n * will be rejected with an incompatibility error.\n *\n * @returns The current protocol version number\n *\n * @example\n * ```ts\n * const version = getTlsyncProtocolVersion()\n * console.log(`Using protocol version: ${version}`)\n * ```\n *\n * @internal\n */\nexport function getTlsyncProtocolVersion() {\n\treturn TLSYNC_PROTOCOL_VERSION\n}\n\n/**\n * Constants defining the different types of protocol incompatibility reasons.\n *\n * These values indicate why a client-server connection was rejected due to\n * version or compatibility issues. Each reason helps diagnose specific problems\n * during the connection handshake.\n *\n * @example\n * ```ts\n * if (error.reason === TLIncompatibilityReason.ClientTooOld) {\n *   showUpgradeMessage('Please update your client')\n * }\n * ```\n *\n * @internal\n * @deprecated Replaced by websocket .close status/reason\n */\nexport const TLIncompatibilityReason = {\n\tClientTooOld: 'clientTooOld',\n\tServerTooOld: 'serverTooOld',\n\tInvalidRecord: 'invalidRecord',\n\tInvalidOperation: 'invalidOperation',\n} as const\n\n/**\n * Union type representing all possible incompatibility reason values.\n *\n * This type represents the different reasons why a client-server connection\n * might fail due to protocol or version mismatches.\n *\n * @example\n * ```ts\n * function handleIncompatibility(reason: TLIncompatibilityReason) {\n *   switch (reason) {\n *     case 'clientTooOld':\n *       return 'Client needs to be updated'\n *     case 'serverTooOld':\n *       return 'Server needs to be updated'\n *   }\n * }\n * ```\n *\n * @internal\n * @deprecated replaced by websocket .close status/reason\n */\nexport type TLIncompatibilityReason =\n\t(typeof TLIncompatibilityReason)[keyof typeof TLIncompatibilityReason]\n\n/**\n * Union type representing all possible message types that can be sent from server to client.\n *\n * This encompasses the complete set of server-originated WebSocket messages in the tldraw\n * sync protocol, including connection establishment, data synchronization, and error handling.\n *\n * @param R - The record type being synchronized (extends UnknownRecord)\n *\n * @example\n * ```ts\n * syncClient.onReceiveMessage((message: TLSocketServerSentEvent<MyRecord>) => {\n *   switch (message.type) {\n *     case 'connect':\n *       console.log('Connected to room with clock:', message.serverClock)\n *       break\n *     case 'data':\n *       console.log('Received data updates:', message.data)\n *       break\n *   }\n * })\n * ```\n *\n * @internal\n */\nexport type TLSocketServerSentEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'connect'\n\t\t\thydrationType: 'wipe_all' | 'wipe_presence'\n\t\t\tconnectRequestId: string\n\t\t\tprotocolVersion: number\n\t\t\tschema: SerializedSchema\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t\t\tisReadonly: boolean\n\t  }\n\t| {\n\t\t\ttype: 'incompatibility_error'\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\treason: TLIncompatibilityReason\n\t  }\n\t| {\n\t\t\ttype: 'pong'\n\t  }\n\t| { type: 'data'; data: TLSocketServerSentDataEvent<R>[] }\n\t| { type: 'custom'; data: any }\n\t| TLSocketServerSentDataEvent<R>\n\n/**\n * Union type representing data-related messages sent from server to client.\n *\n * These messages handle the core synchronization operations: applying patches from\n * other clients and confirming the results of client push operations.\n *\n * @param R - The record type being synchronized (extends UnknownRecord)\n *\n * @example\n * ```ts\n * function handleDataEvent(event: TLSocketServerSentDataEvent<MyRecord>) {\n *   if (event.type === 'patch') {\n *     // Apply changes from other clients\n *     applyNetworkDiff(event.diff)\n *   } else if (event.type === 'push_result') {\n *     // Handle result of our push request\n *     if (event.action === 'commit') {\n *       console.log('Changes accepted by server')\n *     }\n *   }\n * }\n * ```\n *\n * @internal\n */\nexport type TLSocketServerSentDataEvent<R extends UnknownRecord> =\n\t| {\n\t\t\ttype: 'patch'\n\t\t\tdiff: NetworkDiff<R>\n\t\t\tserverClock: number\n\t  }\n\t| {\n\t\t\ttype: 'push_result'\n\t\t\tclientClock: number\n\t\t\tserverClock: number\n\t\t\taction: 'discard' | 'commit' | { rebaseWithDiff: NetworkDiff<R> }\n\t  }\n\n/**\n * Interface defining a client-to-server push request message.\n *\n * Push requests are sent when the client wants to synchronize local changes\n * with the server. They contain document changes and optionally presence updates\n * (like cursor position or user selection).\n *\n * @param R - The record type being synchronized (extends UnknownRecord)\n *\n * @example\n * ```ts\n * const pushRequest: TLPushRequest<MyRecord> = {\n *   type: 'push',\n *   clientClock: 15,\n *   diff: {\n *     'shape:abc123': [RecordOpType.Patch, { x: [ValueOpType.Put, 100] }]\n *   },\n *   presence: [RecordOpType.Put, { cursor: { x: 150, y: 200 } }]\n * }\n * socket.sendMessage(pushRequest)\n * ```\n *\n * @internal\n */\nexport interface TLPushRequest<R extends UnknownRecord> {\n\ttype: 'push'\n\tclientClock: number\n\tdiff?: NetworkDiff<R>\n\tpresence?: [typeof RecordOpType.Patch, ObjectDiff] | [typeof RecordOpType.Put, R]\n}\n\n/**\n * Interface defining a client-to-server connection request message.\n *\n * This message initiates a WebSocket connection to a sync room. It includes\n * the client's schema, protocol version, and last known server clock for\n * proper synchronization state management.\n *\n * @example\n * ```ts\n * const connectRequest: TLConnectRequest = {\n *   type: 'connect',\n *   connectRequestId: 'conn-123',\n *   lastServerClock: 42,\n *   protocolVersion: getTlsyncProtocolVersion(),\n *   schema: mySchema.serialize()\n * }\n * socket.sendMessage(connectRequest)\n * ```\n *\n * @internal\n */\nexport interface TLConnectRequest {\n\ttype: 'connect'\n\tconnectRequestId: string\n\tlastServerClock: number\n\tprotocolVersion: number\n\tschema: SerializedSchema\n}\n\n/**\n * Interface defining a client-to-server ping request message.\n *\n * Ping requests are used to measure network latency and ensure the connection\n * is still active. The server responds with a 'pong' message.\n *\n * @example\n * ```ts\n * const pingRequest: TLPingRequest = { type: 'ping' }\n * socket.sendMessage(pingRequest)\n *\n * // Server will respond with { type: 'pong' }\n * ```\n *\n * @internal\n */\nexport interface TLPingRequest {\n\ttype: 'ping'\n}\n\n/**\n * Union type representing all possible message types that can be sent from client to server.\n *\n * This encompasses the complete set of client-originated WebSocket messages in the tldraw\n * sync protocol, covering connection establishment, data synchronization, and connectivity checks.\n *\n * @param R - The record type being synchronized (extends UnknownRecord)\n *\n * @example\n * ```ts\n * function sendMessage(message: TLSocketClientSentEvent<MyRecord>) {\n *   switch (message.type) {\n *     case 'connect':\n *       console.log('Establishing connection...')\n *       break\n *     case 'push':\n *       console.log('Pushing changes:', message.diff)\n *       break\n *     case 'ping':\n *       console.log('Checking connection latency')\n *       break\n *   }\n *   socket.send(JSON.stringify(message))\n * }\n * ```\n *\n * @internal\n */\nexport type TLSocketClientSentEvent<R extends UnknownRecord> =\n\t| TLPushRequest<R>\n\t| TLConnectRequest\n\t| TLPingRequest\n"],"names":[],"mappings":";;;;;;AAGA,MAAM,0BAA0B;AAmBzB,SAAS,2BAA2B;IAC1C,OAAO;AACR;AAmBO,MAAM,0BAA0B;IACtC,cAAc;IACd,cAAc;IACd,eAAe;IACf,kBAAkB;AACnB","debugId":null}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/TLSyncClient.ts"],"sourcesContent":["import { Signal, react, transact } from '@tldraw/state'\nimport {\n\tRecordId,\n\tRecordsDiff,\n\tStore,\n\tUnknownRecord,\n\treverseRecordsDiff,\n\tsquashRecordDiffs,\n} from '@tldraw/store'\nimport {\n\texhaustiveSwitchError,\n\tfpsThrottle,\n\tisEqual,\n\tobjectMapEntries,\n\tuniqueId,\n} from '@tldraw/utils'\nimport { NetworkDiff, RecordOpType, applyObjectDiff, diffRecord, getNetworkDiff } from './diff'\nimport { interval } from './interval'\nimport {\n\tTLPushRequest,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/**\n * Function type for subscribing to events with a callback.\n * Returns an unsubscribe function to clean up the listener.\n *\n * @param cb - Callback function that receives the event value\n * @returns Function to call when you want to unsubscribe from the events\n *\n * @internal\n */\nexport type SubscribingFn<T> = (cb: (val: T) => void) => () => void\n\n/**\n * WebSocket close code used by the server to signal a non-recoverable sync error.\n * This close code indicates that the connection is being terminated due to an error\n * that cannot be automatically recovered from, such as authentication failures,\n * incompatible client versions, or invalid data.\n *\n * @example\n * ```ts\n * // Server-side: Close connection with specific error reason\n * socket.close(TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason.NOT_FOUND)\n *\n * // Client-side: Handle the error in your sync error handler\n * const syncClient = new TLSyncClient({\n *   // ... other config\n *   onSyncError: (reason) => {\n *     console.error('Sync failed:', reason) // Will receive 'NOT_FOUND'\n *   }\n * })\n * ```\n *\n * @public\n */\nexport const TLSyncErrorCloseEventCode = 4099 as const\n\n/**\n * Predefined reasons for server-initiated connection closures.\n * These constants represent different error conditions that can cause\n * the sync server to terminate a WebSocket connection.\n *\n * @example\n * ```ts\n * // Server usage\n * if (!user.hasPermission(roomId)) {\n *   socket.close(TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason.FORBIDDEN)\n * }\n *\n * // Client error handling\n * syncClient.onSyncError((reason) => {\n *   switch (reason) {\n *     case TLSyncErrorCloseEventReason.NOT_FOUND:\n *       showError('Room does not exist')\n *       break\n *     case TLSyncErrorCloseEventReason.FORBIDDEN:\n *       showError('Access denied')\n *       break\n *     case TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n *       showError('Please update your app')\n *       break\n *   }\n * })\n * ```\n *\n * @public\n */\nexport const TLSyncErrorCloseEventReason = {\n\t/** Room or resource not found */\n\tNOT_FOUND: 'NOT_FOUND',\n\t/** User lacks permission to access the room */\n\tFORBIDDEN: 'FORBIDDEN',\n\t/** User authentication required or invalid */\n\tNOT_AUTHENTICATED: 'NOT_AUTHENTICATED',\n\t/** Unexpected server error occurred */\n\tUNKNOWN_ERROR: 'UNKNOWN_ERROR',\n\t/** Client protocol version too old */\n\tCLIENT_TOO_OLD: 'CLIENT_TOO_OLD',\n\t/** Server protocol version too old */\n\tSERVER_TOO_OLD: 'SERVER_TOO_OLD',\n\t/** Client sent invalid or corrupted record data */\n\tINVALID_RECORD: 'INVALID_RECORD',\n\t/** Client exceeded rate limits */\n\tRATE_LIMITED: 'RATE_LIMITED',\n\t/** Room has reached maximum capacity */\n\tROOM_FULL: 'ROOM_FULL',\n} as const\n/**\n * Union type of all possible server connection close reasons.\n * Represents the string values that can be passed when a server closes\n * a sync connection due to an error condition.\n *\n * @public\n */\nexport type TLSyncErrorCloseEventReason =\n\t(typeof TLSyncErrorCloseEventReason)[keyof typeof TLSyncErrorCloseEventReason]\n\n/**\n * Handler function for custom application messages sent through the sync protocol.\n * These are user-defined messages that can be sent between clients via the sync server,\n * separate from the standard document synchronization messages.\n *\n * @param data - Custom message payload (application-defined structure)\n *\n * @example\n * ```ts\n * const customMessageHandler: TLCustomMessageHandler = (data) => {\n *   if (data.type === 'user_joined') {\n *     console.log(`${data.username} joined the session`)\n *     showToast(`${data.username} is now collaborating`)\n *   }\n * }\n *\n * const syncClient = new TLSyncClient({\n *   // ... other config\n *   onCustomMessageReceived: customMessageHandler\n * })\n * ```\n *\n * @public\n */\nexport type TLCustomMessageHandler = (this: null, data: any) => void\n\n/**\n * Event object describing changes in socket connection status.\n * Contains either a basic status change or an error with details.\n *\n * @internal\n */\nexport type TlSocketStatusChangeEvent =\n\t| {\n\t\t\t/** Connection came online or went offline */\n\t\t\tstatus: 'online' | 'offline'\n\t  }\n\t| {\n\t\t\t/** Connection encountered an error */\n\t\t\tstatus: 'error'\n\t\t\t/** Description of the error that occurred */\n\t\t\treason: string\n\t  }\n/**\n * Callback function type for listening to socket status changes.\n *\n * @param params - Event object containing the new status and optional error details\n *\n * @internal\n */\nexport type TLSocketStatusListener = (params: TlSocketStatusChangeEvent) => void\n\n/**\n * Possible connection states for a persistent client socket.\n * Represents the current connectivity status between client and server.\n *\n * @internal\n */\nexport type TLPersistentClientSocketStatus = 'online' | 'offline' | 'error'\n\n/**\n * Mode for handling presence information in sync sessions.\n * Controls whether presence data (cursors, selections) is shared with other clients.\n *\n * @internal\n */\nexport type TLPresenceMode =\n\t/** No presence sharing - client operates independently */\n\t| 'solo'\n\t/** Full presence sharing - cursors and selections visible to others */\n\t| 'full'\n/**\n * Interface for persistent WebSocket-like connections used by TLSyncClient.\n * Handles automatic reconnection and provides event-based communication with the sync server.\n * Implementations should maintain connection resilience and handle network interruptions gracefully.\n *\n * @example\n * ```ts\n * class MySocketAdapter implements TLPersistentClientSocket {\n *   connectionStatus: 'offline' | 'online' | 'error' = 'offline'\n *\n *   sendMessage(msg: TLSocketClientSentEvent) {\n *     if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n *       this.ws.send(JSON.stringify(msg))\n *     }\n *   }\n *\n *   onReceiveMessage = (callback) => {\n *     // Set up message listener and return cleanup function\n *   }\n *\n *   restart() {\n *     this.disconnect()\n *     this.connect()\n *   }\n * }\n * ```\n *\n * @internal\n */\nexport interface TLPersistentClientSocket<R extends UnknownRecord = UnknownRecord> {\n\t/** Current connection state - online means actively connected and ready */\n\tconnectionStatus: 'online' | 'offline' | 'error'\n\n\t/**\n\t * Send a protocol message to the sync server\n\t * @param msg - Message to send (connect, push, ping, etc.)\n\t */\n\tsendMessage(msg: TLSocketClientSentEvent<R>): void\n\n\t/**\n\t * Subscribe to messages received from the server\n\t * @param callback - Function called for each received message\n\t * @returns Cleanup function to remove the listener\n\t */\n\tonReceiveMessage: SubscribingFn<TLSocketServerSentEvent<R>>\n\n\t/**\n\t * Subscribe to connection status changes\n\t * @param callback - Function called when connection status changes\n\t * @returns Cleanup function to remove the listener\n\t */\n\tonStatusChange: SubscribingFn<TlSocketStatusChangeEvent>\n\n\t/**\n\t * Force a connection restart (disconnect then reconnect)\n\t * Used for error recovery or when connection health checks fail\n\t */\n\trestart(): void\n}\n\nconst PING_INTERVAL = 5000\nconst MAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION = PING_INTERVAL * 2\n\n// Should connect support chunking the response to allow for large payloads?\n\n/**\n * Main client-side synchronization engine for collaborative tldraw applications.\n *\n * TLSyncClient manages bidirectional synchronization between a local tldraw Store\n * and a remote sync server. It uses an optimistic update model where local changes\n * are immediately applied for responsive UI, then sent to the server for validation\n * and distribution to other clients.\n *\n * The synchronization follows a git-like push/pull/rebase model:\n * - **Push**: Local changes are sent to server as diff operations\n * - **Pull**: Server changes are received and applied locally\n * - **Rebase**: Conflicting changes are resolved by undoing local changes,\n *   applying server changes, then re-applying local changes on top\n *\n * @example\n * ```ts\n * import { TLSyncClient, ClientWebSocketAdapter } from '@tldraw/sync-core'\n * import { createTLStore } from '@tldraw/store'\n *\n * // Create store and socket\n * const store = createTLStore({ schema: mySchema })\n * const socket = new ClientWebSocketAdapter('ws://localhost:3000/sync')\n *\n * // Create sync client\n * const syncClient = new TLSyncClient({\n *   store,\n *   socket,\n *   presence: atom(null),\n *   onLoad: () => console.log('Connected and loaded'),\n *   onSyncError: (reason) => console.error('Sync failed:', reason)\n * })\n *\n * // Changes to store are now automatically synchronized\n * store.put([{ id: 'shape1', type: 'geo', x: 100, y: 100 }])\n * ```\n *\n * @example\n * ```ts\n * // Advanced usage with presence and custom messages\n * const syncClient = new TLSyncClient({\n *   store,\n *   socket,\n *   presence: atom({ cursor: { x: 0, y: 0 }, userName: 'Alice' }),\n *   presenceMode: atom('full'),\n *   onCustomMessageReceived: (data) => {\n *     if (data.type === 'chat') {\n *       showChatMessage(data.message, data.from)\n *     }\n *   },\n *   onAfterConnect: (client, { isReadonly }) => {\n *     if (isReadonly) {\n *       showNotification('Connected in read-only mode')\n *     }\n *   }\n * })\n * ```\n *\n * @internal\n */\nexport class TLSyncClient<R extends UnknownRecord, S extends Store<R> = Store<R>> {\n\t/** The last clock time from the most recent server update */\n\tprivate lastServerClock = -1\n\tprivate lastServerInteractionTimestamp = Date.now()\n\n\t/** The queue of in-flight push requests that have not yet been acknowledged by the server */\n\tprivate pendingPushRequests: { request: TLPushRequest<R>; sent: boolean }[] = []\n\n\t/**\n\t * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we\n\t * take this diff, reverse it, and apply that to the store, our store will match exactly the most\n\t * recent state of the server that we know about\n\t */\n\tprivate speculativeChanges: RecordsDiff<R> = {\n\t\tadded: {} as any,\n\t\tupdated: {} as any,\n\t\tremoved: {} as any,\n\t}\n\n\tprivate disposables: Array<() => void> = []\n\n\treadonly store: S\n\treadonly socket: TLPersistentClientSocket<R>\n\n\treadonly presenceState: Signal<R | null> | undefined\n\treadonly presenceMode: Signal<TLPresenceMode> | undefined\n\n\t// isOnline is true when we have an open socket connection and we have\n\t// established a connection with the server room (i.e. we have received a 'connect' message)\n\tisConnectedToRoom = false\n\n\t/**\n\t * The client clock is essentially a counter for push requests Each time a push request is created\n\t * the clock is incremented. This clock is sent with the push request to the server, and the\n\t * server returns it with the response so that we can match up the response with the request.\n\t *\n\t * The clock may also be used at one point in the future to allow the client to re-send push\n\t * requests idempotently (i.e. the server will keep track of each client's clock and not execute\n\t * requests it has already handled), but at the time of writing this is neither needed nor\n\t * implemented.\n\t */\n\tprivate clientClock = 0\n\n\t/**\n\t * Callback executed immediately after successful connection to sync room.\n\t * Use this to perform any post-connection setup required for your application,\n\t * such as initializing default content or updating UI state.\n\t *\n\t * @param self - The TLSyncClient instance that connected\n\t * @param details - Connection details\n\t *   - isReadonly - Whether the connection is in read-only mode\n\t */\n\tpublic readonly onAfterConnect?: (self: this, details: { isReadonly: boolean }) => void\n\n\tprivate readonly onCustomMessageReceived?: TLCustomMessageHandler\n\n\tprivate isDebugging = false\n\tprivate debug(...args: any[]) {\n\t\tif (this.isDebugging) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(...args)\n\t\t}\n\t}\n\n\tprivate readonly presenceType: R['typeName'] | null\n\n\tdidCancel?: () => boolean\n\n\t/**\n\t * Creates a new TLSyncClient instance to manage synchronization with a remote server.\n\t *\n\t * @param config - Configuration object for the sync client\n\t *   - store - The local tldraw store to synchronize\n\t *   - socket - WebSocket adapter for server communication\n\t *   - presence - Reactive signal containing current user's presence data\n\t *   - presenceMode - Optional signal controlling presence sharing (defaults to 'full')\n\t *   - onLoad - Callback fired when initial sync completes successfully\n\t *   - onSyncError - Callback fired when sync fails with error reason\n\t *   - onCustomMessageReceived - Optional handler for custom messages\n\t *   - onAfterConnect - Optional callback fired after successful connection\n\t *   - self - The TLSyncClient instance\n\t *   - details - Connection details including readonly status\n\t *   - didCancel - Optional function to check if sync should be cancelled\n\t */\n\tconstructor(config: {\n\t\tstore: S\n\t\tsocket: TLPersistentClientSocket<R>\n\t\tpresence: Signal<R | null>\n\t\tpresenceMode?: Signal<TLPresenceMode>\n\t\tonLoad(self: TLSyncClient<R, S>): void\n\t\tonSyncError(reason: string): void\n\t\tonCustomMessageReceived?: TLCustomMessageHandler\n\t\tonAfterConnect?(self: TLSyncClient<R, S>, details: { isReadonly: boolean }): void\n\t\tdidCancel?(): boolean\n\t}) {\n\t\tthis.didCancel = config.didCancel\n\n\t\tthis.presenceType = config.store.scopedTypes.presence.values().next().value ?? null\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\t;(window as any).tlsync = this\n\t\t}\n\t\tthis.store = config.store\n\t\tthis.socket = config.socket\n\t\tthis.onAfterConnect = config.onAfterConnect\n\t\tthis.onCustomMessageReceived = config.onCustomMessageReceived\n\n\t\tlet didLoad = false\n\n\t\tthis.presenceState = config.presence\n\t\tthis.presenceMode = config.presenceMode\n\n\t\tthis.disposables.push(\n\t\t\t// when local 'user' changes are made, send them to the server\n\t\t\t// or stash them locally in offline mode\n\t\t\tthis.store.listen(\n\t\t\t\t({ changes }) => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tthis.debug('received store changes', { changes })\n\t\t\t\t\tthis.push(changes)\n\t\t\t\t},\n\t\t\t\t{ source: 'user', scope: 'document' }\n\t\t\t),\n\t\t\t// when the server sends us events, handle them\n\t\t\tthis.socket.onReceiveMessage((msg) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('received message from server', msg)\n\t\t\t\tthis.handleServerEvent(msg)\n\t\t\t\t// the first time we receive a message from the server, we should trigger\n\n\t\t\t\t// one of the load callbacks\n\t\t\t\tif (!didLoad) {\n\t\t\t\t\tdidLoad = true\n\t\t\t\t\tconfig.onLoad(this)\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// handle switching between online and offline\n\t\t\tthis.socket.onStatusChange((ev) => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('socket status changed', ev.status)\n\t\t\t\tif (ev.status === 'online') {\n\t\t\t\t\tthis.sendConnectMessage()\n\t\t\t\t} else {\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t\tif (ev.status === 'error') {\n\t\t\t\t\t\tdidLoad = true\n\t\t\t\t\t\tconfig.onSyncError(ev.reason)\n\t\t\t\t\t\tthis.close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\t// Send a ping every PING_INTERVAL ms while online\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('ping loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\ttry {\n\t\t\t\t\tthis.socket.sendMessage({ type: 'ping' })\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn('ping failed, resetting', error)\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t}, PING_INTERVAL),\n\t\t\t// Check the server connection health, reset the connection if needed\n\t\t\tinterval(() => {\n\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\tthis.debug('health check loop', { isConnectedToRoom: this.isConnectedToRoom })\n\t\t\t\tif (!this.isConnectedToRoom) return\n\t\t\t\tconst timeSinceLastServerInteraction = Date.now() - this.lastServerInteractionTimestamp\n\n\t\t\t\tif (\n\t\t\t\t\ttimeSinceLastServerInteraction <\n\t\t\t\t\tMAX_TIME_TO_WAIT_FOR_SERVER_INTERACTION_BEFORE_RESETTING_CONNECTION\n\t\t\t\t) {\n\t\t\t\t\tthis.debug('health check passed', { timeSinceLastServerInteraction })\n\t\t\t\t\t// last ping was recent, so no need to take any action\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconsole.warn(`Haven't heard from the server in a while, resetting connection...`)\n\t\t\t\tthis.resetConnection()\n\t\t\t}, PING_INTERVAL * 2)\n\t\t)\n\n\t\tif (this.presenceState) {\n\t\t\tthis.disposables.push(\n\t\t\t\treact('pushPresence', () => {\n\t\t\t\t\tif (this.didCancel?.()) return this.close()\n\t\t\t\t\tconst mode = this.presenceMode?.get()\n\t\t\t\t\tif (mode !== 'full') return\n\t\t\t\t\tthis.pushPresence(this.presenceState!.get())\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\t// if the socket is already online before this client was instantiated\n\t\t// then we should send a connect message right away\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.sendConnectMessage()\n\t\t}\n\t}\n\n\tlatestConnectRequestId: string | null = null\n\n\t/**\n\t * This is the first message that is sent over a newly established socket connection. And we need\n\t * to wait for the response before this client can be used.\n\t */\n\tprivate sendConnectMessage() {\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('sendConnectMessage called while already connected')\n\t\t\treturn\n\t\t}\n\t\tthis.debug('sending connect message')\n\t\tthis.latestConnectRequestId = uniqueId()\n\t\tthis.socket.sendMessage({\n\t\t\ttype: 'connect',\n\t\t\tconnectRequestId: this.latestConnectRequestId,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\tlastServerClock: this.lastServerClock,\n\t\t})\n\t}\n\n\t/** Switch to offline mode */\n\tprivate resetConnection(hard = false) {\n\t\tthis.debug('resetting connection')\n\t\tif (hard) {\n\t\t\tthis.lastServerClock = 0\n\t\t}\n\t\t// kill all presence state\n\t\tconst keys = Object.keys(this.store.serialize('presence')) as any\n\t\tif (keys.length > 0) {\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\tthis.store.remove(keys)\n\t\t\t})\n\t\t}\n\t\tthis.lastPushedPresenceState = null\n\t\tthis.isConnectedToRoom = false\n\t\tthis.pendingPushRequests = []\n\t\tthis.incomingDiffBuffer = []\n\t\tif (this.socket.connectionStatus === 'online') {\n\t\t\tthis.socket.restart()\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the socket connection comes online, either for the first time or as the result of\n\t * a reconnect. The goal is to rebase on the server's state and fire off a new push request for\n\t * any local changes that were made while offline.\n\t */\n\tprivate didReconnect(event: Extract<TLSocketServerSentEvent<R>, { type: 'connect' }>) {\n\t\tthis.debug('did reconnect', event)\n\t\tif (event.connectRequestId !== this.latestConnectRequestId) {\n\t\t\t// ignore connect events for old connect requests\n\t\t\treturn\n\t\t}\n\t\tthis.latestConnectRequestId = null\n\n\t\tif (this.isConnectedToRoom) {\n\t\t\tconsole.error('didReconnect called while already connected')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\tif (this.pendingPushRequests.length > 0) {\n\t\t\tconsole.error('pendingPushRequests should already be empty when we reconnect')\n\t\t\tthis.resetConnection(true)\n\t\t\treturn\n\t\t}\n\t\t// at the end of this process we want to have at most one pending push request\n\t\t// based on anything inside this.speculativeChanges\n\t\ttransact(() => {\n\t\t\t// Now our goal is to rebase on the server's state.\n\t\t\t// This means wiping away any peer presence data, which the server will replace in full on every connect.\n\t\t\t// If the server does not have enough history to give us a partial document state hydration we will\n\t\t\t// also need to wipe away all of our document state before hydrating with the server's state from scratch.\n\t\t\tconst stashedChanges = this.speculativeChanges\n\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// gather records to delete in a NetworkDiff\n\t\t\t\tconst wipeDiff: NetworkDiff<R> = {}\n\t\t\t\tconst wipeAll = event.hydrationType === 'wipe_all'\n\t\t\t\tif (!wipeAll) {\n\t\t\t\t\t// if we're only wiping presence data, undo the speculative changes first\n\t\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(stashedChanges), { runCallbacks: false })\n\t\t\t\t}\n\n\t\t\t\t// now wipe all presence data and, if needed, all document data\n\t\t\t\tfor (const [id, record] of objectMapEntries(this.store.serialize('all'))) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(wipeAll && this.store.scopedTypes.document.has(record.typeName)) ||\n\t\t\t\t\t\trecord.typeName === this.presenceType\n\t\t\t\t\t) {\n\t\t\t\t\t\twipeDiff[id] = [RecordOpType.Remove]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// then apply the upstream changes\n\t\t\t\tthis.applyNetworkDiff({ ...wipeDiff, ...event.diff }, true)\n\n\t\t\t\tthis.isConnectedToRoom = true\n\n\t\t\t\t// now re-apply the speculative changes creating a new push request with the\n\t\t\t\t// appropriate diff\n\t\t\t\tconst speculativeChanges = this.store.filterChangesByScope(\n\t\t\t\t\tthis.store.extractingChanges(() => {\n\t\t\t\t\t\tthis.store.applyDiff(stashedChanges)\n\t\t\t\t\t}),\n\t\t\t\t\t'document'\n\t\t\t\t)\n\t\t\t\tif (speculativeChanges) this.push(speculativeChanges)\n\t\t\t})\n\n\t\t\t// this.isConnectedToRoom = true\n\t\t\t// this.store.applyDiff(stashedChanges, false)\n\n\t\t\tthis.onAfterConnect?.(this, { isReadonly: event.isReadonly })\n\t\t\tconst presence = this.presenceState?.get()\n\t\t\tif (presence) {\n\t\t\t\tthis.pushPresence(presence)\n\t\t\t}\n\t\t})\n\n\t\tthis.lastServerClock = event.serverClock\n\t}\n\n\tincomingDiffBuffer: TLSocketServerSentDataEvent<R>[] = []\n\n\t/** Handle events received from the server */\n\tprivate handleServerEvent(event: TLSocketServerSentEvent<R>) {\n\t\tthis.debug('received server event', event)\n\t\tthis.lastServerInteractionTimestamp = Date.now()\n\t\t// always update the lastServerClock when it is present\n\t\tswitch (event.type) {\n\t\t\tcase 'connect':\n\t\t\t\tthis.didReconnect(event)\n\t\t\t\tbreak\n\t\t\t// legacy v4 events\n\t\t\tcase 'patch':\n\t\t\tcase 'push_result':\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(event)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'data':\n\t\t\t\t// wait for a connect to succeed before processing more events\n\t\t\t\tif (!this.isConnectedToRoom) break\n\t\t\t\tthis.incomingDiffBuffer.push(...event.data)\n\t\t\t\tthis.scheduleRebase()\n\t\t\t\tbreak\n\t\t\tcase 'incompatibility_error':\n\t\t\t\t// legacy unrecoverable errors\n\t\t\t\tconsole.error('incompatibility error is legacy and should no longer be sent by the server')\n\t\t\t\tbreak\n\t\t\tcase 'pong':\n\t\t\t\t// noop, we only use ping/pong to set lastSeverInteractionTimestamp\n\t\t\t\tbreak\n\t\t\tcase 'custom':\n\t\t\t\tthis.onCustomMessageReceived?.call(null, event.data)\n\t\t\t\tbreak\n\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(event)\n\t\t}\n\t}\n\n\t/**\n\t * Closes the sync client and cleans up all resources.\n\t *\n\t * Call this method when you no longer need the sync client to prevent\n\t * memory leaks and close the WebSocket connection. After calling close(),\n\t * the client cannot be reused.\n\t *\n\t * @example\n\t * ```ts\n\t * // Clean shutdown\n\t * syncClient.close()\n\t * ```\n\t */\n\tclose() {\n\t\tthis.debug('closing')\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.flushPendingPushRequests.cancel?.()\n\t\tthis.scheduleRebase.cancel?.()\n\t}\n\n\tlastPushedPresenceState: R | null = null\n\n\tprivate pushPresence(nextPresence: R | null) {\n\t\t// make sure we push any document changes first\n\t\tthis.store._flushHistory()\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// if we're offline, don't do anything\n\t\t\treturn\n\t\t}\n\n\t\tlet presence: TLPushRequest<any>['presence'] = undefined\n\t\tif (!this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we don't have a last presence state, so we need to push the full state\n\t\t\tpresence = [RecordOpType.Put, nextPresence]\n\t\t} else if (this.lastPushedPresenceState && nextPresence) {\n\t\t\t// we have a last presence state, so we need to push a diff if there is one\n\t\t\tconst diff = diffRecord(this.lastPushedPresenceState, nextPresence)\n\t\t\tif (diff) {\n\t\t\t\tpresence = [RecordOpType.Patch, diff]\n\t\t\t}\n\t\t}\n\n\t\tif (!presence) return\n\t\tthis.lastPushedPresenceState = nextPresence\n\n\t\t// if there is a pending push that has not been sent and does not already include a presence update,\n\t\t// then add this presence update to it\n\t\tconst lastPush = this.pendingPushRequests.at(-1)\n\t\tif (lastPush && !lastPush.sent && !lastPush.request.presence) {\n\t\t\tlastPush.request.presence = presence\n\t\t\treturn\n\t\t}\n\n\t\t// otherwise, create a new push request\n\t\tconst req: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tclientClock: this.clientClock++,\n\t\t\tpresence,\n\t\t}\n\n\t\tif (req) {\n\t\t\tthis.pendingPushRequests.push({ request: req, sent: false })\n\t\t\tthis.flushPendingPushRequests()\n\t\t}\n\t}\n\n\t/** Push a change to the server, or stash it locally if we're offline */\n\tprivate push(change: RecordsDiff<any>) {\n\t\tthis.debug('push', change)\n\t\t// the Store doesn't do deep equality checks when making changes\n\t\t// so it's possible that the diff passed in here is actually a no-op.\n\t\t// either way, we also don't want to send whole objects over the wire if\n\t\t// only small parts of them have changed, so we'll do a shallow-ish diff\n\t\t// which also uses deep equality checks to see if the change is actually\n\t\t// a no-op.\n\t\tconst diff = getNetworkDiff(change)\n\t\tif (!diff) return\n\n\t\t// the change is not a no-op so we'll send it to the server\n\t\t// but first let's merge the records diff into the speculative changes\n\t\tthis.speculativeChanges = squashRecordDiffs([this.speculativeChanges, change])\n\n\t\tif (!this.isConnectedToRoom) {\n\t\t\t// don't sent push requests or even store them up while offline\n\t\t\t// when we come back online we'll generate another push request from\n\t\t\t// scratch based on the speculativeChanges diff\n\t\t\treturn\n\t\t}\n\n\t\tconst pushRequest: TLPushRequest<R> = {\n\t\t\ttype: 'push',\n\t\t\tdiff,\n\t\t\tclientClock: this.clientClock++,\n\t\t}\n\n\t\tthis.pendingPushRequests.push({ request: pushRequest, sent: false })\n\n\t\t// immediately calling .send on the websocket here was causing some interaction\n\t\t// slugishness when e.g. drawing or translating shapes. Seems like it blocks\n\t\t// until the send completes. So instead we'll schedule a send to happen on some\n\t\t// tick in the near future.\n\t\tthis.flushPendingPushRequests()\n\t}\n\n\t/** Send any unsent push requests to the server */\n\tprivate flushPendingPushRequests = fpsThrottle(() => {\n\t\tthis.debug('flushing pending push requests', {\n\t\t\tisConnectedToRoom: this.isConnectedToRoom,\n\t\t\tpendingPushRequests: this.pendingPushRequests,\n\t\t})\n\t\tif (!this.isConnectedToRoom || this.store.isPossiblyCorrupted()) {\n\t\t\treturn\n\t\t}\n\t\tfor (const pendingPushRequest of this.pendingPushRequests) {\n\t\t\tif (!pendingPushRequest.sent) {\n\t\t\t\tif (this.socket.connectionStatus !== 'online') {\n\t\t\t\t\t// we went offline, so don't send anything\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.socket.sendMessage(pendingPushRequest.request)\n\t\t\t\tpendingPushRequest.sent = true\n\t\t\t}\n\t\t}\n\t})\n\n\t/**\n\t * Applies a 'network' diff to the store this does value-based equality checking so that if the\n\t * data is the same (as opposed to merely identical with ===), then no change is made and no\n\t * changes will be propagated back to store listeners\n\t */\n\tprivate applyNetworkDiff(diff: NetworkDiff<R>, runCallbacks: boolean) {\n\t\tthis.debug('applyNetworkDiff', diff)\n\t\tconst changes: RecordsDiff<R> = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\ttype k = keyof typeof changes.updated\n\t\tlet hasChanges = false\n\t\tfor (const [id, op] of objectMapEntries(diff)) {\n\t\t\tif (op[0] === RecordOpType.Put) {\n\t\t\t\tconst existing = this.store.get(id as RecordId<any>)\n\t\t\t\tif (existing && !isEqual(existing, op[1])) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.updated[id as k] = [existing, op[1]]\n\t\t\t\t} else {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.added[id as k] = op[1]\n\t\t\t\t}\n\t\t\t} else if (op[0] === RecordOpType.Patch) {\n\t\t\t\tconst record = this.store.get(id as RecordId<any>)\n\t\t\t\tif (!record) {\n\t\t\t\t\t// the record was removed upstream\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst patched = applyObjectDiff(record, op[1])\n\t\t\t\thasChanges = true\n\t\t\t\tchanges.updated[id as k] = [record, patched]\n\t\t\t} else if (op[0] === RecordOpType.Remove) {\n\t\t\t\tif (this.store.has(id as RecordId<any>)) {\n\t\t\t\t\thasChanges = true\n\t\t\t\t\tchanges.removed[id as k] = this.store.get(id as RecordId<any>)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasChanges) {\n\t\t\tthis.store.applyDiff(changes, { runCallbacks })\n\t\t}\n\t}\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate rebase = () => {\n\t\t// need to make sure that our speculative changes are in sync with the actual store instance before\n\t\t// proceeding, to avoid inconsistency bugs.\n\t\tthis.store._flushHistory()\n\t\tif (this.incomingDiffBuffer.length === 0) return\n\n\t\tconst diffs = this.incomingDiffBuffer\n\t\tthis.incomingDiffBuffer = []\n\n\t\ttry {\n\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t// first undo speculative changes\n\t\t\t\tthis.store.applyDiff(reverseRecordsDiff(this.speculativeChanges), { runCallbacks: false })\n\n\t\t\t\t// then apply network diffs on top of known-to-be-synced data\n\t\t\t\tfor (const diff of diffs) {\n\t\t\t\t\tif (diff.type === 'patch') {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.diff, true)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// handling push_result\n\t\t\t\t\tif (this.pendingPushRequests.length === 0) {\n\t\t\t\t\t\tthrow new Error('Received push_result but there are no pending push requests')\n\t\t\t\t\t}\n\t\t\t\t\tif (this.pendingPushRequests[0].request.clientClock !== diff.clientClock) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Received push_result for a push request that is not at the front of the queue'\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.action === 'discard') {\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t} else if (diff.action === 'commit') {\n\t\t\t\t\t\tconst { request } = this.pendingPushRequests.shift()!\n\t\t\t\t\t\tif ('diff' in request && request.diff) {\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.applyNetworkDiff(diff.action.rebaseWithDiff, true)\n\t\t\t\t\t\tthis.pendingPushRequests.shift()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update the speculative diff while re-applying pending changes\n\t\t\t\ttry {\n\t\t\t\t\tthis.speculativeChanges = this.store.extractingChanges(() => {\n\t\t\t\t\t\tfor (const { request } of this.pendingPushRequests) {\n\t\t\t\t\t\t\tif (!('diff' in request) || !request.diff) continue\n\t\t\t\t\t\t\tthis.applyNetworkDiff(request.diff, true)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e)\n\t\t\t\t\t// throw away the speculative changes and start over\n\t\t\t\t\tthis.speculativeChanges = { added: {} as any, updated: {} as any, removed: {} as any }\n\t\t\t\t\tthis.resetConnection()\n\t\t\t\t}\n\t\t\t})\n\t\t\tthis.lastServerClock = diffs.at(-1)?.serverClock ?? this.lastServerClock\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.resetConnection()\n\t\t}\n\t}\n\n\tprivate scheduleRebase = fpsThrottle(this.rebase)\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 973, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/ClientWebSocketAdapter.ts"],"sourcesContent":["import { atom, Atom } from '@tldraw/state'\nimport { TLRecord } from '@tldraw/tlschema'\nimport { assert, warnOnce } from '@tldraw/utils'\nimport { chunk } from './chunk'\nimport { TLSocketClientSentEvent, TLSocketServerSentEvent } from './protocol'\nimport {\n\tTLPersistentClientSocket,\n\tTLPersistentClientSocketStatus,\n\tTLSocketStatusListener,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n} from './TLSyncClient'\n\nfunction listenTo<T extends EventTarget>(target: T, event: string, handler: () => void) {\n\ttarget.addEventListener(event, handler)\n\treturn () => {\n\t\ttarget.removeEventListener(event, handler)\n\t}\n}\n\nfunction debug(...args: any[]) {\n\t// @ts-ignore\n\tif (typeof window !== 'undefined' && window.__tldraw_socket_debug) {\n\t\tconst now = new Date()\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(\n\t\t\t`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`,\n\t\t\t...args\n\t\t\t//, new Error().stack\n\t\t)\n\t}\n}\n\n// NOTE: ClientWebSocketAdapter requires its users to implement their own connection loss\n//       detection, for example by regularly pinging the server and .restart()ing\n//       the connection when a number of pings goes unanswered. Without this mechanism,\n//       we might not be able to detect the websocket connection going down in a timely manner\n//       (it will probably time out on outgoing data packets at some point).\n//\n//       This is by design. While the Websocket protocol specifies protocol-level pings,\n//       they don't seem to be surfaced in browser APIs and can't be relied on. Therefore,\n//       pings need to be implemented one level up, on the application API side, which for our\n//       codebase means whatever code that uses ClientWebSocketAdapter.\n/**\n * A WebSocket adapter that provides persistent connection management for tldraw synchronization.\n * This adapter handles connection establishment, reconnection logic, and message routing between\n * the sync client and server. It implements automatic reconnection with exponential backoff\n * and supports connection loss detection.\n *\n * Note: This adapter requires users to implement their own connection loss detection (e.g., pings)\n * as browser WebSocket APIs don't reliably surface protocol-level ping/pong frames.\n *\n * @internal\n * @example\n * ```ts\n * // Create a WebSocket adapter with connection URI\n * const adapter = new ClientWebSocketAdapter(() => 'ws://localhost:3000/sync')\n *\n * // Listen for connection status changes\n * adapter.onStatusChange((status) => {\n *   console.log('Connection status:', status)\n * })\n *\n * // Listen for incoming messages\n * adapter.onReceiveMessage((message) => {\n *   console.log('Received:', message)\n * })\n *\n * // Send a message when connected\n * if (adapter.connectionStatus === 'online') {\n *   adapter.sendMessage({ type: 'ping' })\n * }\n * ```\n */\nexport class ClientWebSocketAdapter implements TLPersistentClientSocket<TLRecord> {\n\t_ws: WebSocket | null = null\n\n\tisDisposed = false\n\n\t/** @internal */\n\treadonly _reconnectManager: ReconnectManager\n\n\t/**\n\t * Permanently closes the WebSocket adapter and disposes of all resources.\n\t * Once closed, the adapter cannot be reused and should be discarded.\n\t * This method is idempotent - calling it multiple times has no additional effect.\n\t */\n\t// TODO: .close should be a project-wide interface with a common contract (.close()d thing\n\t//       can only be garbage collected, and can't be used anymore)\n\tclose() {\n\t\tthis.isDisposed = true\n\t\tthis._reconnectManager.close()\n\t\t//  WebSocket.close() is idempotent\n\t\tthis._ws?.close()\n\t}\n\n\t/**\n\t * Creates a new ClientWebSocketAdapter instance.\n\t *\n\t * @param getUri - Function that returns the WebSocket URI to connect to.\n\t *                 Can return a string directly or a Promise that resolves to a string.\n\t *                 This function is called each time a connection attempt is made,\n\t *                 allowing for dynamic URI generation (e.g., for authentication tokens).\n\t */\n\tconstructor(getUri: () => Promise<string> | string) {\n\t\tthis._reconnectManager = new ReconnectManager(this, getUri)\n\t}\n\n\tprivate _handleConnect() {\n\t\tdebug('handleConnect')\n\n\t\tthis._connectionStatus.set('online')\n\t\tthis.statusListeners.forEach((cb) => cb({ status: 'online' }))\n\n\t\tthis._reconnectManager.connected()\n\t}\n\n\tprivate _handleDisconnect(\n\t\treason: 'closed' | 'manual',\n\t\tcloseCode?: number,\n\t\tdidOpen?: boolean,\n\t\tcloseReason?: string\n\t) {\n\t\tcloseReason = closeReason || TLSyncErrorCloseEventReason.UNKNOWN_ERROR\n\n\t\tdebug('handleDisconnect', {\n\t\t\tcurrentStatus: this.connectionStatus,\n\t\t\tcloseCode,\n\t\t\treason,\n\t\t})\n\n\t\tlet newStatus: 'offline' | 'error'\n\t\tswitch (reason) {\n\t\t\tcase 'closed':\n\t\t\t\tif (closeCode === TLSyncErrorCloseEventCode) {\n\t\t\t\t\tnewStatus = 'error'\n\t\t\t\t} else {\n\t\t\t\t\tnewStatus = 'offline'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'manual':\n\t\t\t\tnewStatus = 'offline'\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (closeCode === 1006 && !didOpen) {\n\t\t\twarnOnce(\n\t\t\t\t\"Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to.\"\n\t\t\t)\n\t\t}\n\n\t\tif (\n\t\t\t// it the status changed\n\t\t\tthis.connectionStatus !== newStatus &&\n\t\t\t// ignore errors if we're already in the offline state\n\t\t\t!(newStatus === 'error' && this.connectionStatus === 'offline')\n\t\t) {\n\t\t\tthis._connectionStatus.set(newStatus)\n\t\t\tthis.statusListeners.forEach((cb) =>\n\t\t\t\tcb(newStatus === 'error' ? { status: 'error', reason: closeReason } : { status: newStatus })\n\t\t\t)\n\t\t}\n\n\t\tthis._reconnectManager.disconnected()\n\t}\n\n\t_setNewSocket(ws: WebSocket) {\n\t\tassert(!this.isDisposed, 'Tried to set a new websocket on a disposed socket')\n\t\tassert(\n\t\t\tthis._ws === null ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSED ||\n\t\t\t\tthis._ws.readyState === WebSocket.CLOSING,\n\t\t\t`Tried to set a new websocket in when the existing one was ${this._ws?.readyState}`\n\t\t)\n\n\t\tlet didOpen = false\n\n\t\t// NOTE: Sockets can stay for quite a while in the CLOSING state. This is because the transition\n\t\t//       between CLOSING and CLOSED happens either after the closing handshake, or after a\n\t\t//       timeout, but in either case those sockets don't need any special handling, the browser\n\t\t//       will close them eventually. We just \"orphan\" such sockets and ignore their onclose/onerror.\n\t\tws.onopen = () => {\n\t\t\tdebug('ws.onopen')\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open\"\n\t\t\t)\n\t\t\tdidOpen = true\n\t\t\tthis._handleConnect()\n\t\t}\n\t\tws.onclose = (event: CloseEvent) => {\n\t\t\tdebug('ws.onclose', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed', event.code, didOpen, event.reason)\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onclose for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onerror = (event) => {\n\t\t\tdebug('ws.onerror', event)\n\t\t\tif (this._ws === ws) {\n\t\t\t\tthis._handleDisconnect('closed')\n\t\t\t} else {\n\t\t\t\tdebug('ignoring onerror for an orphaned socket')\n\t\t\t}\n\t\t}\n\t\tws.onmessage = (ev) => {\n\t\t\tassert(\n\t\t\t\tthis._ws === ws,\n\t\t\t\t\"sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages\"\n\t\t\t)\n\t\t\tconst parsed = JSON.parse(ev.data.toString())\n\t\t\tthis.messageListeners.forEach((cb) => cb(parsed))\n\t\t}\n\n\t\tthis._ws = ws\n\t}\n\n\t_closeSocket() {\n\t\tif (this._ws === null) return\n\n\t\tthis._ws.close()\n\t\t// explicitly orphan the socket to ignore its onclose/onerror, because onclose can be delayed\n\t\tthis._ws = null\n\t\tthis._handleDisconnect('manual')\n\t}\n\n\t// TLPersistentClientSocket stuff\n\n\t_connectionStatus: Atom<TLPersistentClientSocketStatus | 'initial'> = atom(\n\t\t'websocket connection status',\n\t\t'initial'\n\t)\n\n\t/**\n\t * Gets the current connection status of the WebSocket.\n\t *\n\t * @returns The current connection status: 'online', 'offline', or 'error'\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget connectionStatus(): TLPersistentClientSocketStatus {\n\t\tconst status = this._connectionStatus.get()\n\t\treturn status === 'initial' ? 'offline' : status\n\t}\n\n\t/**\n\t * Sends a message to the server through the WebSocket connection.\n\t * Messages are automatically chunked if they exceed size limits.\n\t *\n\t * @param msg - The message to send to the server\n\t *\n\t * @example\n\t * ```ts\n\t * adapter.sendMessage({\n\t *   type: 'push',\n\t *   diff: { 'shape:abc123': [2, { x: [1, 150] }] }\n\t * })\n\t * ```\n\t */\n\tsendMessage(msg: TLSocketClientSentEvent<TLRecord>) {\n\t\tassert(!this.isDisposed, 'Tried to send message on a disposed socket')\n\n\t\tif (!this._ws) return\n\t\tif (this.connectionStatus === 'online') {\n\t\t\tconst chunks = chunk(JSON.stringify(msg))\n\t\t\tfor (const part of chunks) {\n\t\t\t\tthis._ws.send(part)\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('Tried to send message while ' + this.connectionStatus)\n\t\t}\n\t}\n\n\tprivate messageListeners = new Set<(msg: TLSocketServerSentEvent<TLRecord>) => void>()\n\t/**\n\t * Registers a callback to handle incoming messages from the server.\n\t *\n\t * @param cb - Callback function that will be called with each received message\n\t * @returns A cleanup function to remove the message listener\n\t *\n\t * @example\n\t * ```ts\n\t * const unsubscribe = adapter.onReceiveMessage((message) => {\n\t *   switch (message.type) {\n\t *     case 'connect':\n\t *       console.log('Connected to room')\n\t *       break\n\t *     case 'data':\n\t *       console.log('Received data:', message.diff)\n\t *       break\n\t *   }\n\t * })\n\t *\n\t * // Later, remove the listener\n\t * unsubscribe()\n\t * ```\n\t */\n\tonReceiveMessage(cb: (val: TLSocketServerSentEvent<TLRecord>) => void) {\n\t\tassert(!this.isDisposed, 'Tried to add message listener on a disposed socket')\n\n\t\tthis.messageListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.messageListeners.delete(cb)\n\t\t}\n\t}\n\n\tprivate statusListeners = new Set<TLSocketStatusListener>()\n\t/**\n\t * Registers a callback to handle connection status changes.\n\t *\n\t * @param cb - Callback function that will be called when the connection status changes\n\t * @returns A cleanup function to remove the status listener\n\t *\n\t * @example\n\t * ```ts\n\t * const unsubscribe = adapter.onStatusChange((status) => {\n\t *   if (status.status === 'error') {\n\t *     console.error('Connection error:', status.reason)\n\t *   } else {\n\t *     console.log('Status changed to:', status.status)\n\t *   }\n\t * })\n\t *\n\t * // Later, remove the listener\n\t * unsubscribe()\n\t * ```\n\t */\n\tonStatusChange(cb: TLSocketStatusListener) {\n\t\tassert(!this.isDisposed, 'Tried to add status listener on a disposed socket')\n\n\t\tthis.statusListeners.add(cb)\n\t\treturn () => {\n\t\t\tthis.statusListeners.delete(cb)\n\t\t}\n\t}\n\n\t/**\n\t * Manually restarts the WebSocket connection.\n\t * This closes the current connection (if any) and attempts to establish a new one.\n\t * Useful for implementing connection loss detection and recovery.\n\t *\n\t * @example\n\t * ```ts\n\t * // Restart connection after detecting it's stale\n\t * if (lastPongTime < Date.now() - 30000) {\n\t *   adapter.restart()\n\t * }\n\t * ```\n\t */\n\trestart() {\n\t\tassert(!this.isDisposed, 'Tried to restart a disposed socket')\n\t\tdebug('restarting')\n\n\t\tthis._closeSocket()\n\t\tthis._reconnectManager.maybeReconnected()\n\t}\n}\n\n/**\n * Minimum reconnection delay in milliseconds when the browser tab is active and focused.\n *\n * @internal\n */\nexport const ACTIVE_MIN_DELAY = 500\n\n/**\n * Maximum reconnection delay in milliseconds when the browser tab is active and focused.\n *\n * @internal\n */\nexport const ACTIVE_MAX_DELAY = 2000\n\n/**\n * Minimum reconnection delay in milliseconds when the browser tab is inactive or hidden.\n * This longer delay helps reduce battery drain and server load when users aren't actively viewing the tab.\n *\n * @internal\n */\nexport const INACTIVE_MIN_DELAY = 1000\n\n/**\n * Maximum reconnection delay in milliseconds when the browser tab is inactive or hidden.\n * Set to 5 minutes to balance between maintaining sync and conserving resources.\n *\n * @internal\n */\nexport const INACTIVE_MAX_DELAY = 1000 * 60 * 5\n\n/**\n * Exponential backoff multiplier for calculating reconnection delays.\n * Each failed connection attempt increases the delay by this factor until max delay is reached.\n *\n * @internal\n */\nexport const DELAY_EXPONENT = 1.5\n\n/**\n * Maximum time in milliseconds to wait for a connection attempt before considering it failed.\n * This helps detect connections stuck in the CONNECTING state and retry with fresh attempts.\n *\n * @internal\n */\nexport const ATTEMPT_TIMEOUT = 1000\n\n/**\n * Manages automatic reconnection logic for WebSocket connections with intelligent backoff strategies.\n * This class handles connection attempts, tracks connection state, and implements exponential backoff\n * with different delays based on whether the browser tab is active or inactive.\n *\n * The ReconnectManager responds to various browser events like network status changes,\n * tab visibility changes, and connection events to optimize reconnection timing and\n * minimize unnecessary connection attempts.\n *\n * @internal\n *\n * @example\n * ```ts\n * const manager = new ReconnectManager(\n *   socketAdapter,\n *   () => 'ws://localhost:3000/sync'\n * )\n *\n * // Manager automatically handles:\n * // - Initial connection\n * // - Reconnection on disconnect\n * // - Exponential backoff on failures\n * // - Tab visibility-aware delays\n * // - Network status change responses\n * ```\n */\nexport class ReconnectManager {\n\tprivate isDisposed = false\n\tprivate disposables: (() => void)[] = [\n\t\t() => {\n\t\t\tif (this.reconnectTimeout) clearTimeout(this.reconnectTimeout)\n\t\t\tif (this.recheckConnectingTimeout) clearTimeout(this.recheckConnectingTimeout)\n\t\t},\n\t]\n\tprivate reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n\tprivate recheckConnectingTimeout: ReturnType<typeof setTimeout> | null = null\n\n\tprivate lastAttemptStart: number | null = null\n\tintendedDelay: number = ACTIVE_MIN_DELAY\n\tprivate state: 'pendingAttempt' | 'pendingAttemptResult' | 'delay' | 'connected'\n\n\t/**\n\t * Creates a new ReconnectManager instance.\n\t *\n\t * socketAdapter - The ClientWebSocketAdapter instance to manage\n\t * getUri - Function that returns the WebSocket URI for connection attempts\n\t */\n\tconstructor(\n\t\tprivate socketAdapter: ClientWebSocketAdapter,\n\t\tprivate getUri: () => Promise<string> | string\n\t) {\n\t\tthis.subscribeToReconnectHints()\n\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'offline', () => {\n\t\t\t\tdebug('window went offline')\n\t\t\t\t// On the one hand, 'offline' event is not really reliable; on the other, the only\n\t\t\t\t// alternative is to wait for pings not being delivered, which takes more than 20 seconds,\n\t\t\t\t// which means we won't see the ClientWebSocketAdapter status change for more than\n\t\t\t\t// 20 seconds after the tab goes offline. Our application layer must be resistent to\n\t\t\t\t// connection restart anyway, so we can just try to reconnect and see if\n\t\t\t\t// we're truly offline.\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t})\n\t\t)\n\n\t\tthis.state = 'pendingAttempt'\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.scheduleAttempt()\n\t}\n\n\tprivate subscribeToReconnectHints() {\n\t\tthis.disposables.push(\n\t\t\tlistenTo(window, 'online', () => {\n\t\t\t\tdebug('window went online')\n\t\t\t\tthis.maybeReconnected()\n\t\t\t}),\n\t\t\tlistenTo(document, 'visibilitychange', () => {\n\t\t\t\tif (!document.hidden) {\n\t\t\t\t\tdebug('document became visible')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tif (Object.prototype.hasOwnProperty.call(navigator, 'connection')) {\n\t\t\tconst connection = (navigator as any)['connection'] as EventTarget\n\t\t\tthis.disposables.push(\n\t\t\t\tlistenTo(connection, 'change', () => {\n\t\t\t\t\tdebug('navigator.connection change')\n\t\t\t\t\tthis.maybeReconnected()\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate scheduleAttempt() {\n\t\tassert(this.state === 'pendingAttempt')\n\t\tdebug('scheduling a connection attempt')\n\t\tPromise.resolve(this.getUri()).then((uri) => {\n\t\t\t// this can happen if the promise gets resolved too late\n\t\t\tif (this.state !== 'pendingAttempt' || this.isDisposed) return\n\t\t\tassert(\n\t\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN,\n\t\t\t\t'There should be no connection attempts while already connected'\n\t\t\t)\n\n\t\t\tthis.lastAttemptStart = Date.now()\n\t\t\tthis.socketAdapter._setNewSocket(new WebSocket(httpToWs(uri)))\n\t\t\tthis.state = 'pendingAttemptResult'\n\t\t})\n\t}\n\n\tprivate getMaxDelay() {\n\t\treturn document.hidden ? INACTIVE_MAX_DELAY : ACTIVE_MAX_DELAY\n\t}\n\n\tprivate getMinDelay() {\n\t\treturn document.hidden ? INACTIVE_MIN_DELAY : ACTIVE_MIN_DELAY\n\t}\n\n\tprivate clearReconnectTimeout() {\n\t\tif (this.reconnectTimeout) {\n\t\t\tclearTimeout(this.reconnectTimeout)\n\t\t\tthis.reconnectTimeout = null\n\t\t}\n\t}\n\n\tprivate clearRecheckConnectingTimeout() {\n\t\tif (this.recheckConnectingTimeout) {\n\t\t\tclearTimeout(this.recheckConnectingTimeout)\n\t\t\tthis.recheckConnectingTimeout = null\n\t\t}\n\t}\n\n\t/**\n\t * Checks if reconnection should be attempted and initiates it if appropriate.\n\t * This method is called in response to network events, tab visibility changes,\n\t * and other hints that connectivity may have been restored.\n\t *\n\t * The method intelligently handles various connection states:\n\t * - Already connected: no action needed\n\t * - Currently connecting: waits or retries based on attempt age\n\t * - Disconnected: initiates immediate reconnection attempt\n\t *\n\t * @example\n\t * ```ts\n\t * // Called automatically on network/visibility events, but can be called manually\n\t * manager.maybeReconnected()\n\t * ```\n\t */\n\tmaybeReconnected() {\n\t\tdebug('ReconnectManager.maybeReconnected')\n\t\t// It doesn't make sense to have another check scheduled if we're already checking it now.\n\t\t// If we have a CONNECTING check scheduled and relevant, it'll be recreated below anyway\n\t\tthis.clearRecheckConnectingTimeout()\n\n\t\t// readyState can be CONNECTING, OPEN, CLOSING, CLOSED, or null (if getUri() is still pending)\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: already connected')\n\t\t\t// nothing to do, we're already OK\n\t\t\treturn\n\t\t}\n\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.CONNECTING) {\n\t\t\tdebug('ReconnectManager.maybeReconnected: connecting')\n\t\t\t// We might be waiting for a TCP connection that sent SYN out and will never get it back,\n\t\t\t// while a new connection appeared. On the other hand, we might have just started connecting\n\t\t\t// and will succeed in a bit. Thus, we're checking how old the attempt is and retry anew\n\t\t\t// if it's old enough. This by itself can delay the connection a bit, but shouldn't prevent\n\t\t\t// new connections as long as `maybeReconnected` is not looped itself\n\t\t\tassert(\n\t\t\t\tthis.lastAttemptStart,\n\t\t\t\t'ReadyState=CONNECTING without lastAttemptStart should be impossible'\n\t\t\t)\n\t\t\tconst sinceLastStart = Date.now() - this.lastAttemptStart\n\t\t\tif (sinceLastStart < ATTEMPT_TIMEOUT) {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, rechecking later')\n\t\t\t\tthis.recheckConnectingTimeout = setTimeout(\n\t\t\t\t\t() => this.maybeReconnected(),\n\t\t\t\t\tATTEMPT_TIMEOUT - sinceLastStart\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tdebug('ReconnectManager.maybeReconnected: connecting, but for too long, retry now')\n\t\t\t\t// Last connection attempt was started a while ago, it's possible that network conditions\n\t\t\t\t// changed, and it's worth retrying to connect. `disconnected` will handle reconnection\n\t\t\t\t//\n\t\t\t\t// NOTE: The danger here is looping in connection attemps if connections are slow.\n\t\t\t\t//       Make sure that `maybeReconnected` is not called in the `disconnected` codepath!\n\t\t\t\tthis.clearRecheckConnectingTimeout()\n\t\t\t\tthis.socketAdapter._closeSocket()\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tdebug('ReconnectManager.maybeReconnected: closing/closed/null, retry now')\n\t\t// readyState is CLOSING or CLOSED, or the websocket is null\n\t\t// Restart the backoff and retry ASAP (honouring the min delay)\n\t\t// this.state doesn't really matter, because disconnected() will handle any state correctly\n\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\tthis.disconnected()\n\t}\n\n\t/**\n\t * Handles disconnection events and schedules reconnection attempts with exponential backoff.\n\t * This method is called when the WebSocket connection is lost or fails to establish.\n\t *\n\t * It implements intelligent delay calculation based on:\n\t * - Previous attempt timing\n\t * - Current tab visibility (active vs inactive delays)\n\t * - Exponential backoff for repeated failures\n\t *\n\t * @example\n\t * ```ts\n\t * // Called automatically when connection is lost\n\t * // Schedules reconnection with appropriate delay\n\t * manager.disconnected()\n\t * ```\n\t */\n\tdisconnected() {\n\t\tdebug('ReconnectManager.disconnected')\n\t\t// This either means we're freshly disconnected, or the last connection attempt failed;\n\t\t// either way, time to try again.\n\n\t\t// Guard against delayed notifications and recheck synchronously\n\t\tif (\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.OPEN &&\n\t\t\tthis.socketAdapter._ws?.readyState !== WebSocket.CONNECTING\n\t\t) {\n\t\t\tdebug('ReconnectManager.disconnected: websocket is not OPEN or CONNECTING')\n\t\t\tthis.clearReconnectTimeout()\n\n\t\t\tlet delayLeft\n\t\t\tif (this.state === 'connected') {\n\t\t\t\t// it's the first sign that we got disconnected; the state will be updated below,\n\t\t\t\t// just set the appropriate delay for now\n\t\t\t\tthis.intendedDelay = this.getMinDelay()\n\t\t\t\tdelayLeft = this.intendedDelay\n\t\t\t} else {\n\t\t\t\tdelayLeft =\n\t\t\t\t\tthis.lastAttemptStart !== null\n\t\t\t\t\t\t? this.lastAttemptStart + this.intendedDelay - Date.now()\n\t\t\t\t\t\t: 0\n\t\t\t}\n\n\t\t\tif (delayLeft > 0) {\n\t\t\t\tdebug('ReconnectManager.disconnected: delaying, delayLeft', delayLeft)\n\t\t\t\t// try again later\n\t\t\t\tthis.state = 'delay'\n\n\t\t\t\tthis.reconnectTimeout = setTimeout(() => this.disconnected(), delayLeft)\n\t\t\t} else {\n\t\t\t\t// not connected and not delayed, time to retry\n\t\t\t\tthis.state = 'pendingAttempt'\n\n\t\t\t\tthis.intendedDelay = Math.min(\n\t\t\t\t\tthis.getMaxDelay(),\n\t\t\t\t\tMath.max(this.getMinDelay(), this.intendedDelay) * DELAY_EXPONENT\n\t\t\t\t)\n\t\t\t\tdebug(\n\t\t\t\t\t'ReconnectManager.disconnected: attempting a connection, next delay',\n\t\t\t\t\tthis.intendedDelay\n\t\t\t\t)\n\t\t\t\tthis.scheduleAttempt()\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles successful connection events and resets reconnection state.\n\t * This method is called when the WebSocket successfully connects to the server.\n\t *\n\t * It clears any pending reconnection attempts and resets the delay back to minimum\n\t * for future connection attempts.\n\t *\n\t * @example\n\t * ```ts\n\t * // Called automatically when WebSocket opens successfully\n\t * manager.connected()\n\t * ```\n\t */\n\tconnected() {\n\t\tdebug('ReconnectManager.connected')\n\t\t// this notification could've been delayed, recheck synchronously\n\t\tif (this.socketAdapter._ws?.readyState === WebSocket.OPEN) {\n\t\t\tdebug('ReconnectManager.connected: websocket is OPEN')\n\t\t\tthis.state = 'connected'\n\t\t\tthis.clearReconnectTimeout()\n\t\t\tthis.intendedDelay = ACTIVE_MIN_DELAY\n\t\t}\n\t}\n\n\t/**\n\t * Permanently closes the reconnection manager and cleans up all resources.\n\t * This stops all pending reconnection attempts and removes event listeners.\n\t * Once closed, the manager cannot be reused.\n\t */\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.isDisposed = true\n\t}\n}\n\nfunction httpToWs(url: string) {\n\treturn url.replace(/^http(s)?:/, 'ws$1:')\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1433, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/RoomSession.ts"],"sourcesContent":["import { SerializedSchema, UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentDataEvent } from './protocol'\n\n/**\n * Enumeration of possible states for a room session during its lifecycle.\n *\n * Room sessions progress through these states as clients connect, authenticate,\n * and disconnect from collaborative rooms.\n *\n * @internal\n */\nexport const RoomSessionState = {\n\t/** Session is waiting for the initial connect message from the client */\n\tAwaitingConnectMessage: 'awaiting-connect-message',\n\t/** Session is disconnected but waiting for final cleanup before removal */\n\tAwaitingRemoval: 'awaiting-removal',\n\t/** Session is fully connected and actively synchronizing */\n\tConnected: 'connected',\n} as const\n\n/**\n * Type representing the possible states a room session can be in.\n *\n * @example\n * ```ts\n * const sessionState: RoomSessionState = RoomSessionState.Connected\n * if (sessionState === RoomSessionState.AwaitingConnectMessage) {\n *   console.log('Session waiting for connect message')\n * }\n * ```\n *\n * @internal\n */\nexport type RoomSessionState = (typeof RoomSessionState)[keyof typeof RoomSessionState]\n\n/**\n * Maximum time in milliseconds to wait for a connect message after socket connection.\n *\n * If a client connects but doesn't send a connect message within this time,\n * the session will be terminated.\n *\n * @public\n */\nexport const SESSION_START_WAIT_TIME = 10000\n\n/**\n * Time in milliseconds to wait before completely removing a disconnected session.\n *\n * This grace period allows for quick reconnections without losing session state,\n * which is especially helpful for brief network interruptions.\n *\n * @public\n */\nexport const SESSION_REMOVAL_WAIT_TIME = 5000\n\n/**\n * Maximum time in milliseconds a connected session can remain idle before cleanup.\n *\n * Sessions that don't receive any messages or interactions for this duration\n * may be considered for cleanup to free server resources.\n *\n * @public\n */\nexport const SESSION_IDLE_TIMEOUT = 20000\n\n/**\n * Represents a client session within a collaborative room, tracking the connection\n * state, permissions, and synchronization details for a single user.\n *\n * Each session corresponds to one WebSocket connection and progresses through\n * different states during its lifecycle. The session type is a discriminated union\n * based on the current state, ensuring type safety when accessing state-specific properties.\n *\n * @example\n * ```ts\n * // Check session state and access appropriate properties\n * function handleSession(session: RoomSession<MyRecord, UserMeta>) {\n *   switch (session.state) {\n *     case RoomSessionState.AwaitingConnectMessage:\n *       console.log(`Session ${session.sessionId} started at ${session.sessionStartTime}`)\n *       break\n *     case RoomSessionState.Connected:\n *       console.log(`Connected session has ${session.outstandingDataMessages.length} pending messages`)\n *       break\n *     case RoomSessionState.AwaitingRemoval:\n *       console.log(`Session will be removed at ${session.cancellationTime}`)\n *       break\n *   }\n * }\n * ```\n *\n * @internal\n */\nexport type RoomSession<R extends UnknownRecord, Meta> =\n\t| {\n\t\t\t/** Current state of the session */\n\t\t\tstate: typeof RoomSessionState.AwaitingConnectMessage\n\t\t\t/** Unique identifier for this session */\n\t\t\tsessionId: string\n\t\t\t/** Presence identifier for live cursor/selection tracking, if available */\n\t\t\tpresenceId: string | null\n\t\t\t/** WebSocket connection wrapper for this session */\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\t/** Timestamp when the session was created */\n\t\t\tsessionStartTime: number\n\t\t\t/** Custom metadata associated with this session */\n\t\t\tmeta: Meta\n\t\t\t/** Whether this session has read-only permissions */\n\t\t\tisReadonly: boolean\n\t\t\t/** Whether this session requires legacy protocol rejection handling */\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\t/** Current state of the session */\n\t\t\tstate: typeof RoomSessionState.AwaitingRemoval\n\t\t\t/** Unique identifier for this session */\n\t\t\tsessionId: string\n\t\t\t/** Presence identifier for live cursor/selection tracking, if available */\n\t\t\tpresenceId: string | null\n\t\t\t/** WebSocket connection wrapper for this session */\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\t/** Timestamp when the session was marked for removal */\n\t\t\tcancellationTime: number\n\t\t\t/** Custom metadata associated with this session */\n\t\t\tmeta: Meta\n\t\t\t/** Whether this session has read-only permissions */\n\t\t\tisReadonly: boolean\n\t\t\t/** Whether this session requires legacy protocol rejection handling */\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n\t| {\n\t\t\t/** Current state of the session */\n\t\t\tstate: typeof RoomSessionState.Connected\n\t\t\t/** Unique identifier for this session */\n\t\t\tsessionId: string\n\t\t\t/** Presence identifier for live cursor/selection tracking, if available */\n\t\t\tpresenceId: string | null\n\t\t\t/** WebSocket connection wrapper for this session */\n\t\t\tsocket: TLRoomSocket<R>\n\t\t\t/** Serialized schema information for this connected session */\n\t\t\tserializedSchema: SerializedSchema\n\t\t\t/** Timestamp of the last interaction or message from this session */\n\t\t\tlastInteractionTime: number\n\t\t\t/** Timer for debouncing operations, if active */\n\t\t\tdebounceTimer: ReturnType<typeof setTimeout> | null\n\t\t\t/** Queue of data messages waiting to be sent to this session */\n\t\t\toutstandingDataMessages: TLSocketServerSentDataEvent<R>[]\n\t\t\t/** Custom metadata associated with this session */\n\t\t\tmeta: Meta\n\t\t\t/** Whether this session has read-only permissions */\n\t\t\tisReadonly: boolean\n\t\t\t/** Whether this session requires legacy protocol rejection handling */\n\t\t\trequiresLegacyRejection: boolean\n\t  }\n"],"names":[],"mappings":";;;;;;;;;;AAYO,MAAM,mBAAmB;IAAA,uEAAA,GAE/B,wBAAwB;IAAA,yEAAA,GAExB,iBAAiB;IAAA,0DAAA,GAEjB,WAAW;AACZ;AAyBO,MAAM,0BAA0B;AAUhC,MAAM,4BAA4B;AAUlC,MAAM,uBAAuB","debugId":null}},
    {"offset": {"line": 1457, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/TLRemoteSyncError.ts"],"sourcesContent":["import { TLSyncErrorCloseEventReason } from './TLSyncClient'\n\n/**\n * Specialized error class for synchronization-related failures in tldraw collaboration.\n *\n * This error is thrown when the sync client encounters fatal errors that prevent\n * successful synchronization with the server. It captures both the error message\n * and the specific reason code that triggered the failure.\n *\n * Common scenarios include schema version mismatches, authentication failures,\n * network connectivity issues, and server-side validation errors.\n *\n * @example\n * ```ts\n * import { TLRemoteSyncError, TLSyncErrorCloseEventReason } from '@tldraw/sync-core'\n *\n * // Handle sync errors in your application\n * syncClient.onSyncError((error) => {\n *   if (error instanceof TLRemoteSyncError) {\n *     switch (error.reason) {\n *       case TLSyncErrorCloseEventReason.NOT_AUTHENTICATED:\n *         // Redirect user to login\n *         break\n *       case TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n *         // Show update required message\n *         break\n *       default:\n *         console.error('Sync error:', error.message)\n *     }\n *   }\n * })\n * ```\n *\n * @example\n * ```ts\n * // Server-side: throwing a sync error\n * if (!hasPermission(userId, roomId)) {\n *   throw new TLRemoteSyncError(TLSyncErrorCloseEventReason.FORBIDDEN)\n * }\n * ```\n *\n * @public\n */\nexport class TLRemoteSyncError extends Error {\n\toverride name = 'RemoteSyncError'\n\n\t/**\n\t * Creates a new TLRemoteSyncError with the specified reason.\n\t *\n\t * reason - The specific reason code or custom string describing why the sync failed.\n\t *                 When using predefined reasons from TLSyncErrorCloseEventReason, the client\n\t *                 can handle specific error types appropriately. Custom strings allow for\n\t *                 application-specific error details.\n\t */\n\tconstructor(public readonly reason: TLSyncErrorCloseEventReason | string) {\n\t\tsuper(`sync error: ${reason}`)\n\t}\n}\n"],"names":[],"mappings":";;;;AA2CO,MAAM,0BAA0B,MAAM;IAAA;;;;;;;GAAA,GAW5C,YAA4B,MAAA,CAA8C;QACzE,KAAA,CAAM,CAAA,YAAA,EAAe,MAAM,EAAE;QADF,IAAA,CAAA,MAAA,GAAA;IAE5B;IAZS,OAAO,kBAAA;AAajB","debugId":null}},
    {"offset": {"line": 1481, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/ServerSocketAdapter.ts"],"sourcesContent":["import { UnknownRecord } from '@tldraw/store'\nimport { TLRoomSocket } from './TLSyncRoom'\nimport { TLSocketServerSentEvent } from './protocol'\n\n/**\n * Minimal server-side WebSocket interface that is compatible with various WebSocket implementations.\n * This interface abstracts over different WebSocket libraries and platforms to provide a consistent\n * API for the ServerSocketAdapter.\n *\n * Supports:\n * - The standard WebSocket interface (Cloudflare, Deno, some Node.js setups)\n * - The 'ws' WebSocket interface (Node.js ws library)\n * - The Bun.serve socket implementation\n *\n * @public\n * @example\n * ```ts\n * // Standard WebSocket\n * const standardWs: WebSocketMinimal = new WebSocket('ws://localhost:8080')\n *\n * // Node.js 'ws' library WebSocket\n * import WebSocket from 'ws'\n * const nodeWs: WebSocketMinimal = new WebSocket('ws://localhost:8080')\n *\n * // Bun WebSocket (in server context)\n * // const bunWs: WebSocketMinimal = server.upgrade(request)\n * ```\n */\nexport interface WebSocketMinimal {\n\t/**\n\t * Optional method to add event listeners for WebSocket events.\n\t * Not all WebSocket implementations provide this method.\n\t *\n\t * @param type - The event type to listen for\n\t * @param listener - The event handler function\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\taddEventListener?: (type: 'message' | 'close' | 'error', listener: (event: any) => void) => void\n\n\t/**\n\t * Optional method to remove event listeners for WebSocket events.\n\t * Not all WebSocket implementations provide this method.\n\t *\n\t * @param type - The event type to stop listening for\n\t * @param listener - The event handler function to remove\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tremoveEventListener?: (\n\t\ttype: 'message' | 'close' | 'error',\n\t\tlistener: (event: any) => void\n\t) => void\n\n\t/**\n\t * Sends a string message through the WebSocket connection.\n\t *\n\t * @param data - The string data to send\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tsend: (data: string) => void\n\n\t/**\n\t * Closes the WebSocket connection.\n\t *\n\t * @param code - Optional close code (default: 1000 for normal closure)\n\t * @param reason - Optional human-readable close reason\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tclose: (code?: number, reason?: string) => void\n\n\t/**\n\t * The current state of the WebSocket connection.\n\t * - 0: CONNECTING\n\t * - 1: OPEN\n\t * - 2: CLOSING\n\t * - 3: CLOSED\n\t */\n\treadyState: number\n}\n\n/**\n * Configuration options for creating a ServerSocketAdapter instance.\n *\n * @internal\n */\nexport interface ServerSocketAdapterOptions<R extends UnknownRecord> {\n\t/** The underlying WebSocket connection to wrap */\n\treadonly ws: WebSocketMinimal\n\n\t/**\n\t * Optional callback invoked before each message is sent to the client.\n\t * Useful for logging, metrics, or message transformation.\n\t *\n\t * @param msg - The message object being sent\n\t * @param stringified - The JSON stringified version of the message\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\treadonly onBeforeSendMessage?: (msg: TLSocketServerSentEvent<R>, stringified: string) => void\n}\n\n/**\n * Server-side adapter that wraps various WebSocket implementations to provide a consistent\n * TLRoomSocket interface for the TLSyncRoom. This adapter handles the differences between\n * WebSocket libraries and platforms, allowing sync-core to work across different server\n * environments.\n *\n * The adapter implements the TLRoomSocket interface, providing methods for sending messages,\n * checking connection status, and closing connections.\n *\n * @internal\n * @example\n * ```ts\n * import { ServerSocketAdapter } from '@tldraw/sync-core'\n *\n * // Wrap a standard WebSocket\n * const adapter = new ServerSocketAdapter({\n *   ws: webSocketConnection,\n *   onBeforeSendMessage: (msg, json) => {\n *     console.log('Sending:', msg.type)\n *   }\n * })\n *\n * // Use with TLSyncRoom\n * room.handleNewSession({\n *   sessionId: 'session-123',\n *   socket: adapter,\n *   isReadonly: false\n * })\n * ```\n */\nexport class ServerSocketAdapter<R extends UnknownRecord> implements TLRoomSocket<R> {\n\t/**\n\t * Creates a new ServerSocketAdapter instance.\n\t *\n\t * opts - Configuration options for the adapter\n\t */\n\tconstructor(public readonly opts: ServerSocketAdapterOptions<R>) {}\n\n\t/**\n\t * Checks if the underlying WebSocket connection is currently open and ready to send messages.\n\t *\n\t * @returns True if the connection is open (readyState === 1), false otherwise\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isOpen(): boolean {\n\t\treturn this.opts.ws.readyState === 1 // ready state open\n\t}\n\n\t/**\n\t * Sends a sync protocol message to the connected client. The message is JSON stringified\n\t * before being sent through the WebSocket. If configured, the onBeforeSendMessage callback\n\t * is invoked before sending.\n\t *\n\t * @param msg - The sync protocol message to send\n\t */\n\t// see TLRoomSocket for details on why this accepts a union and not just arrays\n\tsendMessage(msg: TLSocketServerSentEvent<R>) {\n\t\tconst message = JSON.stringify(msg)\n\t\tthis.opts.onBeforeSendMessage?.(msg, message)\n\t\tthis.opts.ws.send(message)\n\t}\n\n\t/**\n\t * Closes the WebSocket connection with an optional close code and reason.\n\t *\n\t * @param code - Optional close code (default: 1000 for normal closure)\n\t * @param reason - Optional human-readable reason for closing\n\t */\n\tclose(code?: number, reason?: string) {\n\t\tthis.opts.ws.close(code, reason)\n\t}\n}\n"],"names":[],"mappings":";;;;AAiIO,MAAM,oBAAwE;IAAA;;;;GAAA,GAMpF,YAA4B,IAAA,CAAqC;QAArC,IAAA,CAAA,IAAA,GAAA;IAAsC;IAAA;;;;GAAA,GAAA,gDAAA;IAQlE,IAAI,SAAkB;QACrB,OAAO,IAAA,CAAK,IAAA,CAAK,EAAA,CAAG,UAAA,KAAe;IACpC;IAAA;;;;;;GAAA,GAAA,+EAAA;IAUA,YAAY,GAAA,EAAiC;QAC5C,MAAM,UAAU,KAAK,SAAA,CAAU,GAAG;QAClC,IAAA,CAAK,IAAA,CAAK,mBAAA,GAAsB,KAAK,OAAO;QAC5C,IAAA,CAAK,IAAA,CAAK,EAAA,CAAG,IAAA,CAAK,OAAO;IAC1B;IAAA;;;;;GAAA,GAQA,MAAM,IAAA,EAAe,MAAA,EAAiB;QACrC,IAAA,CAAK,IAAA,CAAK,EAAA,CAAG,KAAA,CAAM,MAAM,MAAM;IAChC;AACD","debugId":null}},
    {"offset": {"line": 1528, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/findMin.ts"],"sourcesContent":["/**\n * Finds the minimum value from an iterable of numbers.\n *\n * @param values - An iterable of numbers to find the minimum from\n * @returns The minimum value, or null if the iterable is empty\n * @example\n * ```ts\n * findMin([3, 1, 4, 1, 5]) // returns 1\n * findMin(new Set([10, 5, 8])) // returns 5\n * findMin([]) // returns null\n * ```\n */\nexport function findMin(values: Iterable<number>): number | null {\n\tlet min: number | null = null\n\tfor (const value of values) {\n\t\tif (min === null) {\n\t\t\tmin = value\n\t\t} else if (value < min) {\n\t\t\tmin = value\n\t\t}\n\t}\n\treturn min\n}\n"],"names":[],"mappings":";;;;AAYO,SAAS,QAAQ,MAAA,EAAyC;IAChE,IAAI,MAAqB;IACzB,KAAA,MAAW,SAAS,OAAQ;QAC3B,IAAI,QAAQ,MAAM;YACjB,MAAM;QACP,OAAA,IAAW,QAAQ,KAAK;YACvB,MAAM;QACP;IACD;IACA,OAAO;AACR","debugId":null}},
    {"offset": {"line": 1549, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/TLSyncRoom.ts"],"sourcesContent":["import { transact, transaction } from '@tldraw/state'\nimport {\n\tAtomMap,\n\tIdOf,\n\tMigrationFailureReason,\n\tRecordType,\n\tSerializedSchema,\n\tStoreSchema,\n\tUnknownRecord,\n} from '@tldraw/store'\nimport { DocumentRecordType, PageRecordType, TLDOCUMENT_ID } from '@tldraw/tlschema'\nimport {\n\tIndexKey,\n\tResult,\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tisEqual,\n\tisNativeStructuredClone,\n\tobjectMapEntriesIterable,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport { createNanoEvents } from 'nanoevents'\nimport {\n\tRoomSession,\n\tRoomSessionState,\n\tSESSION_IDLE_TIMEOUT,\n\tSESSION_REMOVAL_WAIT_TIME,\n\tSESSION_START_WAIT_TIME,\n} from './RoomSession'\nimport { TLSyncLog } from './TLSocketRoom'\nimport { TLSyncErrorCloseEventCode, TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport {\n\tNetworkDiff,\n\tObjectDiff,\n\tRecordOp,\n\tRecordOpType,\n\tValueOpType,\n\tapplyObjectDiff,\n\tdiffRecord,\n} from './diff'\nimport { findMin } from './findMin'\nimport { interval } from './interval'\nimport {\n\tTLIncompatibilityReason,\n\tTLSocketClientSentEvent,\n\tTLSocketServerSentDataEvent,\n\tTLSocketServerSentEvent,\n\tgetTlsyncProtocolVersion,\n} from './protocol'\n\n/**\n * WebSocket interface for server-side room connections. This defines the contract\n * that socket implementations must follow to work with TLSyncRoom.\n *\n * @internal\n */\nexport interface TLRoomSocket<R extends UnknownRecord> {\n\t/**\n\t * Whether the socket connection is currently open and ready to send messages.\n\t */\n\tisOpen: boolean\n\t/**\n\t * Send a message to the connected client through this socket.\n\t *\n\t * @param msg - The server-sent event message to transmit\n\t */\n\tsendMessage(msg: TLSocketServerSentEvent<R>): void\n\t/**\n\t * Close the socket connection with optional status code and reason.\n\t *\n\t * @param code - WebSocket close code (optional)\n\t * @param reason - Human-readable close reason (optional)\n\t */\n\tclose(code?: number, reason?: string): void\n}\n\n/**\n * The maximum number of tombstone records to keep in memory. Tombstones track\n * deleted records to prevent resurrection during sync operations.\n * @public\n */\nexport const MAX_TOMBSTONES = 3000\n\n/**\n * The number of tombstones to delete when pruning occurs after reaching MAX_TOMBSTONES.\n * This buffer prevents frequent pruning operations.\n * @public\n */\nexport const TOMBSTONE_PRUNE_BUFFER_SIZE = 300\n\n/**\n * The minimum time interval (in milliseconds) between sending batched data messages\n * to clients. This debouncing prevents overwhelming clients with rapid updates.\n * @public\n */\nexport const DATA_MESSAGE_DEBOUNCE_INTERVAL = 1000 / 60\n\nconst timeSince = (time: number) => Date.now() - time\n\n/**\n * Represents the state of a document record within a sync room, including\n * its current data and the clock value when it was last modified.\n *\n * @internal\n */\nexport class DocumentState<R extends UnknownRecord> {\n\t/**\n\t * Create a DocumentState instance without validating the record data.\n\t * Used for performance when validation has already been performed.\n\t *\n\t * @param state - The record data\n\t * @param lastChangedClock - Clock value when this record was last modified\n\t * @param recordType - The record type definition for validation\n\t * @returns A new DocumentState instance\n\t */\n\tstatic createWithoutValidating<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): DocumentState<R> {\n\t\treturn new DocumentState(state, lastChangedClock, recordType)\n\t}\n\n\t/**\n\t * Create a DocumentState instance with validation of the record data.\n\t *\n\t * @param state - The record data to validate\n\t * @param lastChangedClock - Clock value when this record was last modified\n\t * @param recordType - The record type definition for validation\n\t * @returns Result containing the DocumentState or validation error\n\t */\n\tstatic createAndValidate<R extends UnknownRecord>(\n\t\tstate: R,\n\t\tlastChangedClock: number,\n\t\trecordType: RecordType<R, any>\n\t): Result<DocumentState<R>, Error> {\n\t\ttry {\n\t\t\trecordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\treturn Result.ok(new DocumentState(state, lastChangedClock, recordType))\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly state: R,\n\t\tpublic readonly lastChangedClock: number,\n\t\tprivate readonly recordType: RecordType<R, any>\n\t) {}\n\n\t/**\n\t * Replace the current state with new state and calculate the diff.\n\t *\n\t * @param state - The new record state\n\t * @param clock - The new clock value\n\t * @returns Result containing the diff and new DocumentState, or null if no changes, or validation error\n\t */\n\treplaceState(state: R, clock: number): Result<[ObjectDiff, DocumentState<R>] | null, Error> {\n\t\tconst diff = diffRecord(this.state, state)\n\t\tif (!diff) return Result.ok(null)\n\t\ttry {\n\t\t\tthis.recordType.validate(state)\n\t\t} catch (error: any) {\n\t\t\treturn Result.err(error)\n\t\t}\n\t\treturn Result.ok([diff, new DocumentState(state, clock, this.recordType)])\n\t}\n\t/**\n\t * Apply a diff to the current state and return the resulting changes.\n\t *\n\t * @param diff - The object diff to apply\n\t * @param clock - The new clock value\n\t * @returns Result containing the final diff and new DocumentState, or null if no changes, or validation error\n\t */\n\tmergeDiff(diff: ObjectDiff, clock: number): Result<[ObjectDiff, DocumentState<R>] | null, Error> {\n\t\tconst newState = applyObjectDiff(this.state, diff)\n\t\treturn this.replaceState(newState, clock)\n\t}\n}\n\n/**\n * Snapshot of a room's complete state that can be persisted and restored.\n * Contains all documents, tombstones, and metadata needed to reconstruct the room.\n *\n * @public\n */\nexport interface RoomSnapshot {\n\t/**\n\t * The current logical clock value for the room\n\t */\n\tclock: number\n\t/**\n\t * Clock value when document data was last changed (optional for backwards compatibility)\n\t */\n\tdocumentClock?: number\n\t/**\n\t * Array of all document records with their last modification clocks\n\t */\n\tdocuments: Array<{ state: UnknownRecord; lastChangedClock: number }>\n\t/**\n\t * Map of deleted record IDs to their deletion clock values (optional)\n\t */\n\ttombstones?: Record<string, number>\n\t/**\n\t * Clock value where tombstone history begins - older deletions are not tracked (optional)\n\t */\n\ttombstoneHistoryStartsAtClock?: number\n\t/**\n\t * Serialized schema used when creating this snapshot (optional)\n\t */\n\tschema?: SerializedSchema\n}\n\nfunction getDocumentClock(snapshot: RoomSnapshot) {\n\tif (typeof snapshot.documentClock === 'number') {\n\t\treturn snapshot.documentClock\n\t}\n\tlet max = 0\n\tfor (const doc of snapshot.documents) {\n\t\tmax = Math.max(max, doc.lastChangedClock)\n\t}\n\tfor (const tombstone of Object.values(snapshot.tombstones ?? {})) {\n\t\tmax = Math.max(max, tombstone)\n\t}\n\treturn max\n}\n\n/**\n * A collaborative workspace that manages multiple client sessions and synchronizes\n * document changes between them. The room serves as the authoritative source for\n * all document state and handles conflict resolution, schema migrations, and\n * real-time data distribution.\n *\n * @example\n * ```ts\n * const room = new TLSyncRoom({\n *   schema: mySchema,\n *   onDataChange: () => saveToDatabase(room.getSnapshot()),\n *   onPresenceChange: () => updateLiveCursors()\n * })\n *\n * // Handle new client connections\n * room.handleNewSession({\n *   sessionId: 'user-123',\n *   socket: webSocketAdapter,\n *   meta: { userId: '123', name: 'Alice' },\n *   isReadonly: false\n * })\n * ```\n *\n * @internal\n */\nexport class TLSyncRoom<R extends UnknownRecord, SessionMeta> {\n\t// A table of connected clients\n\treadonly sessions = new Map<string, RoomSession<R, SessionMeta>>()\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\tpruneSessions = () => {\n\t\tfor (const client of this.sessions.values()) {\n\t\t\tswitch (client.state) {\n\t\t\t\tcase RoomSessionState.Connected: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.lastInteractionTime) > SESSION_IDLE_TIMEOUT\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\tthis.cancelSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingConnectMessage: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.sessionStartTime) > SESSION_START_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut || !client.socket.isOpen) {\n\t\t\t\t\t\t// remove immediately\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase RoomSessionState.AwaitingRemoval: {\n\t\t\t\t\tconst hasTimedOut = timeSince(client.cancellationTime) > SESSION_REMOVAL_WAIT_TIME\n\t\t\t\t\tif (hasTimedOut) {\n\t\t\t\t\t\tthis.removeSession(client.sessionId)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\texhaustiveSwitchError(client)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate disposables: Array<() => void> = [interval(this.pruneSessions, 2000)]\n\n\tprivate _isClosed = false\n\n\t/**\n\t * Close the room and clean up all resources. Disconnects all sessions\n\t * and stops background processes.\n\t */\n\tclose() {\n\t\tthis.disposables.forEach((d) => d())\n\t\tthis.sessions.forEach((session) => {\n\t\t\tsession.socket.close()\n\t\t})\n\t\tthis._isClosed = true\n\t}\n\n\t/**\n\t * Check if the room has been closed and is no longer accepting connections.\n\t *\n\t * @returns True if the room is closed\n\t */\n\tisClosed() {\n\t\treturn this._isClosed\n\t}\n\n\treadonly events = createNanoEvents<{\n\t\troom_became_empty(): void\n\t\tsession_removed(args: { sessionId: string; meta: SessionMeta }): void\n\t}>()\n\n\t// Values associated with each uid (must be serializable).\n\t/** @internal */\n\tdocuments: AtomMap<string, DocumentState<R>>\n\ttombstones: AtomMap<string, number>\n\n\t// this clock should start higher than the client, to make sure that clients who sync with their\n\t// initial lastServerClock value get the full state\n\t// in this case clients will start with 0, and the server will start with 1\n\tclock: number\n\tdocumentClock: number\n\ttombstoneHistoryStartsAtClock: number\n\t// map from record id to clock upon deletion\n\n\treadonly serializedSchema: SerializedSchema\n\n\treadonly documentTypes: Set<string>\n\treadonly presenceType: RecordType<R, any> | null\n\tprivate log?: TLSyncLog\n\tpublic readonly schema: StoreSchema<R, any>\n\tprivate onDataChange?(): void\n\tprivate onPresenceChange?(): void\n\n\tconstructor(opts: {\n\t\tlog?: TLSyncLog\n\t\tschema: StoreSchema<R, any>\n\t\tsnapshot?: RoomSnapshot\n\t\tonDataChange?(): void\n\t\tonPresenceChange?(): void\n\t}) {\n\t\tthis.schema = opts.schema\n\t\tlet snapshot = opts.snapshot\n\t\tthis.log = opts.log\n\t\tthis.onDataChange = opts.onDataChange\n\t\tthis.onPresenceChange = opts.onPresenceChange\n\n\t\tassert(\n\t\t\tisNativeStructuredClone,\n\t\t\t'TLSyncRoom is supposed to run either on Cloudflare Workers' +\n\t\t\t\t'or on a 18+ version of Node.js, which both support the native structuredClone API'\n\t\t)\n\n\t\t// do a json serialization cycle to make sure the schema has no 'undefined' values\n\t\tthis.serializedSchema = JSON.parse(JSON.stringify(this.schema.serialize()))\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\n\t\tconst presenceTypes = new Set(\n\t\t\tObject.values<RecordType<R, any>>(this.schema.types).filter((t) => t.scope === 'presence')\n\t\t)\n\n\t\tif (presenceTypes.size > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`TLSyncRoom: exactly zero or one presence type is expected, but found ${presenceTypes.size}`\n\t\t\t)\n\t\t}\n\n\t\tthis.presenceType = presenceTypes.values().next()?.value ?? null\n\n\t\tif (!snapshot) {\n\t\t\tsnapshot = {\n\t\t\t\tclock: 0,\n\t\t\t\tdocumentClock: 0,\n\t\t\t\tdocuments: [\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: DocumentRecordType.create({ id: TLDOCUMENT_ID }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tstate: PageRecordType.create({ name: 'Page 1', index: 'a1' as IndexKey }),\n\t\t\t\t\t\tlastChangedClock: 0,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t}\n\n\t\tthis.clock = snapshot.clock\n\n\t\tlet didIncrementClock = false\n\t\tconst ensureClockDidIncrement = (_reason: string) => {\n\t\t\tif (!didIncrementClock) {\n\t\t\t\tdidIncrementClock = true\n\t\t\t\tthis.clock++\n\t\t\t}\n\t\t}\n\n\t\tthis.tombstones = new AtomMap(\n\t\t\t'room tombstones',\n\t\t\tobjectMapEntriesIterable(snapshot.tombstones ?? {})\n\t\t)\n\t\tthis.documents = new AtomMap(\n\t\t\t'room documents',\n\t\t\tfunction* (this: TLSyncRoom<R, SessionMeta>) {\n\t\t\t\tfor (const doc of snapshot.documents) {\n\t\t\t\t\tif (this.documentTypes.has(doc.state.typeName)) {\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tdoc.state.id,\n\t\t\t\t\t\t\tDocumentState.createWithoutValidating<R>(\n\t\t\t\t\t\t\t\tdoc.state as R,\n\t\t\t\t\t\t\t\tdoc.lastChangedClock,\n\t\t\t\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, doc.state.typeName))\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t] as const\n\t\t\t\t\t} else {\n\t\t\t\t\t\tensureClockDidIncrement('doc type was not doc type')\n\t\t\t\t\t\tthis.tombstones.set(doc.state.id, this.clock)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}.call(this)\n\t\t)\n\n\t\tthis.tombstoneHistoryStartsAtClock =\n\t\t\tsnapshot.tombstoneHistoryStartsAtClock ?? findMin(this.tombstones.values()) ?? this.clock\n\n\t\tif (this.tombstoneHistoryStartsAtClock === 0) {\n\t\t\t// Before this comment was added, new clients would send '0' as their 'lastServerClock'\n\t\t\t// which was technically an error because clocks start at 0, but the error didn't manifest\n\t\t\t// because we initialized tombstoneHistoryStartsAtClock to 1 and then never updated it.\n\t\t\t// Now that we handle tombstoneHistoryStartsAtClock properly we need to increment it here to make sure old\n\t\t\t// clients still get data when they connect. This if clause can be deleted after a few months.\n\t\t\tthis.tombstoneHistoryStartsAtClock++\n\t\t}\n\n\t\ttransact(() => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\tconst schema = snapshot.schema ?? this.schema.serializeEarliestVersion()\n\n\t\t\tconst migrationsToApply = this.schema.getMigrationsSince(schema)\n\t\t\tassert(migrationsToApply.ok, 'Failed to get migrations')\n\n\t\t\tif (migrationsToApply.value.length > 0) {\n\t\t\t\t// only bother allocating a snapshot if there are migrations to apply\n\t\t\t\tconst store = {} as Record<IdOf<R>, R>\n\t\t\t\tfor (const [k, v] of this.documents.entries()) {\n\t\t\t\t\tstore[k as IdOf<R>] = v.state\n\t\t\t\t}\n\n\t\t\t\tconst migrationResult = this.schema.migrateStoreSnapshot(\n\t\t\t\t\t{ store, schema },\n\t\t\t\t\t{ mutateInputStore: true }\n\t\t\t\t)\n\n\t\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\t\t// TODO: Fault tolerance\n\t\t\t\t\tthrow new Error('Failed to migrate: ' + migrationResult.reason)\n\t\t\t\t}\n\n\t\t\t\t// use for..in to iterate over the keys of the object because it consumes less memory than\n\t\t\t\t// Object.entries\n\t\t\t\tfor (const id in migrationResult.value) {\n\t\t\t\t\tif (!Object.prototype.hasOwnProperty.call(migrationResult.value, id)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst r = migrationResult.value[id as keyof typeof migrationResult.value]\n\t\t\t\t\tconst existing = this.documents.get(id)\n\t\t\t\t\tif (!existing || !isEqual(existing.state, r)) {\n\t\t\t\t\t\t// record was added or updated during migration\n\t\t\t\t\t\tensureClockDidIncrement('record was added or updated during migration')\n\t\t\t\t\t\tthis.documents.set(\n\t\t\t\t\t\t\tr.id,\n\t\t\t\t\t\t\tDocumentState.createWithoutValidating(\n\t\t\t\t\t\t\t\tr,\n\t\t\t\t\t\t\t\tthis.clock,\n\t\t\t\t\t\t\t\tassertExists(getOwnProperty(this.schema.types, r.typeName)) as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const id of this.documents.keys()) {\n\t\t\t\t\tif (!migrationResult.value[id as keyof typeof migrationResult.value]) {\n\t\t\t\t\t\t// record was removed during migration\n\t\t\t\t\t\tensureClockDidIncrement('record was removed during migration')\n\t\t\t\t\t\tthis.tombstones.set(id, this.clock)\n\t\t\t\t\t\tthis.documents.delete(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.pruneTombstones()\n\t\t})\n\n\t\tif (didIncrementClock) {\n\t\t\tthis.documentClock = this.clock\n\t\t\topts.onDataChange?.()\n\t\t} else {\n\t\t\tthis.documentClock = getDocumentClock(snapshot)\n\t\t}\n\t}\n\n\tprivate didSchedulePrune = true\n\t// eslint-disable-next-line local/prefer-class-methods\n\tprivate pruneTombstones = () => {\n\t\tthis.didSchedulePrune = false\n\t\t// avoid blocking any pending responses\n\t\tif (this.tombstones.size > MAX_TOMBSTONES) {\n\t\t\tconst entries = Array.from(this.tombstones.entries())\n\t\t\t// sort entries in ascending order by clock\n\t\t\tentries.sort((a, b) => a[1] - b[1])\n\t\t\tlet idx = entries.length - 1 - MAX_TOMBSTONES + TOMBSTONE_PRUNE_BUFFER_SIZE\n\t\t\tconst cullClock = entries[idx++][1]\n\t\t\twhile (idx < entries.length && entries[idx][1] === cullClock) {\n\t\t\t\tidx++\n\t\t\t}\n\t\t\t// trim off the first bunch\n\t\t\tconst keysToDelete = entries.slice(0, idx).map(([key]) => key)\n\n\t\t\tthis.tombstoneHistoryStartsAtClock = cullClock + 1\n\t\t\tthis.tombstones.deleteMany(keysToDelete)\n\t\t}\n\t}\n\n\tprivate getDocument(id: string) {\n\t\treturn this.documents.get(id)\n\t}\n\n\tprivate addDocument(id: string, state: R, clock: number): Result<void, Error> {\n\t\tif (this.tombstones.has(id)) {\n\t\t\tthis.tombstones.delete(id)\n\t\t}\n\t\tconst createResult = DocumentState.createAndValidate(\n\t\t\tstate,\n\t\t\tclock,\n\t\t\tassertExists(getOwnProperty(this.schema.types, state.typeName))\n\t\t)\n\t\tif (!createResult.ok) return createResult\n\t\tthis.documents.set(id, createResult.value)\n\t\treturn Result.ok(undefined)\n\t}\n\n\tprivate removeDocument(id: string, clock: number) {\n\t\tthis.documents.delete(id)\n\t\tthis.tombstones.set(id, clock)\n\t\tif (!this.didSchedulePrune) {\n\t\t\tthis.didSchedulePrune = true\n\t\t\tsetTimeout(this.pruneTombstones, 0)\n\t\t}\n\t}\n\n\t/**\n\t * Get a complete snapshot of the current room state that can be persisted\n\t * and later used to restore the room.\n\t *\n\t * @returns Room snapshot containing all documents, tombstones, and metadata\n\t * @example\n\t * ```ts\n\t * const snapshot = room.getSnapshot()\n\t * await database.saveRoomSnapshot(roomId, snapshot)\n\t *\n\t * // Later, restore from snapshot\n\t * const restoredRoom = new TLSyncRoom({\n\t *   schema: mySchema,\n\t *   snapshot: snapshot\n\t * })\n\t * ```\n\t */\n\tgetSnapshot(): RoomSnapshot {\n\t\tconst tombstones = Object.fromEntries(this.tombstones.entries())\n\t\tconst documents = []\n\t\tfor (const doc of this.documents.values()) {\n\t\t\tif (this.documentTypes.has(doc.state.typeName)) {\n\t\t\t\tdocuments.push({\n\t\t\t\t\tstate: doc.state,\n\t\t\t\t\tlastChangedClock: doc.lastChangedClock,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tclock: this.clock,\n\t\t\tdocumentClock: this.documentClock,\n\t\t\ttombstones,\n\t\t\ttombstoneHistoryStartsAtClock: this.tombstoneHistoryStartsAtClock,\n\t\t\tschema: this.serializedSchema,\n\t\t\tdocuments,\n\t\t}\n\t}\n\n\t/**\n\t * Send a message to a particular client. Debounces data events\n\t *\n\t * @param sessionId - The id of the session to send the message to.\n\t * @param message - The message to send.\n\t */\n\tprivate sendMessage(\n\t\tsessionId: string,\n\t\tmessage: TLSocketServerSentEvent<R> | TLSocketServerSentDataEvent<R>\n\t) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to send message to unknown session', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.state !== RoomSessionState.Connected) {\n\t\t\tthis.log?.warn?.('Tried to send message to disconnected client', message.type)\n\t\t\treturn\n\t\t}\n\t\tif (session.socket.isOpen) {\n\t\t\tif (message.type !== 'patch' && message.type !== 'push_result') {\n\t\t\t\t// this is not a data message\n\t\t\t\tif (message.type !== 'pong') {\n\t\t\t\t\t// non-data messages like \"connect\" might still need to be ordered correctly with\n\t\t\t\t\t// respect to data messages, so it's better to flush just in case\n\t\t\t\t\tthis._flushDataMessages(sessionId)\n\t\t\t\t}\n\t\t\t\tsession.socket.sendMessage(message)\n\t\t\t} else {\n\t\t\t\tif (session.debounceTimer === null) {\n\t\t\t\t\t// this is the first message since the last flush, don't delay it\n\t\t\t\t\tsession.socket.sendMessage({ type: 'data', data: [message] })\n\n\t\t\t\t\tsession.debounceTimer = setTimeout(\n\t\t\t\t\t\t() => this._flushDataMessages(sessionId),\n\t\t\t\t\t\tDATA_MESSAGE_DEBOUNCE_INTERVAL\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tsession.outstandingDataMessages.push(message)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cancelSession(session.sessionId)\n\t\t}\n\t}\n\n\t// needs to accept sessionId and not a session because the session might be dead by the time\n\t// the timer fires\n\t_flushDataMessages(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\n\t\tif (!session || session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\tsession.debounceTimer = null\n\n\t\tif (session.outstandingDataMessages.length > 0) {\n\t\t\tsession.socket.sendMessage({ type: 'data', data: session.outstandingDataMessages })\n\t\t\tsession.outstandingDataMessages.length = 0\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate removeSession(sessionId: string, fatalReason?: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Tried to remove unknown session')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.delete(sessionId)\n\n\t\tconst presence = this.getDocument(session.presenceId ?? '')\n\n\t\ttry {\n\t\t\tif (fatalReason) {\n\t\t\t\tsession.socket.close(TLSyncErrorCloseEventCode, fatalReason)\n\t\t\t} else {\n\t\t\t\tsession.socket.close()\n\t\t\t}\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\n\t\tif (presence) {\n\t\t\tthis.documents.delete(session.presenceId!)\n\n\t\t\tthis.broadcastPatch({\n\t\t\t\tdiff: { [session.presenceId!]: [RecordOpType.Remove] },\n\t\t\t\tsourceSessionId: sessionId,\n\t\t\t})\n\t\t}\n\n\t\tthis.events.emit('session_removed', { sessionId, meta: session.meta })\n\t\tif (this.sessions.size === 0) {\n\t\t\tthis.events.emit('room_became_empty')\n\t\t}\n\t}\n\n\tprivate cancelSession(sessionId: string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\treturn\n\t\t}\n\n\t\tif (session.state === RoomSessionState.AwaitingRemoval) {\n\t\t\tthis.log?.warn?.('Tried to cancel session that is already awaiting removal')\n\t\t\treturn\n\t\t}\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingRemoval,\n\t\t\tsessionId,\n\t\t\tpresenceId: session.presenceId,\n\t\t\tsocket: session.socket,\n\t\t\tcancellationTime: Date.now(),\n\t\t\tmeta: session.meta,\n\t\t\tisReadonly: session.isReadonly,\n\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t})\n\n\t\ttry {\n\t\t\tsession.socket.close()\n\t\t} catch {\n\t\t\t// noop, calling .close() multiple times is fine\n\t\t}\n\t}\n\n\t/**\n\t * Broadcast a patch to all connected clients except the one with the sessionId provided.\n\t * Automatically handles schema migration for clients on different versions.\n\t *\n\t * @param message - The broadcast message\n\t *   - diff - The network diff to broadcast to all clients\n\t *   - sourceSessionId - Optional ID of the session that originated this change (excluded from broadcast)\n\t * @returns This room instance for method chaining\n\t * @example\n\t * ```ts\n\t * room.broadcastPatch({\n\t *   diff: { 'shape:123': [RecordOpType.Put, newShapeData] },\n\t *   sourceSessionId: 'user-456' // This user won't receive the broadcast\n\t * })\n\t * ```\n\t */\n\tbroadcastPatch(message: { diff: NetworkDiff<R>; sourceSessionId?: string }) {\n\t\tconst { diff, sourceSessionId } = message\n\t\tthis.sessions.forEach((session) => {\n\t\t\tif (session.state !== RoomSessionState.Connected) return\n\t\t\tif (sourceSessionId === session.sessionId) return\n\t\t\tif (!session.socket.isOpen) {\n\t\t\t\tthis.cancelSession(session.sessionId)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst res = this.migrateDiffForSession(session.serializedSchema, diff)\n\n\t\t\tif (!res.ok) {\n\t\t\t\t// disconnect client and send incompatibility error\n\t\t\t\tthis.rejectSession(\n\t\t\t\t\tsession.sessionId,\n\t\t\t\t\tres.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\ttype: 'patch',\n\t\t\t\tdiff: res.value,\n\t\t\t\tserverClock: this.clock,\n\t\t\t})\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * Send a custom message to a connected client. Useful for application-specific\n\t * communication that doesn't involve document synchronization.\n\t *\n\t * @param sessionId - The ID of the session to send the message to\n\t * @param data - The custom payload to send (will be JSON serialized)\n\t * @example\n\t * ```ts\n\t * // Send a custom notification\n\t * room.sendCustomMessage('user-123', {\n\t *   type: 'notification',\n\t *   message: 'Document saved successfully'\n\t * })\n\t *\n\t * // Send user-specific data\n\t * room.sendCustomMessage('user-456', {\n\t *   type: 'user_permissions',\n\t *   canEdit: true,\n\t *   canDelete: false\n\t * })\n\t * ```\n\t */\n\tsendCustomMessage(sessionId: string, data: any): void {\n\t\tthis.sendMessage(sessionId, { type: 'custom', data })\n\t}\n\n\t/**\n\t * Register a new client session with the room. The session will be in an awaiting\n\t * state until it sends a connect message with protocol handshake.\n\t *\n\t * @param opts - Session configuration\n\t *   - sessionId - Unique identifier for this session\n\t *   - socket - WebSocket adapter for communication\n\t *   - meta - Application-specific metadata for this session\n\t *   - isReadonly - Whether this session can modify documents\n\t * @returns This room instance for method chaining\n\t * @example\n\t * ```ts\n\t * room.handleNewSession({\n\t *   sessionId: crypto.randomUUID(),\n\t *   socket: new WebSocketAdapter(ws),\n\t *   meta: { userId: '123', name: 'Alice', avatar: 'url' },\n\t *   isReadonly: !hasEditPermission\n\t * })\n\t * ```\n\t *\n\t * @internal\n\t */\n\thandleNewSession(opts: {\n\t\tsessionId: string\n\t\tsocket: TLRoomSocket<R>\n\t\tmeta: SessionMeta\n\t\tisReadonly: boolean\n\t}) {\n\t\tconst { sessionId, socket, meta, isReadonly } = opts\n\t\tconst existing = this.sessions.get(sessionId)\n\t\tthis.sessions.set(sessionId, {\n\t\t\tstate: RoomSessionState.AwaitingConnectMessage,\n\t\t\tsessionId,\n\t\t\tsocket,\n\t\t\tpresenceId: existing?.presenceId ?? this.presenceType?.createId() ?? null,\n\t\t\tsessionStartTime: Date.now(),\n\t\t\tmeta,\n\t\t\tisReadonly: isReadonly ?? false,\n\t\t\t// this gets set later during handleConnectMessage\n\t\t\trequiresLegacyRejection: false,\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * When we send a diff to a client, if that client is on a lower version than us, we need to make\n\t * the diff compatible with their version. At the moment this means migrating each affected record\n\t * to the client's version and sending the whole record again. We can optimize this later by\n\t * keeping the previous versions of records around long enough to recalculate these diffs for\n\t * older client versions.\n\t */\n\tprivate migrateDiffForSession(\n\t\tserializedSchema: SerializedSchema,\n\t\tdiff: NetworkDiff<R>\n\t): Result<NetworkDiff<R>, MigrationFailureReason> {\n\t\t// TODO: optimize this by recalculating patches using the previous versions of records\n\n\t\t// when the client connects we check whether the schema is identical and make sure\n\t\t// to use the same object reference so that === works on this line\n\t\tif (serializedSchema === this.serializedSchema) {\n\t\t\treturn Result.ok(diff)\n\t\t}\n\n\t\tconst result: NetworkDiff<R> = {}\n\t\tfor (const [id, op] of objectMapEntriesIterable(diff)) {\n\t\t\tif (op[0] === RecordOpType.Remove) {\n\t\t\t\tresult[id] = op\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst doc = this.getDocument(id)\n\t\t\tif (!doc) {\n\t\t\t\treturn Result.err(MigrationFailureReason.TargetVersionTooNew)\n\t\t\t}\n\t\t\tconst migrationResult = this.schema.migratePersistedRecord(\n\t\t\t\tdoc.state,\n\t\t\t\tserializedSchema,\n\t\t\t\t'down'\n\t\t\t)\n\n\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\treturn Result.err(migrationResult.reason)\n\t\t\t}\n\n\t\t\tresult[id] = [RecordOpType.Put, migrationResult.value]\n\t\t}\n\n\t\treturn Result.ok(result)\n\t}\n\n\t/**\n\t * Process an incoming message from a client session. Handles connection requests,\n\t * data synchronization pushes, and ping/pong for connection health.\n\t *\n\t * @param sessionId - The ID of the session that sent the message\n\t * @param message - The client message to process\n\t * @example\n\t * ```ts\n\t * // Typically called by WebSocket message handlers\n\t * websocket.onMessage((data) => {\n\t *   const message = JSON.parse(data)\n\t *   room.handleMessage(sessionId, message)\n\t * })\n\t * ```\n\t */\n\tasync handleMessage(sessionId: string, message: TLSocketClientSentEvent<R>) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) {\n\t\t\tthis.log?.warn?.('Received message from unknown session')\n\t\t\treturn\n\t\t}\n\t\tswitch (message.type) {\n\t\t\tcase 'connect': {\n\t\t\t\treturn this.handleConnectRequest(session, message)\n\t\t\t}\n\t\t\tcase 'push': {\n\t\t\t\treturn this.handlePushRequest(session, message)\n\t\t\t}\n\t\t\tcase 'ping': {\n\t\t\t\tif (session.state === RoomSessionState.Connected) {\n\t\t\t\t\tsession.lastInteractionTime = Date.now()\n\t\t\t\t}\n\t\t\t\treturn this.sendMessage(session.sessionId, { type: 'pong' })\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\texhaustiveSwitchError(message)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reject and disconnect a session due to incompatibility or other fatal errors.\n\t * Sends appropriate error messages before closing the connection.\n\t *\n\t * @param sessionId - The session to reject\n\t * @param fatalReason - The reason for rejection (optional)\n\t * @example\n\t * ```ts\n\t * // Reject due to version mismatch\n\t * room.rejectSession('user-123', TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t *\n\t * // Reject due to permission issue\n\t * room.rejectSession('user-456', 'Insufficient permissions')\n\t * ```\n\t */\n\trejectSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tconst session = this.sessions.get(sessionId)\n\t\tif (!session) return\n\t\tif (!fatalReason) {\n\t\t\tthis.removeSession(sessionId)\n\t\t\treturn\n\t\t}\n\t\tif (session.requiresLegacyRejection) {\n\t\t\ttry {\n\t\t\t\tif (session.socket.isOpen) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\tlet legacyReason: TLIncompatibilityReason\n\t\t\t\t\tswitch (fatalReason) {\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.CLIENT_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ClientTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.SERVER_TOO_OLD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.ServerTooOld\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase TLSyncErrorCloseEventReason.INVALID_RECORD:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidRecord\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\t\tlegacyReason = TLIncompatibilityReason.InvalidOperation\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tsession.socket.sendMessage({\n\t\t\t\t\t\ttype: 'incompatibility_error',\n\t\t\t\t\t\treason: legacyReason,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// noop\n\t\t\t} finally {\n\t\t\t\tthis.removeSession(sessionId)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.removeSession(sessionId, fatalReason)\n\t\t}\n\t}\n\n\tprivate handleConnectRequest(\n\t\tsession: RoomSession<R, SessionMeta>,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'connect' }>\n\t) {\n\t\t// if the protocol versions don't match, disconnect the client\n\t\t// we will eventually want to try to make our protocol backwards compatible to some degree\n\t\t// and have a MIN_PROTOCOL_VERSION constant that the TLSyncRoom implements support for\n\t\tlet theirProtocolVersion = message.protocolVersion\n\t\t// 5 is the same as 6\n\t\tif (theirProtocolVersion === 5) {\n\t\t\ttheirProtocolVersion = 6\n\t\t}\n\t\t// 6 is almost the same as 7\n\t\tsession.requiresLegacyRejection = theirProtocolVersion === 6\n\t\tif (theirProtocolVersion === 6) {\n\t\t\ttheirProtocolVersion++\n\t\t}\n\n\t\tif (theirProtocolVersion == null || theirProtocolVersion < getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t} else if (theirProtocolVersion > getTlsyncProtocolVersion()) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.SERVER_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\t// If the client's store is at a different version to ours, it could cause corruption.\n\t\t// We should disconnect the client and ask them to refresh.\n\t\tif (message.schema == null) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\t\tconst migrations = this.schema.getMigrationsSince(message.schema)\n\t\t// if the client's store is at a different version to ours, we can't support them\n\t\tif (!migrations.ok || migrations.value.some((m) => m.scope === 'store' || !m.down)) {\n\t\t\tthis.rejectSession(session.sessionId, TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\treturn\n\t\t}\n\n\t\tconst sessionSchema = isEqual(message.schema, this.serializedSchema)\n\t\t\t? this.serializedSchema\n\t\t\t: message.schema\n\n\t\tconst connect = async (msg: Extract<TLSocketServerSentEvent<R>, { type: 'connect' }>) => {\n\t\t\tthis.sessions.set(session.sessionId, {\n\t\t\t\tstate: RoomSessionState.Connected,\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tpresenceId: session.presenceId,\n\t\t\t\tsocket: session.socket,\n\t\t\t\tserializedSchema: sessionSchema,\n\t\t\t\tlastInteractionTime: Date.now(),\n\t\t\t\tdebounceTimer: null,\n\t\t\t\toutstandingDataMessages: [],\n\t\t\t\tmeta: session.meta,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\trequiresLegacyRejection: session.requiresLegacyRejection,\n\t\t\t})\n\t\t\tthis.sendMessage(session.sessionId, msg)\n\t\t}\n\n\t\ttransaction((rollback) => {\n\t\t\tif (\n\t\t\t\t// if the client requests changes since a time before we have tombstone history, send them the full state\n\t\t\t\tmessage.lastServerClock < this.tombstoneHistoryStartsAtClock ||\n\t\t\t\t// similarly, if they ask for a time we haven't reached yet, send them the full state\n\t\t\t\t// this will only happen if the DB is reset (or there is no db) and the server restarts\n\t\t\t\t// or if the server exits/crashes with unpersisted changes\n\t\t\t\tmessage.lastServerClock > this.clock\n\t\t\t) {\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tfor (const [id, doc] of this.documents.entries()) {\n\t\t\t\t\tif (id !== session.presenceId) {\n\t\t\t\t\t\tdiff[id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_all',\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// calculate the changes since the time the client last saw\n\t\t\t\tconst diff: NetworkDiff<R> = {}\n\t\t\t\tfor (const doc of this.documents.values()) {\n\t\t\t\t\tif (doc.lastChangedClock > message.lastServerClock) {\n\t\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t} else if (this.presenceType?.isId(doc.state.id) && doc.state.id !== session.presenceId) {\n\t\t\t\t\t\tdiff[doc.state.id] = [RecordOpType.Put, doc.state]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const [id, deletedAtClock] of this.tombstones.entries()) {\n\t\t\t\t\tif (deletedAtClock > message.lastServerClock) {\n\t\t\t\t\t\tdiff[id] = [RecordOpType.Remove]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst migrated = this.migrateDiffForSession(sessionSchema, diff)\n\t\t\t\tif (!migrated.ok) {\n\t\t\t\t\trollback()\n\t\t\t\t\tthis.rejectSession(\n\t\t\t\t\t\tsession.sessionId,\n\t\t\t\t\t\tmigrated.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconnect({\n\t\t\t\t\ttype: 'connect',\n\t\t\t\t\tconnectRequestId: message.connectRequestId,\n\t\t\t\t\thydrationType: 'wipe_presence',\n\t\t\t\t\tschema: this.schema.serialize(),\n\t\t\t\t\tprotocolVersion: getTlsyncProtocolVersion(),\n\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\tdiff: migrated.value,\n\t\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate handlePushRequest(\n\t\tsession: RoomSession<R, SessionMeta> | null,\n\t\tmessage: Extract<TLSocketClientSentEvent<R>, { type: 'push' }>\n\t) {\n\t\t// We must be connected to handle push requests\n\t\tif (session && session.state !== RoomSessionState.Connected) {\n\t\t\treturn\n\t\t}\n\n\t\t// update the last interaction time\n\t\tif (session) {\n\t\t\tsession.lastInteractionTime = Date.now()\n\t\t}\n\n\t\t// increment the clock for this push\n\t\tthis.clock++\n\n\t\tconst initialDocumentClock = this.documentClock\n\t\tlet didPresenceChange = false\n\t\ttransaction((rollback) => {\n\t\t\t// collect actual ops that resulted from the push\n\t\t\t// these will be broadcast to other users\n\t\t\tinterface ActualChanges {\n\t\t\t\tdiff: NetworkDiff<R> | null\n\t\t\t}\n\t\t\tconst docChanges: ActualChanges = { diff: null }\n\t\t\tconst presenceChanges: ActualChanges = { diff: null }\n\n\t\t\tconst propagateOp = (changes: ActualChanges, id: string, op: RecordOp<R>) => {\n\t\t\t\tif (!changes.diff) changes.diff = {}\n\t\t\t\tchanges.diff[id] = op\n\t\t\t}\n\n\t\t\tconst fail = (\n\t\t\t\treason: TLSyncErrorCloseEventReason,\n\t\t\t\tunderlyingError?: Error\n\t\t\t): Result<void, void> => {\n\t\t\t\trollback()\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.rejectSession(session.sessionId, reason)\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('failed to apply changes: ' + reason, underlyingError)\n\t\t\t\t}\n\t\t\t\tif (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n\t\t\t\t\tthis.log?.error?.('failed to apply push', reason, message, underlyingError)\n\t\t\t\t}\n\t\t\t\treturn Result.err(undefined)\n\t\t\t}\n\n\t\t\tconst addDocument = (changes: ActualChanges, id: string, _state: R): Result<void, void> => {\n\t\t\t\tconst res = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(_state, session.serializedSchema, 'up')\n\t\t\t\t\t: { type: 'success' as const, value: _state }\n\t\t\t\tif (res.type === 'error') {\n\t\t\t\t\treturn fail(\n\t\t\t\t\t\tres.reason === MigrationFailureReason.TargetVersionTooOld // target version is our version\n\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst { value: state } = res\n\n\t\t\t\t// Get the existing document, if any\n\t\t\t\tconst doc = this.getDocument(id)\n\n\t\t\t\tif (doc) {\n\t\t\t\t\t// If there's an existing document, replace it with the new state\n\t\t\t\t\t// but propagate a diff rather than the entire value\n\t\t\t\t\tconst diff = doc.replaceState(state, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tthis.documents.set(id, diff.value[1])\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value[0]])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, if we don't already have a document with this id\n\t\t\t\t\t// create the document and propagate the put op\n\t\t\t\t\tconst result = this.addDocument(id, state, this.clock)\n\t\t\t\t\tif (!result.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Put, state])\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst patchDocument = (\n\t\t\t\tchanges: ActualChanges,\n\t\t\t\tid: string,\n\t\t\t\tpatch: ObjectDiff\n\t\t\t): Result<void, void> => {\n\t\t\t\t// if it was already deleted, there's no need to apply the patch\n\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\tif (!doc) return Result.ok(undefined)\n\t\t\t\t// If the client's version of the record is older than ours,\n\t\t\t\t// we apply the patch to the downgraded version of the record\n\t\t\t\tconst downgraded = session\n\t\t\t\t\t? this.schema.migratePersistedRecord(doc.state, session.serializedSchema, 'down')\n\t\t\t\t\t: { type: 'success' as const, value: doc.state }\n\t\t\t\tif (downgraded.type === 'error') {\n\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t}\n\n\t\t\t\tif (downgraded.value === doc.state) {\n\t\t\t\t\t// If the versions are compatible, apply the patch and propagate the patch op\n\t\t\t\t\tconst diff = doc.mergeDiff(patch, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tthis.documents.set(id, diff.value[1])\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value[0]])\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// need to apply the patch to the downgraded version and then upgrade it\n\n\t\t\t\t\t// apply the patch to the downgraded version\n\t\t\t\t\tconst patched = applyObjectDiff(downgraded.value, patch)\n\t\t\t\t\t// then upgrade the patched version and use that as the new state\n\t\t\t\t\tconst upgraded = session\n\t\t\t\t\t\t? this.schema.migratePersistedRecord(patched, session.serializedSchema, 'up')\n\t\t\t\t\t\t: { type: 'success' as const, value: patched }\n\t\t\t\t\t// If the client's version is too old, we'll hit an error\n\t\t\t\t\tif (upgraded.type === 'error') {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.CLIENT_TOO_OLD)\n\t\t\t\t\t}\n\t\t\t\t\t// replace the state with the upgraded version and propagate the patch op\n\t\t\t\t\tconst diff = doc.replaceState(upgraded.value, this.clock)\n\t\t\t\t\tif (!diff.ok) {\n\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t}\n\t\t\t\t\tif (diff.value) {\n\t\t\t\t\t\tthis.documents.set(id, diff.value[1])\n\t\t\t\t\t\tpropagateOp(changes, id, [RecordOpType.Patch, diff.value[0]])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Result.ok(undefined)\n\t\t\t}\n\n\t\t\tconst { clientClock } = message\n\n\t\t\tif (this.presenceType && session?.presenceId && 'presence' in message && message.presence) {\n\t\t\t\tif (!session) throw new Error('session is required for presence pushes')\n\t\t\t\t// The push request was for the presence scope.\n\t\t\t\tconst id = session.presenceId\n\t\t\t\tconst [type, val] = message.presence\n\t\t\t\tconst { typeName } = this.presenceType\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t// Try to put the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = addDocument(presenceChanges, id, { ...val, id, typeName })\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\tconst res = patchDocument(presenceChanges, id, {\n\t\t\t\t\t\t\t...val,\n\t\t\t\t\t\t\tid: [ValueOpType.Put, id],\n\t\t\t\t\t\t\ttypeName: [ValueOpType.Put, typeName],\n\t\t\t\t\t\t})\n\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (message.diff && !session?.isReadonly) {\n\t\t\t\t// The push request was for the document scope.\n\t\t\t\tfor (const [id, op] of objectMapEntriesIterable(message.diff!)) {\n\t\t\t\t\tswitch (op[0]) {\n\t\t\t\t\t\tcase RecordOpType.Put: {\n\t\t\t\t\t\t\t// Try to add the document.\n\t\t\t\t\t\t\t// If we're putting a record with a type that we don't recognize, fail\n\t\t\t\t\t\t\tif (!this.documentTypes.has(op[1].typeName)) {\n\t\t\t\t\t\t\t\treturn fail(TLSyncErrorCloseEventReason.INVALID_RECORD)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst res = addDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Patch: {\n\t\t\t\t\t\t\t// Try to patch the document. If it fails, stop here.\n\t\t\t\t\t\t\tconst res = patchDocument(docChanges, id, op[1])\n\t\t\t\t\t\t\t// if res.ok is false here then we already called `fail` and we should stop immediately\n\t\t\t\t\t\t\tif (!res.ok) return\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase RecordOpType.Remove: {\n\t\t\t\t\t\t\tconst doc = this.getDocument(id)\n\t\t\t\t\t\t\tif (!doc) {\n\t\t\t\t\t\t\t\t// If the doc was already deleted, don't do anything, no need to propagate a delete op\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Delete the document and propagate the delete op\n\t\t\t\t\t\t\tthis.removeDocument(id, this.clock)\n\t\t\t\t\t\t\t// Schedule a pruneTombstones call to happen on the next call stack\n\t\t\t\t\t\t\tpropagateOp(docChanges, id, op)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the client know what action to take based on the results of the push\n\t\t\tif (\n\t\t\t\t// if there was only a presence push, the client doesn't need to do anything aside from\n\t\t\t\t// shift the push request.\n\t\t\t\t!message.diff ||\n\t\t\t\tisEqual(docChanges.diff, message.diff)\n\t\t\t) {\n\t\t\t\t// COMMIT\n\t\t\t\t// Applying the client's changes had the exact same effect on the server as\n\t\t\t\t// they had on the client, so the client should keep the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'commit',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else if (!docChanges.diff) {\n\t\t\t\t// DISCARD\n\t\t\t\t// Applying the client's changes had no effect, so the client should drop the diff\n\t\t\t\tif (session) {\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: 'discard',\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// REBASE\n\t\t\t\t// Applying the client's changes had a different non-empty effect on the server,\n\t\t\t\t// so the client should rebase with our gold-standard / authoritative diff.\n\t\t\t\t// First we need to migrate the diff to the client's version\n\t\t\t\tif (session) {\n\t\t\t\t\tconst migrateResult = this.migrateDiffForSession(\n\t\t\t\t\t\tsession.serializedSchema,\n\t\t\t\t\t\tdocChanges.diff\n\t\t\t\t\t)\n\t\t\t\t\tif (!migrateResult.ok) {\n\t\t\t\t\t\treturn fail(\n\t\t\t\t\t\t\tmigrateResult.error === MigrationFailureReason.TargetVersionTooNew\n\t\t\t\t\t\t\t\t? TLSyncErrorCloseEventReason.SERVER_TOO_OLD\n\t\t\t\t\t\t\t\t: TLSyncErrorCloseEventReason.CLIENT_TOO_OLD\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\t// If the migration worked, send the rebased diff to the client\n\t\t\t\t\tthis.sendMessage(session.sessionId, {\n\t\t\t\t\t\ttype: 'push_result',\n\t\t\t\t\t\tserverClock: this.clock,\n\t\t\t\t\t\tclientClock,\n\t\t\t\t\t\taction: { rebaseWithDiff: migrateResult.value },\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are merged changes, broadcast them to all other clients\n\t\t\tif (docChanges.diff || presenceChanges.diff) {\n\t\t\t\tthis.broadcastPatch({\n\t\t\t\t\tsourceSessionId: session?.sessionId,\n\t\t\t\t\tdiff: {\n\t\t\t\t\t\t...docChanges.diff,\n\t\t\t\t\t\t...presenceChanges.diff,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (docChanges.diff) {\n\t\t\t\tthis.documentClock = this.clock\n\t\t\t}\n\t\t\tif (presenceChanges.diff) {\n\t\t\t\tdidPresenceChange = true\n\t\t\t}\n\n\t\t\treturn\n\t\t})\n\n\t\t// if it threw the changes will have been rolled back and the document clock will not have been incremented\n\t\tif (this.documentClock !== initialDocumentClock) {\n\t\t\tthis.onDataChange?.()\n\t\t}\n\n\t\tif (didPresenceChange) {\n\t\t\tthis.onPresenceChange?.()\n\t\t}\n\t}\n\n\t/**\n\t * Handle the event when a client disconnects. Cleans up the session and\n\t * removes any presence information.\n\t *\n\t * @param sessionId - The session that disconnected\n\t * @example\n\t * ```ts\n\t * websocket.onClose(() => {\n\t *   room.handleClose(sessionId)\n\t * })\n\t * ```\n\t */\n\thandleClose(sessionId: string) {\n\t\tthis.cancelSession(sessionId)\n\t}\n\n\t/**\n\t * Apply changes to the room's store in a transactional way. Changes are\n\t * automatically synchronized to all connected clients.\n\t *\n\t * @param updater - Function that receives store methods to make changes\n\t * @returns Promise that resolves when the transaction is complete\n\t * @example\n\t * ```ts\n\t * // Add multiple shapes atomically\n\t * await room.updateStore((store) => {\n\t *   store.put(createShape({ type: 'geo', x: 100, y: 100 }))\n\t *   store.put(createShape({ type: 'text', x: 200, y: 200 }))\n\t * })\n\t *\n\t * // Async operations are supported\n\t * await room.updateStore(async (store) => {\n\t *   const template = await loadTemplate()\n\t *   template.shapes.forEach(shape => store.put(shape))\n\t * })\n\t * ```\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\tif (this._isClosed) {\n\t\t\tthrow new Error('Cannot update store on a closed room')\n\t\t}\n\t\tconst context = new StoreUpdateContext<R>(\n\t\t\tObject.fromEntries(this.getSnapshot().documents.map((d) => [d.state.id, d.state]))\n\t\t)\n\t\ttry {\n\t\t\tawait updater(context)\n\t\t} finally {\n\t\t\tcontext.close()\n\t\t}\n\n\t\tconst diff = context.toDiff()\n\t\tif (Object.keys(diff).length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.handlePushRequest(null, { type: 'push', diff, clientClock: 0 })\n\t}\n}\n\n/**\n * Interface for making transactional changes to room store data. Used within\n * updateStore transactions to modify documents atomically.\n *\n * @example\n * ```ts\n * await room.updateStore((store) => {\n *   const shape = store.get('shape:123')\n *   if (shape) {\n *     store.put({ ...shape, x: shape.x + 10 })\n *   }\n *   store.delete('shape:456')\n * })\n * ```\n *\n * @public\n */\nexport interface RoomStoreMethods<R extends UnknownRecord = UnknownRecord> {\n\t/**\n\t * Add or update a record in the store.\n\t *\n\t * @param record - The record to store\n\t */\n\tput(record: R): void\n\t/**\n\t * Delete a record from the store.\n\t *\n\t * @param recordOrId - The record or record ID to delete\n\t */\n\tdelete(recordOrId: R | string): void\n\t/**\n\t * Get a record by its ID.\n\t *\n\t * @param id - The record ID\n\t * @returns The record or null if not found\n\t */\n\tget(id: string): R | null\n\t/**\n\t * Get all records in the store.\n\t *\n\t * @returns Array of all records\n\t */\n\tgetAll(): R[]\n}\n\nclass StoreUpdateContext<R extends UnknownRecord> implements RoomStoreMethods<R> {\n\tconstructor(private readonly snapshot: Record<string, UnknownRecord>) {}\n\tprivate readonly updates = {\n\t\tputs: {} as Record<string, UnknownRecord>,\n\t\tdeletes: new Set<string>(),\n\t}\n\tput(record: R): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (record.id in this.snapshot && isEqual(this.snapshot[record.id], record)) {\n\t\t\tdelete this.updates.puts[record.id]\n\t\t} else {\n\t\t\tthis.updates.puts[record.id] = structuredClone(record)\n\t\t}\n\t\tthis.updates.deletes.delete(record.id)\n\t}\n\tdelete(recordOrId: R | string): void {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst id = typeof recordOrId === 'string' ? recordOrId : recordOrId.id\n\t\tdelete this.updates.puts[id]\n\t\tif (this.snapshot[id]) {\n\t\t\tthis.updates.deletes.add(id)\n\t\t}\n\t}\n\tget(id: string): R | null {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tif (hasOwnProperty(this.updates.puts, id)) {\n\t\t\treturn structuredClone(this.updates.puts[id]) as R\n\t\t}\n\t\tif (this.updates.deletes.has(id)) {\n\t\t\treturn null\n\t\t}\n\t\treturn structuredClone(this.snapshot[id] ?? null) as R\n\t}\n\n\tgetAll(): R[] {\n\t\tif (this._isClosed) throw new Error('StoreUpdateContext is closed')\n\t\tconst result = Object.values(this.updates.puts)\n\t\tfor (const [id, record] of Object.entries(this.snapshot)) {\n\t\t\tif (!this.updates.deletes.has(id) && !hasOwnProperty(this.updates.puts, id)) {\n\t\t\t\tresult.push(record)\n\t\t\t}\n\t\t}\n\t\treturn structuredClone(result) as R[]\n\t}\n\n\ttoDiff(): NetworkDiff<any> {\n\t\tconst diff: NetworkDiff<R> = {}\n\t\tfor (const [id, record] of Object.entries(this.updates.puts)) {\n\t\t\tdiff[id] = [RecordOpType.Put, record as R]\n\t\t}\n\t\tfor (const id of this.updates.deletes) {\n\t\t\tdiff[id] = [RecordOpType.Remove]\n\t\t}\n\t\treturn diff\n\t}\n\n\tprivate _isClosed = false\n\tclose() {\n\t\tthis._isClosed = true\n\t}\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2745, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/lib/TLSocketRoom.ts"],"sourcesContent":["import type { StoreSchema, UnknownRecord } from '@tldraw/store'\nimport { TLStoreSnapshot, createTLSchema } from '@tldraw/tlschema'\nimport { objectMapValues, structuredClone } from '@tldraw/utils'\nimport { RoomSessionState } from './RoomSession'\nimport { ServerSocketAdapter, WebSocketMinimal } from './ServerSocketAdapter'\nimport { TLSyncErrorCloseEventReason } from './TLSyncClient'\nimport { RoomSnapshot, RoomStoreMethods, TLSyncRoom } from './TLSyncRoom'\nimport { JsonChunkAssembler } from './chunk'\nimport { TLSocketServerSentEvent } from './protocol'\n\n/**\n * Logging interface for TLSocketRoom operations. Provides optional methods\n * for warning and error logging during synchronization operations.\n *\n * @example\n * ```ts\n * const logger: TLSyncLog = {\n *   warn: (...args) => console.warn('[SYNC]', ...args),\n *   error: (...args) => console.error('[SYNC]', ...args)\n * }\n *\n * const room = new TLSocketRoom({ log: logger })\n * ```\n *\n * @public\n */\nexport interface TLSyncLog {\n\t/**\n\t * Optional warning logger for non-fatal sync issues\n\t * @param args - Arguments to log\n\t */\n\twarn?(...args: any[]): void\n\t/**\n\t * Optional error logger for sync errors and failures\n\t * @param args - Arguments to log\n\t */\n\terror?(...args: any[]): void\n}\n\n/**\n * A server-side room that manages WebSocket connections and synchronizes tldraw document state\n * between multiple clients in real-time. Each room represents a collaborative document space\n * where users can work together on drawings with automatic conflict resolution.\n *\n * TLSocketRoom handles:\n * - WebSocket connection lifecycle management\n * - Real-time synchronization of document changes\n * - Session management and presence tracking\n * - Message chunking for large payloads\n * - Automatic client timeout and cleanup\n *\n * @example\n * ```ts\n * // Basic room setup\n * const room = new TLSocketRoom({\n *   onSessionRemoved: (room, { sessionId, numSessionsRemaining }) => {\n *     console.log(`Client ${sessionId} disconnected, ${numSessionsRemaining} remaining`)\n *     if (numSessionsRemaining === 0) {\n *       room.close()\n *     }\n *   },\n *   onDataChange: () => {\n *     console.log('Document data changed, consider persisting')\n *   }\n * })\n *\n * // Handle new client connections\n * room.handleSocketConnect({\n *   sessionId: 'user-session-123',\n *   socket: webSocket,\n *   isReadonly: false\n * })\n * ```\n *\n * @example\n * ```ts\n * // Room with initial snapshot and schema\n * const room = new TLSocketRoom({\n *   initialSnapshot: existingSnapshot,\n *   schema: myCustomSchema,\n *   clientTimeout: 30000,\n *   log: {\n *     warn: (...args) => logger.warn('SYNC:', ...args),\n *     error: (...args) => logger.error('SYNC:', ...args)\n *   }\n * })\n *\n * // Update document programmatically\n * await room.updateStore(store => {\n *   const shape = store.get('shape:abc123')\n *   if (shape) {\n *     shape.x = 100\n *     store.put(shape)\n *   }\n * })\n * ```\n *\n * @public\n */\nexport class TLSocketRoom<R extends UnknownRecord = UnknownRecord, SessionMeta = void> {\n\tprivate room: TLSyncRoom<R, SessionMeta>\n\tprivate readonly sessions = new Map<\n\t\tstring,\n\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t{ assembler: JsonChunkAssembler; socket: WebSocketMinimal; unlisten: () => void }\n\t>()\n\treadonly log?: TLSyncLog\n\tprivate readonly syncCallbacks: {\n\t\tonDataChange?(): void\n\t\tonPresenceChange?(): void\n\t}\n\n\t/**\n\t * Creates a new TLSocketRoom instance for managing collaborative document synchronization.\n\t *\n\t * opts - Configuration options for the room\n\t *   - initialSnapshot - Optional initial document state to load\n\t *   - schema - Store schema defining record types and validation\n\t *   - clientTimeout - Milliseconds to wait before disconnecting inactive clients\n\t *   - log - Optional logger for warnings and errors\n\t *   - onSessionRemoved - Called when a client session is removed\n\t *   - onBeforeSendMessage - Called before sending messages to clients\n\t *   - onAfterReceiveMessage - Called after receiving messages from clients\n\t *   - onDataChange - Called when document data changes\n\t *   - onPresenceChange - Called when presence data changes\n\t */\n\tconstructor(\n\t\tpublic readonly opts: {\n\t\t\tinitialSnapshot?: RoomSnapshot | TLStoreSnapshot\n\t\t\tschema?: StoreSchema<R, any>\n\t\t\t// how long to wait for a client to communicate before disconnecting them\n\t\t\tclientTimeout?: number\n\t\t\tlog?: TLSyncLog\n\t\t\t// a callback that is called when a client is disconnected\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonSessionRemoved?: (\n\t\t\t\troom: TLSocketRoom<R, SessionMeta>,\n\t\t\t\targs: { sessionId: string; numSessionsRemaining: number; meta: SessionMeta }\n\t\t\t) => void\n\t\t\t// a callback that is called whenever a message is sent\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonBeforeSendMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\t\t\tonAfterReceiveMessage?: (args: {\n\t\t\t\tsessionId: string\n\t\t\t\t/** @internal keep the protocol private for now */\n\t\t\t\tmessage: TLSocketServerSentEvent<R>\n\t\t\t\tstringified: string\n\t\t\t\tmeta: SessionMeta\n\t\t\t}) => void\n\t\t\tonDataChange?(): void\n\t\t\t/** @internal */\n\t\t\tonPresenceChange?(): void\n\t\t}\n\t) {\n\t\tconst initialSnapshot =\n\t\t\topts.initialSnapshot && 'store' in opts.initialSnapshot\n\t\t\t\t? convertStoreSnapshotToRoomSnapshot(opts.initialSnapshot!)\n\t\t\t\t: opts.initialSnapshot\n\n\t\tthis.syncCallbacks = {\n\t\t\tonDataChange: opts.onDataChange,\n\t\t\tonPresenceChange: opts.onPresenceChange,\n\t\t}\n\t\tthis.room = new TLSyncRoom<R, SessionMeta>({\n\t\t\t...this.syncCallbacks,\n\t\t\tschema: opts.schema ?? (createTLSchema() as any),\n\t\t\tsnapshot: initialSnapshot,\n\t\t\tlog: opts.log,\n\t\t})\n\t\tthis.room.events.on('session_removed', (args) => {\n\t\t\tthis.sessions.delete(args.sessionId)\n\t\t\tif (this.opts.onSessionRemoved) {\n\t\t\t\tthis.opts.onSessionRemoved(this, {\n\t\t\t\t\tsessionId: args.sessionId,\n\t\t\t\t\tnumSessionsRemaining: this.room.sessions.size,\n\t\t\t\t\tmeta: args.meta,\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tthis.log = 'log' in opts ? opts.log : { error: console.error }\n\t}\n\n\t/**\n\t * Returns the number of active sessions.\n\t * Note that this is not the same as the number of connected sockets!\n\t * Sessions time out a few moments after sockets close, to smooth over network hiccups.\n\t *\n\t * @returns the number of active sessions\n\t */\n\tgetNumActiveSessions() {\n\t\treturn this.room.sessions.size\n\t}\n\n\t/**\n\t * Handles a new client WebSocket connection, creating a session within the room.\n\t * This should be called whenever a client establishes a WebSocket connection to join\n\t * the collaborative document.\n\t *\n\t * @param opts - Connection options\n\t *   - sessionId - Unique identifier for the client session (typically from browser tab)\n\t *   - socket - WebSocket-like object for client communication\n\t *   - isReadonly - Whether the client can modify the document (defaults to false)\n\t *   - meta - Additional session metadata (required if SessionMeta is not void)\n\t *\n\t * @example\n\t * ```ts\n\t * // Handle new WebSocket connection\n\t * room.handleSocketConnect({\n\t *   sessionId: 'user-session-abc123',\n\t *   socket: webSocketConnection,\n\t *   isReadonly: !userHasEditPermission\n\t * })\n\t * ```\n\t *\n\t * @example\n\t * ```ts\n\t * // With session metadata\n\t * room.handleSocketConnect({\n\t *   sessionId: 'session-xyz',\n\t *   socket: ws,\n\t *   meta: { userId: 'user-123', name: 'Alice' }\n\t * })\n\t * ```\n\t */\n\thandleSocketConnect(\n\t\topts: {\n\t\t\tsessionId: string\n\t\t\tsocket: WebSocketMinimal\n\t\t\tisReadonly?: boolean\n\t\t} & (SessionMeta extends void ? object : { meta: SessionMeta })\n\t) {\n\t\tconst { sessionId, socket, isReadonly = false } = opts\n\t\tconst handleSocketMessage = (event: MessageEvent) =>\n\t\t\tthis.handleSocketMessage(sessionId, event.data)\n\t\tconst handleSocketError = this.handleSocketError.bind(this, sessionId)\n\t\tconst handleSocketClose = this.handleSocketClose.bind(this, sessionId)\n\n\t\tthis.sessions.set(sessionId, {\n\t\t\tassembler: new JsonChunkAssembler(),\n\t\t\tsocket,\n\t\t\tunlisten: () => {\n\t\t\t\tsocket.removeEventListener?.('message', handleSocketMessage)\n\t\t\t\tsocket.removeEventListener?.('close', handleSocketClose)\n\t\t\t\tsocket.removeEventListener?.('error', handleSocketError)\n\t\t\t},\n\t\t})\n\n\t\tthis.room.handleNewSession({\n\t\t\tsessionId,\n\t\t\tisReadonly,\n\t\t\tsocket: new ServerSocketAdapter({\n\t\t\t\tws: socket,\n\t\t\t\tonBeforeSendMessage: this.opts.onBeforeSendMessage\n\t\t\t\t\t? (message, stringified) =>\n\t\t\t\t\t\t\tthis.opts.onBeforeSendMessage!({\n\t\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t\t\tstringified,\n\t\t\t\t\t\t\t\tmeta: this.room.sessions.get(sessionId)?.meta as SessionMeta,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: undefined,\n\t\t\t}),\n\t\t\tmeta: 'meta' in opts ? (opts.meta as any) : undefined,\n\t\t})\n\n\t\tsocket.addEventListener?.('message', handleSocketMessage)\n\t\tsocket.addEventListener?.('close', handleSocketClose)\n\t\tsocket.addEventListener?.('error', handleSocketError)\n\t}\n\n\t/**\n\t * Processes a message received from a client WebSocket. Use this method in server\n\t * environments where WebSocket event listeners cannot be attached directly to socket\n\t * instances (e.g., Bun.serve, Cloudflare Workers with WebSocket hibernation).\n\t *\n\t * The method handles message chunking/reassembly and forwards complete messages\n\t * to the underlying sync room for processing.\n\t *\n\t * @param sessionId - Session identifier matching the one used in handleSocketConnect\n\t * @param message - Raw message data from the client (string or binary)\n\t *\n\t * @example\n\t * ```ts\n\t * // In a Bun.serve handler\n\t * server.upgrade(req, {\n\t *   data: { sessionId, room },\n\t *   upgrade(res, req) {\n\t *     // Connection established\n\t *   },\n\t *   message(ws, message) {\n\t *     const { sessionId, room } = ws.data\n\t *     room.handleSocketMessage(sessionId, message)\n\t *   }\n\t * })\n\t * ```\n\t */\n\thandleSocketMessage(sessionId: string, message: string | AllowSharedBufferSource) {\n\t\tconst assembler = this.sessions.get(sessionId)?.assembler\n\t\tif (!assembler) {\n\t\t\tthis.log?.warn?.('Received message from unknown session', sessionId)\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\tconst messageString =\n\t\t\t\ttypeof message === 'string' ? message : new TextDecoder().decode(message)\n\t\t\tconst res = assembler.handleMessage(messageString)\n\t\t\tif (!res) {\n\t\t\t\t// not enough chunks yet\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif ('data' in res) {\n\t\t\t\t// need to do this first in case the session gets removed as a result of handling the message\n\t\t\t\tif (this.opts.onAfterReceiveMessage) {\n\t\t\t\t\tconst session = this.room.sessions.get(sessionId)\n\t\t\t\t\tif (session) {\n\t\t\t\t\t\tthis.opts.onAfterReceiveMessage({\n\t\t\t\t\t\t\tsessionId,\n\t\t\t\t\t\t\tmessage: res.data as any,\n\t\t\t\t\t\t\tstringified: res.stringified,\n\t\t\t\t\t\t\tmeta: session.meta,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.room.handleMessage(sessionId, res.data as any)\n\t\t\t} else {\n\t\t\t\tthis.log?.error?.('Error assembling message', res.error)\n\t\t\t\t// close the socket to reset the connection\n\t\t\t\tthis.handleSocketError(sessionId)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.log?.error?.(e)\n\t\t\t// here we use rejectSession rather than removeSession to support legacy clients\n\t\t\t// that use the old incompatibility_error close event\n\t\t\tthis.room.rejectSession(sessionId, TLSyncErrorCloseEventReason.UNKNOWN_ERROR)\n\t\t}\n\t}\n\n\t/**\n\t * Handles a WebSocket error for the specified session. Use this in server environments\n\t * where socket event listeners cannot be attached directly. This will initiate cleanup\n\t * and session removal for the affected client.\n\t *\n\t * @param sessionId - Session identifier matching the one used in handleSocketConnect\n\t *\n\t * @example\n\t * ```ts\n\t * // In a custom WebSocket handler\n\t * socket.addEventListener('error', () => {\n\t *   room.handleSocketError(sessionId)\n\t * })\n\t * ```\n\t */\n\thandleSocketError(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * Handles a WebSocket close event for the specified session. Use this in server\n\t * environments where socket event listeners cannot be attached directly. This will\n\t * initiate cleanup and session removal for the disconnected client.\n\t *\n\t * @param sessionId - Session identifier matching the one used in handleSocketConnect\n\t *\n\t * @example\n\t * ```ts\n\t * // In a custom WebSocket handler\n\t * socket.addEventListener('close', () => {\n\t *   room.handleSocketClose(sessionId)\n\t * })\n\t * ```\n\t */\n\thandleSocketClose(sessionId: string) {\n\t\tthis.room.handleClose(sessionId)\n\t}\n\n\t/**\n\t * Returns the current document clock value. The clock is a monotonically increasing\n\t * integer that increments with each document change, providing a consistent ordering\n\t * of changes across the distributed system.\n\t *\n\t * @returns The current document clock value\n\t *\n\t * @example\n\t * ```ts\n\t * const clock = room.getCurrentDocumentClock()\n\t * console.log(`Document is at version ${clock}`)\n\t * ```\n\t */\n\tgetCurrentDocumentClock() {\n\t\treturn this.room.documentClock\n\t}\n\n\t/**\n\t * Retrieves a deeply cloned copy of a record from the document store.\n\t * Returns undefined if the record doesn't exist. The returned record is\n\t * safe to mutate without affecting the original store data.\n\t *\n\t * @param id - Unique identifier of the record to retrieve\n\t * @returns Deep clone of the record, or undefined if not found\n\t *\n\t * @example\n\t * ```ts\n\t * const shape = room.getRecord('shape:abc123')\n\t * if (shape) {\n\t *   console.log('Shape position:', shape.x, shape.y)\n\t *   // Safe to modify without affecting store\n\t *   shape.x = 100\n\t * }\n\t * ```\n\t */\n\tgetRecord(id: string) {\n\t\treturn structuredClone(this.room.documents.get(id)?.state)\n\t}\n\n\t/**\n\t * Returns information about all active sessions in the room. Each session\n\t * represents a connected client with their current connection status and metadata.\n\t *\n\t * @returns Array of session information objects containing:\n\t *   - sessionId - Unique session identifier\n\t *   - isConnected - Whether the session has an active WebSocket connection\n\t *   - isReadonly - Whether the session can modify the document\n\t *   - meta - Custom session metadata\n\t *\n\t * @example\n\t * ```ts\n\t * const sessions = room.getSessions()\n\t * console.log(`Room has ${sessions.length} active sessions`)\n\t *\n\t * for (const session of sessions) {\n\t *   console.log(`${session.sessionId}: ${session.isConnected ? 'online' : 'offline'}`)\n\t *   if (session.isReadonly) {\n\t *     console.log('  (read-only access)')\n\t *   }\n\t * }\n\t * ```\n\t */\n\tgetSessions(): Array<{\n\t\tsessionId: string\n\t\tisConnected: boolean\n\t\tisReadonly: boolean\n\t\tmeta: SessionMeta\n\t}> {\n\t\treturn [...this.room.sessions.values()].map((session) => {\n\t\t\treturn {\n\t\t\t\tsessionId: session.sessionId,\n\t\t\t\tisConnected: session.state === RoomSessionState.Connected,\n\t\t\t\tisReadonly: session.isReadonly,\n\t\t\t\tmeta: session.meta,\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Creates a complete snapshot of the current document state, including all records\n\t * and synchronization metadata. This snapshot can be persisted to storage and used\n\t * to restore the room state later or revert to a previous version.\n\t *\n\t * @returns Complete room snapshot including documents, clock values, and tombstones\n\t *\n\t * @example\n\t * ```ts\n\t * // Capture current state for persistence\n\t * const snapshot = room.getCurrentSnapshot()\n\t * await saveToDatabase(roomId, JSON.stringify(snapshot))\n\t *\n\t * // Later, restore from snapshot\n\t * const savedSnapshot = JSON.parse(await loadFromDatabase(roomId))\n\t * const newRoom = new TLSocketRoom({ initialSnapshot: savedSnapshot })\n\t * ```\n\t */\n\tgetCurrentSnapshot() {\n\t\treturn this.room.getSnapshot()\n\t}\n\n\t/**\n\t * Retrieves all presence records from the document store. Presence records\n\t * contain ephemeral user state like cursor positions and selections.\n\t *\n\t * @returns Object mapping record IDs to presence record data\n\t * @internal\n\t */\n\tgetPresenceRecords() {\n\t\tconst result = {} as Record<string, UnknownRecord>\n\t\tfor (const document of this.room.documents.values()) {\n\t\t\tif (document.state.typeName === this.room.presenceType?.typeName) {\n\t\t\t\tresult[document.state.id] = document.state\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Returns a JSON-serialized snapshot of the current document state. This is\n\t * equivalent to JSON.stringify(getCurrentSnapshot()) but provided as a convenience.\n\t *\n\t * @returns JSON string representation of the room snapshot\n\t * @internal\n\t */\n\tgetCurrentSerializedSnapshot() {\n\t\treturn JSON.stringify(this.room.getSnapshot())\n\t}\n\n\t/**\n\t * Loads a document snapshot, completely replacing the current room state.\n\t * This will disconnect all current clients and update the document to match\n\t * the provided snapshot. Use this for restoring from backups or implementing\n\t * document versioning.\n\t *\n\t * @param snapshot - Room or store snapshot to load\n\t *\n\t * @example\n\t * ```ts\n\t * // Restore from a saved snapshot\n\t * const backup = JSON.parse(await loadBackup(roomId))\n\t * room.loadSnapshot(backup)\n\t *\n\t * // All clients will be disconnected and need to reconnect\n\t * // to see the restored document state\n\t * ```\n\t */\n\tloadSnapshot(snapshot: RoomSnapshot | TLStoreSnapshot) {\n\t\tif ('store' in snapshot) {\n\t\t\tsnapshot = convertStoreSnapshotToRoomSnapshot(snapshot)\n\t\t}\n\t\tconst oldRoom = this.room\n\t\tconst oldRoomSnapshot = oldRoom.getSnapshot()\n\t\tconst oldIds = oldRoomSnapshot.documents.map((d) => d.state.id)\n\t\tconst newIds = new Set(snapshot.documents.map((d) => d.state.id))\n\t\tconst removedIds = oldIds.filter((id) => !newIds.has(id))\n\n\t\tconst tombstones: RoomSnapshot['tombstones'] = { ...oldRoomSnapshot.tombstones }\n\t\tremovedIds.forEach((id) => {\n\t\t\ttombstones[id] = oldRoom.clock + 1\n\t\t})\n\t\tnewIds.forEach((id) => {\n\t\t\tdelete tombstones[id]\n\t\t})\n\n\t\tconst newRoom = new TLSyncRoom<R, SessionMeta>({\n\t\t\t...this.syncCallbacks,\n\t\t\tschema: oldRoom.schema,\n\t\t\tsnapshot: {\n\t\t\t\tclock: oldRoom.clock + 1,\n\t\t\t\tdocumentClock: oldRoom.clock + 1,\n\t\t\t\tdocuments: snapshot.documents.map((d) => ({\n\t\t\t\t\tlastChangedClock: oldRoom.clock + 1,\n\t\t\t\t\tstate: d.state,\n\t\t\t\t})),\n\t\t\t\tschema: snapshot.schema,\n\t\t\t\ttombstones,\n\t\t\t\ttombstoneHistoryStartsAtClock: oldRoomSnapshot.tombstoneHistoryStartsAtClock,\n\t\t\t},\n\t\t\tlog: this.log,\n\t\t})\n\t\t// replace room with new one and kick out all the clients\n\t\tthis.room = newRoom\n\t\toldRoom.close()\n\t}\n\n\t/**\n\t * Executes a transaction to modify the document store. Changes made within the\n\t * transaction are atomic and will be synchronized to all connected clients.\n\t * The transaction provides isolation from concurrent changes until it commits.\n\t *\n\t * @param updater - Function that receives store methods to make changes\n\t *   - store.get(id) - Retrieve a record (safe to mutate, but must call put() to commit)\n\t *   - store.put(record) - Save a modified record\n\t *   - store.getAll() - Get all records in the store\n\t *   - store.delete(id) - Remove a record from the store\n\t * @returns Promise that resolves when the transaction completes\n\t *\n\t * @example\n\t * ```ts\n\t * // Update multiple shapes in a single transaction\n\t * await room.updateStore(store => {\n\t *   const shape1 = store.get('shape:abc123')\n\t *   const shape2 = store.get('shape:def456')\n\t *\n\t *   if (shape1) {\n\t *     shape1.x = 100\n\t *     store.put(shape1)\n\t *   }\n\t *\n\t *   if (shape2) {\n\t *     shape2.meta.approved = true\n\t *     store.put(shape2)\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * @example\n\t * ```ts\n\t * // Async transaction with external API call\n\t * await room.updateStore(async store => {\n\t *   const doc = store.get('document:main')\n\t *   if (doc) {\n\t *     doc.lastModified = await getCurrentTimestamp()\n\t *     store.put(doc)\n\t *   }\n\t * })\n\t * ```\n\t */\n\tasync updateStore(updater: (store: RoomStoreMethods<R>) => void | Promise<void>) {\n\t\treturn this.room.updateStore(updater)\n\t}\n\n\t/**\n\t * Sends a custom message to a specific client session. This allows sending\n\t * application-specific data that doesn't modify the document state, such as\n\t * notifications, chat messages, or custom commands.\n\t *\n\t * @param sessionId - Target session identifier\n\t * @param data - Custom payload to send (will be JSON serialized)\n\t *\n\t * @example\n\t * ```ts\n\t * // Send a notification to a specific user\n\t * room.sendCustomMessage('session-123', {\n\t *   type: 'notification',\n\t *   message: 'Your changes have been saved'\n\t * })\n\t *\n\t * // Send a chat message\n\t * room.sendCustomMessage('session-456', {\n\t *   type: 'chat',\n\t *   from: 'Alice',\n\t *   text: 'Great work on this design!'\n\t * })\n\t * ```\n\t */\n\tsendCustomMessage(sessionId: string, data: any) {\n\t\tthis.room.sendCustomMessage(sessionId, data)\n\t}\n\n\t/**\n\t * Immediately removes a session from the room and closes its WebSocket connection.\n\t * The client will attempt to reconnect automatically unless a fatal reason is provided.\n\t *\n\t * @param sessionId - Session identifier to remove\n\t * @param fatalReason - Optional fatal error reason that prevents reconnection\n\t *\n\t * @example\n\t * ```ts\n\t * // Kick a user (they can reconnect)\n\t * room.closeSession('session-troublemaker')\n\t *\n\t * // Permanently ban a user\n\t * room.closeSession('session-banned', 'PERMISSION_DENIED')\n\t *\n\t * // Close session due to inactivity\n\t * room.closeSession('session-idle', 'TIMEOUT')\n\t * ```\n\t */\n\tcloseSession(sessionId: string, fatalReason?: TLSyncErrorCloseEventReason | string) {\n\t\tthis.room.rejectSession(sessionId, fatalReason)\n\t}\n\n\t/**\n\t * Closes the room and disconnects all connected clients. This should be called\n\t * when shutting down the room permanently, such as during server shutdown or\n\t * when the room is no longer needed. Once closed, the room cannot be reopened.\n\t *\n\t * @example\n\t * ```ts\n\t * // Clean shutdown when no users remain\n\t * if (room.getNumActiveSessions() === 0) {\n\t *   await persistSnapshot(room.getCurrentSnapshot())\n\t *   room.close()\n\t * }\n\t *\n\t * // Server shutdown\n\t * process.on('SIGTERM', () => {\n\t *   for (const room of activeRooms.values()) {\n\t *     room.close()\n\t *   }\n\t * })\n\t * ```\n\t */\n\tclose() {\n\t\tthis.room.close()\n\t}\n\n\t/**\n\t * Checks whether the room has been permanently closed. Closed rooms cannot\n\t * accept new connections or process further changes.\n\t *\n\t * @returns True if the room is closed, false if still active\n\t *\n\t * @example\n\t * ```ts\n\t * if (room.isClosed()) {\n\t *   console.log('Room has been shut down')\n\t *   // Create a new room or redirect users\n\t * } else {\n\t *   // Room is still accepting connections\n\t *   room.handleSocketConnect({ sessionId, socket })\n\t * }\n\t * ```\n\t */\n\tisClosed() {\n\t\treturn this.room.isClosed()\n\t}\n}\n\n/**\n * Utility type that removes properties with void values from an object type.\n * This is used internally to conditionally require session metadata based on\n * whether SessionMeta extends void.\n *\n * @example\n * ```ts\n * type Example = { a: string, b: void, c: number }\n * type Result = OmitVoid<Example> // { a: string, c: number }\n * ```\n *\n * @public\n */\nexport type OmitVoid<T, KS extends keyof T = keyof T> = {\n\t[K in KS extends any ? (void extends T[KS] ? never : KS) : never]: T[K]\n}\n\nfunction convertStoreSnapshotToRoomSnapshot(snapshot: TLStoreSnapshot): RoomSnapshot {\n\treturn {\n\t\tclock: 0,\n\t\tdocumentClock: 0,\n\t\tdocuments: objectMapValues(snapshot.store).map((state) => ({\n\t\t\tstate,\n\t\t\tlastChangedClock: 0,\n\t\t})),\n\t\tschema: snapshot.schema,\n\t\ttombstones: {},\n\t}\n}\n"],"names":[],"mappings":";;;;;AACA,SAA0B,sBAAsB;;;AAChD,SAAS,iBAAiB,uBAAuB;AACjD,SAAS,wBAAwB;AACjC,SAAS,2BAA6C;AACtD,SAAS,mCAAmC;AAC5C,SAAyC,kBAAkB;AAC3D,SAAS,0BAA0B;;;;;;;;AA4F5B,MAAM,aAA0E;IAAA;;;;;;;;;;;;;GAAA,GA2BtF,YACiB,IAAA,CAiCf;QAjCe,IAAA,CAAA,IAAA,GAAA;QAkChB,MAAM,kBACL,KAAK,eAAA,IAAmB,WAAW,KAAK,eAAA,GACrC,mCAAmC,KAAK,eAAgB,IACxD,KAAK,eAAA;QAET,IAAA,CAAK,aAAA,GAAgB;YACpB,cAAc,KAAK,YAAA;YACnB,kBAAkB,KAAK,gBAAA;QACxB;QACA,IAAA,CAAK,IAAA,GAAO,IAAI,2LAAA,CAA2B;YAC1C,GAAG,IAAA,CAAK,aAAA;YACR,QAAQ,KAAK,MAAA,QAAW,wLAAA,CAAe;YACvC,UAAU;YACV,KAAK,KAAK,GAAA;QACX,CAAC;QACD,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,EAAA,CAAG,mBAAmB,CAAC,SAAS;YAChD,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,KAAK,SAAS;YACnC,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;gBAC/B,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAiB,IAAA,EAAM;oBAChC,WAAW,KAAK,SAAA;oBAChB,sBAAsB,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA;oBACzC,MAAM,KAAK,IAAA;gBACZ,CAAC;YACF;QACD,CAAC;QACD,IAAA,CAAK,GAAA,GAAM,SAAS,OAAO,KAAK,GAAA,GAAM;YAAE,OAAO,QAAQ,KAAA;QAAM;IAC9D;IAvFQ,KAAA;IACS,WAAW,aAAA,GAAA,IAAI,IAI9B,EAAA;IACO,IAAA;IACQ,cAAA;IAAA;;;;;;GAAA,GAyFjB,uBAAuB;QACtB,OAAO,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA;IAC3B;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GAiCA,oBACC,IAAA,EAKC;QACD,MAAM,EAAE,SAAA,EAAW,MAAA,EAAQ,aAAa,KAAA,CAAM,CAAA,GAAI;QAClD,MAAM,sBAAsB,CAAC,QAC5B,IAAA,CAAK,mBAAA,CAAoB,WAAW,MAAM,IAAI;QAC/C,MAAM,oBAAoB,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,IAAA,EAAM,SAAS;QACrE,MAAM,oBAAoB,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,IAAA,EAAM,SAAS;QAErE,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,WAAW;YAC5B,WAAW,IAAI,8LAAA,CAAmB;YAClC;YACA,UAAU,MAAM;gBACf,OAAO,mBAAA,GAAsB,WAAW,mBAAmB;gBAC3D,OAAO,mBAAA,GAAsB,SAAS,iBAAiB;gBACvD,OAAO,mBAAA,GAAsB,SAAS,iBAAiB;YACxD;QACD,CAAC;QAED,IAAA,CAAK,IAAA,CAAK,gBAAA,CAAiB;YAC1B;YACA;YACA,QAAQ,IAAI,6MAAA,CAAoB;gBAC/B,IAAI;gBACJ,qBAAqB,IAAA,CAAK,IAAA,CAAK,mBAAA,GAC5B,CAAC,SAAS,cACV,IAAA,CAAK,IAAA,CAAK,mBAAA,CAAqB;wBAC9B;wBACA;wBACA;wBACA,MAAM,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAS,GAAG;oBAC1C,CAAC,IACD,KAAA;YACJ,CAAC;YACD,MAAM,UAAU,OAAQ,KAAK,IAAA,GAAe,KAAA;QAC7C,CAAC;QAED,OAAO,gBAAA,GAAmB,WAAW,mBAAmB;QACxD,OAAO,gBAAA,GAAmB,SAAS,iBAAiB;QACpD,OAAO,gBAAA,GAAmB,SAAS,iBAAiB;IACrD;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA4BA,oBAAoB,SAAA,EAAmB,OAAA,EAA2C;QACjF,MAAM,YAAY,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAS,GAAG;QAChD,IAAI,CAAC,WAAW;YACf,IAAA,CAAK,GAAA,EAAK,OAAO,yCAAyC,SAAS;YACnE;QACD;QAEA,IAAI;YACH,MAAM,gBACL,OAAO,YAAY,WAAW,UAAU,IAAI,YAAY,EAAE,MAAA,CAAO,OAAO;YACzE,MAAM,MAAM,UAAU,aAAA,CAAc,aAAa;YACjD,IAAI,CAAC,KAAK;gBAET;YACD;YACA,IAAI,UAAU,KAAK;gBAElB,IAAI,IAAA,CAAK,IAAA,CAAK,qBAAA,EAAuB;oBACpC,MAAM,UAAU,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAS;oBAChD,IAAI,SAAS;wBACZ,IAAA,CAAK,IAAA,CAAK,qBAAA,CAAsB;4BAC/B;4BACA,SAAS,IAAI,IAAA;4BACb,aAAa,IAAI,WAAA;4BACjB,MAAM,QAAQ,IAAA;wBACf,CAAC;oBACF;gBACD;gBAEA,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,WAAW,IAAI,IAAW;YACnD,OAAO;gBACN,IAAA,CAAK,GAAA,EAAK,QAAQ,4BAA4B,IAAI,KAAK;gBAEvD,IAAA,CAAK,iBAAA,CAAkB,SAAS;YACjC;QACD,EAAA,OAAS,GAAG;YACX,IAAA,CAAK,GAAA,EAAK,QAAQ,CAAC;YAGnB,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,WAAW,8MAAA,CAA4B,aAAa;QAC7E;IACD;IAAA;;;;;;;;;;;;;;GAAA,GAiBA,kBAAkB,SAAA,EAAmB;QACpC,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,SAAS;IAChC;IAAA;;;;;;;;;;;;;;GAAA,GAiBA,kBAAkB,SAAA,EAAmB;QACpC,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,SAAS;IAChC;IAAA;;;;;;;;;;;;GAAA,GAeA,0BAA0B;QACzB,OAAO,IAAA,CAAK,IAAA,CAAK,aAAA;IAClB;IAAA;;;;;;;;;;;;;;;;;GAAA,GAoBA,UAAU,EAAA,EAAY;QACrB,WAAO,oLAAA,EAAgB,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,EAAE,GAAG,KAAK;IAC1D;IAAA;;;;;;;;;;;;;;;;;;;;;;GAAA,GAyBA,cAKG;QACF,OAAO,CAAC;eAAG,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,CAAC;SAAA,CAAE,GAAA,CAAI,CAAC,YAAY;YACxD,OAAO;gBACN,WAAW,QAAQ,SAAA;gBACnB,aAAa,QAAQ,KAAA,KAAU,kMAAA,CAAiB,SAAA;gBAChD,YAAY,QAAQ,UAAA;gBACpB,MAAM,QAAQ,IAAA;YACf;QACD,CAAC;IACF;IAAA;;;;;;;;;;;;;;;;;GAAA,GAoBA,qBAAqB;QACpB,OAAO,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY;IAC9B;IAAA;;;;;;GAAA,GASA,qBAAqB;QACpB,MAAM,SAAS,CAAC;QAChB,KAAA,MAAW,YAAY,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,EAAG;YACpD,IAAI,SAAS,KAAA,CAAM,QAAA,KAAa,IAAA,CAAK,IAAA,CAAK,YAAA,EAAc,UAAU;gBACjE,MAAA,CAAO,SAAS,KAAA,CAAM,EAAE,CAAA,GAAI,SAAS,KAAA;YACtC;QACD;QACA,OAAO;IACR;IAAA;;;;;;GAAA,GASA,+BAA+B;QAC9B,OAAO,KAAK,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,CAAC;IAC9C;IAAA;;;;;;;;;;;;;;;;;GAAA,GAoBA,aAAa,QAAA,EAA0C;QACtD,IAAI,WAAW,UAAU;YACxB,WAAW,mCAAmC,QAAQ;QACvD;QACA,MAAM,UAAU,IAAA,CAAK,IAAA;QACrB,MAAM,kBAAkB,QAAQ,WAAA,CAAY;QAC5C,MAAM,SAAS,gBAAgB,SAAA,CAAU,GAAA,CAAI,CAAC,IAAM,EAAE,KAAA,CAAM,EAAE;QAC9D,MAAM,SAAS,IAAI,IAAI,SAAS,SAAA,CAAU,GAAA,CAAI,CAAC,IAAM,EAAE,KAAA,CAAM,EAAE,CAAC;QAChE,MAAM,aAAa,OAAO,MAAA,CAAO,CAAC,KAAO,CAAC,OAAO,GAAA,CAAI,EAAE,CAAC;QAExD,MAAM,aAAyC;YAAE,GAAG,gBAAgB,UAAA;QAAW;QAC/E,WAAW,OAAA,CAAQ,CAAC,OAAO;YAC1B,UAAA,CAAW,EAAE,CAAA,GAAI,QAAQ,KAAA,GAAQ;QAClC,CAAC;QACD,OAAO,OAAA,CAAQ,CAAC,OAAO;YACtB,OAAO,UAAA,CAAW,EAAE,CAAA;QACrB,CAAC;QAED,MAAM,UAAU,IAAI,2LAAA,CAA2B;YAC9C,GAAG,IAAA,CAAK,aAAA;YACR,QAAQ,QAAQ,MAAA;YAChB,UAAU;gBACT,OAAO,QAAQ,KAAA,GAAQ;gBACvB,eAAe,QAAQ,KAAA,GAAQ;gBAC/B,WAAW,SAAS,SAAA,CAAU,GAAA,CAAI,CAAC,IAAA,CAAO;wBACzC,kBAAkB,QAAQ,KAAA,GAAQ;wBAClC,OAAO,EAAE,KAAA;oBACV,CAAA,CAAE;gBACF,QAAQ,SAAS,MAAA;gBACjB;gBACA,+BAA+B,gBAAgB,6BAAA;YAChD;YACA,KAAK,IAAA,CAAK,GAAA;QACX,CAAC;QAED,IAAA,CAAK,IAAA,GAAO;QACZ,QAAQ,KAAA,CAAM;IACf;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA6CA,MAAM,YAAY,OAAA,EAA+D;QAChF,OAAO,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,OAAO;IACrC;IAAA;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA0BA,kBAAkB,SAAA,EAAmB,IAAA,EAAW;QAC/C,IAAA,CAAK,IAAA,CAAK,iBAAA,CAAkB,WAAW,IAAI;IAC5C;IAAA;;;;;;;;;;;;;;;;;;GAAA,GAqBA,aAAa,SAAA,EAAmB,WAAA,EAAoD;QACnF,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,WAAW,WAAW;IAC/C;IAAA;;;;;;;;;;;;;;;;;;;;GAAA,GAuBA,QAAQ;QACP,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM;IACjB;IAAA;;;;;;;;;;;;;;;;GAAA,GAmBA,WAAW;QACV,OAAO,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS;IAC3B;AACD;AAmBA,SAAS,mCAAmC,QAAA,EAAyC;IACpF,OAAO;QACN,OAAO;QACP,eAAe;QACf,eAAW,qLAAA,EAAgB,SAAS,KAAK,EAAE,GAAA,CAAI,CAAC,QAAA,CAAW;gBAC1D;gBACA,kBAAkB;YACnB,CAAA,CAAE;QACF,QAAQ,SAAS,MAAA;QACjB,YAAY,CAAC;IACd;AACD","debugId":null}},
    {"offset": {"line": 3295, "column": 0}, "map": {"version":3,"sources":["file:///Users/buyantogtokh/Documents/calhacks12/node_modules/%40tldraw/sync-core/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { chunk } from './lib/chunk'\nexport { ClientWebSocketAdapter, ReconnectManager } from './lib/ClientWebSocketAdapter'\nexport {\n\tapplyObjectDiff,\n\tdiffRecord,\n\tgetNetworkDiff,\n\tRecordOpType,\n\tValueOpType,\n\ttype AppendOp,\n\ttype DeleteOp,\n\ttype NetworkDiff,\n\ttype ObjectDiff,\n\ttype PatchOp,\n\ttype PutOp,\n\ttype RecordOp,\n\ttype ValueOp,\n} from './lib/diff'\nexport {\n\tgetTlsyncProtocolVersion,\n\tTLIncompatibilityReason,\n\ttype TLConnectRequest,\n\ttype TLPingRequest,\n\ttype TLPushRequest,\n\ttype TLSocketClientSentEvent,\n\ttype TLSocketServerSentDataEvent,\n\ttype TLSocketServerSentEvent,\n} from './lib/protocol'\nexport { RoomSessionState, type RoomSession } from './lib/RoomSession'\nexport type { PersistedRoomSnapshotForSupabase } from './lib/server-types'\nexport type { WebSocketMinimal } from './lib/ServerSocketAdapter'\nexport { TLRemoteSyncError } from './lib/TLRemoteSyncError'\nexport { TLSocketRoom, type OmitVoid, type TLSyncLog } from './lib/TLSocketRoom'\nexport {\n\tTLSyncClient,\n\tTLSyncErrorCloseEventCode,\n\tTLSyncErrorCloseEventReason,\n\ttype SubscribingFn,\n\ttype TLCustomMessageHandler,\n\ttype TLPersistentClientSocket,\n\ttype TLPersistentClientSocketStatus,\n\ttype TLPresenceMode,\n\ttype TlSocketStatusChangeEvent,\n\ttype TLSocketStatusListener,\n} from './lib/TLSyncClient'\nexport {\n\tDocumentState,\n\tTLSyncRoom,\n\ttype RoomSnapshot,\n\ttype RoomStoreMethods,\n\ttype TLRoomSocket,\n} from './lib/TLSyncRoom'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,SAAS,aAAa;AACtB,SAAS,wBAAwB,wBAAwB;AACzD;AAeA;AAUA,SAAS,wBAA0C;AAGnD,SAAS,yBAAyB;AAClC,SAAS,oBAAmD;AAC5D;AAYA;;;;;;;;;;;IAQA,mMAAA,EACE,qBACA,SACA","debugId":null}}]
}